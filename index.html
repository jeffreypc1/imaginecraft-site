<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>ImagineCraft Studios</title>
    <!-- Dynamic Cache Buster: Appends timestamp to CSS/JS resources to bypass CDN caching -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Playfair+Display:wght@400;600&family=VT323&display=swap" rel="stylesheet">
    <script>
        // Generate timestamp once for consistent cache busting across all resources
        var CACHE_TIMESTAMP = Date.now();
        // Write CSS link with dynamic timestamp to bypass GitHub CDN caching
        document.write('<link rel="stylesheet" href="style.css?v=' + CACHE_TIMESTAMP + '">');
    </script>
    <noscript><link rel="stylesheet" href="style.css"></noscript>
</head>
<body>
    <!-- Boot Sequence Overlay -->
    <div id="bootSequenceOverlay" class="boot-sequence-overlay">
        <div class="boot-diagnostics" id="bootDiagnostics">
            <!-- Boot lines will be dynamically typed character-by-character from Firebase bootScript -->
        </div>
    </div>

    <main class="explore-page" role="main">
        <div class="explore-container">
            <!-- Question and cursor area -->
            <div class="explore-question-area">
                <h1 class="explore-question" id="exploreQuestion"></h1>
                <!-- Cursor and thoughts inline together -->
                <div class="explore-cursor-line">
                    <div class="explore-thought-container" aria-live="polite" aria-atomic="true">
                        <button
                            class="explore-thought"
                            id="currentThought"
                            tabindex="0"
                            aria-label="Click to select this thought"
                        ></button>
                    </div><span class="explore-cursor" id="exploreCursor" aria-hidden="true">â–ˆ</span>
                    <!-- Optional: text input appears here when user starts typing -->
                    <input
                        type="text"
                        class="explore-input"
                        id="exploreInput"
                        placeholder=""
                        aria-label="Type your own response"
                        autocomplete="off"
                    >
                </div>
                <!-- Choice buttons for Yes/No interaction -->
                <div class="choice-buttons-container" id="choiceButtonsContainer" hidden>
                    <button class="choice-btn choice-btn-yes" id="choiceBtnYes">Yes</button>
                    <button class="choice-btn choice-btn-no" id="choiceBtnNo">No</button>
                </div>
                <!-- New Question button (appears after No selection) -->
                <button class="new-question-btn" id="newQuestionBtnChoice">New Question</button>
            </div>

            <!-- Response panels (hidden by default) -->
            <div class="explore-panels" id="explorePanels" aria-live="polite">
                <!-- Panel 1: I have ideas -->
                <article class="explore-panel" data-thought="0" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn0"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn0">New Question</button>
                    </div>
                </article>

                <!-- Panel 2: I don't know where to start -->
                <article class="explore-panel" data-thought="1" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn1"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn1">New Question</button>
                    </div>
                </article>

                <!-- Panel 3: Our tools don't fit us -->
                <article class="explore-panel" data-thought="2" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn2"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn2">New Question</button>
                    </div>
                </article>

                <!-- Panel 4: I want software that matches how we work -->
                <article class="explore-panel" data-thought="3" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn3"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn3">New Question</button>
                    </div>
                </article>

                <!-- Panel 5: Help us think this through -->
                <article class="explore-panel" data-thought="4" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn4"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn4">New Question</button>
                    </div>
                </article>

                <!-- Panel 6: Who are you? -->
                <article class="explore-panel" data-thought="5" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn5"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 7: I need something custom -->
                <article class="explore-panel" data-thought="6" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn6"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 8: Our budget is limited -->
                <article class="explore-panel" data-thought="7" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn7"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 9: We've tried this before -->
                <article class="explore-panel" data-thought="8" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn8"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 10: How long will it take? -->
                <article class="explore-panel" data-thought="9" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn9"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 11: Can you work with our team? -->
                <article class="explore-panel" data-thought="10" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn10"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 12: What makes you different? -->
                <article class="explore-panel" data-thought="11" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn11"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Generic panel for typed input -->
                <article class="explore-panel" data-thought="custom" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtnCustom"><span class="action-text"></span></button>
                    </div>
                </article>
            </div>

        </div>
    </main>

    <!-- Multimedia Modal (for video/image actions) -->
    <div class="modal-overlay" id="multimediaModal" onclick="closeMultimediaModalOnOverlay(event)">
        <div class="modal-content multimedia-modal-content" role="dialog" aria-modal="true" aria-labelledby="multimediaTitle">
            <button class="modal-close" onclick="closeMultimediaModal()" aria-label="Close modal">&times;</button>
            <div id="multimediaContent" class="multimedia-container">
                <!-- Video iframe or image will be inserted here -->
            </div>
        </div>
    </div>

    <!-- The Matrix Canvas (for falling 0s and 1s animation) -->
    <canvas id="matrixCanvas" class="matrix-canvas"></canvas>

    <!-- ASCII Logo Container (for permanent terminal logos) -->
    <div id="asciiLogoContainer" class="ascii-logo-container"></div>

    <!-- Main Site Background Layer (z-index: 1) - Always loaded behind terminal -->
    <div id="mainSiteBackground" class="main-site-background">
        <iframe id="mainSiteFrame" src="" title="Main Site"></iframe>
    </div>

    <!-- Terminal Overlay Shell (z-index: 2) - Splits during earthquake transition -->
    <div id="terminalOverlay" class="terminal-overlay">
        <div class="terminal-half terminal-half-left"></div>
        <div class="terminal-half terminal-half-right"></div>
    </div>

    <!-- Contact Modal (reused from main site) -->
    <div class="modal-overlay" id="contactModal" onclick="closeModalOnOverlay(event)">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
            <button class="modal-close" onclick="closeContactModal()" aria-label="Close modal">&times;</button>
            <h2 id="modalTitle">Get in Touch</h2>
            <form class="modal-form">
                <div class="form-group">
                    <label for="modalName">Name</label>
                    <input type="text" id="modalName" name="name" placeholder="Your name" required>
                </div>
                <div class="form-group">
                    <label for="modalEmail">Email</label>
                    <input type="email" id="modalEmail" name="email" placeholder="you@example.com" required>
                </div>
                <div class="form-group">
                    <label for="modalMessage">Message</label>
                    <textarea id="modalMessage" name="body" placeholder="Tell us about your project..." required></textarea>
                </div>
                <button type="submit" class="cta-button">Send Message</button>
            </form>
        </div>
    </div>

    <!-- Name Capture Modal -->
    <div class="modal-overlay" id="nameModal" onclick="closeModalOnOverlay(event)">
        <div class="modal-content name-modal-content" role="dialog" aria-modal="true" aria-labelledby="nameModalTitle">
            <button class="modal-close" onclick="closeNameModal()" aria-label="Close modal">&times;</button>
            <h2 id="nameModalTitle">Identity Recognition</h2>
            <p class="name-modal-subtitle">Please enter your designation for system records.</p>
            <form class="modal-form" onsubmit="saveUserName(event)">
                <div class="form-group">
                    <label for="userName">Name</label>
                    <input type="text" id="userName" name="userName" placeholder="Enter your name" required autofocus>
                </div>
                <button type="submit" class="cta-button">Confirm</button>
            </form>
        </div>
    </div>

    <style>
        /* Boot Sequence Styles */
        .boot-sequence-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000 !important;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
            font-family: 'VT323', monospace;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .boot-sequence-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .boot-sequence-overlay.removed {
            display: none;
        }

        .boot-diagnostics {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            text-align: center;
        }

        .boot-line {
            font-size: 1.2rem;
            color: var(--boot-text-color, #00ff00);
            text-shadow: var(--boot-text-shadow, 0 0 8px rgba(0, 255, 0, 0.6));
            opacity: 1;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-width: 90%;
        }

        .boot-line.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .boot-line.flicker {
            animation: crtFlicker 0.15s ease-in-out;
        }

        .boot-line .status {
            color: var(--boot-text-color, #00ff00);
        }

        @keyframes crtFlicker {
            0% { opacity: 0.3; transform: translateX(-2px); }
            25% { opacity: 1; transform: translateX(1px); }
            50% { opacity: 0.7; transform: translateX(-1px); }
            75% { opacity: 1; transform: translateX(0); }
            100% { opacity: 1; transform: translateX(0); }
        }

        /* CRT scanline effect for boot sequence */
        .boot-sequence-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1;
        }

        .boot-diagnostics,
        .boot-progress-container {
            position: relative;
            z-index: 2;
        }

        /* Hide main content during boot */
        .explore-page.boot-hidden {
            visibility: hidden;
        }

        /* Transparent Effect Styles */
        .builders-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: #2a2a2a;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .builders-container.active {
            opacity: 1;
        }

        .builders-media {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Placeholder construction scene when no media is set */
        .builders-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #87CEEB 0%, #87CEEB 60%, #8B4513 60%, #8B4513 100%);
            position: relative;
            overflow: hidden;
        }

        .scaffold {
            position: absolute;
            bottom: 40%;
            left: 20%;
            width: 200px;
            height: 300px;
            border: 8px solid #654321;
            border-bottom: none;
            background: transparent;
        }

        .scaffold::before,
        .scaffold::after {
            content: '';
            position: absolute;
            background: #654321;
        }

        .scaffold::before {
            width: 100%;
            height: 8px;
            top: 50%;
        }

        .scaffold::after {
            width: 8px;
            height: 100%;
            left: 50%;
        }

        .scaffold-2 {
            left: auto;
            right: 25%;
            height: 250px;
        }

        .builder {
            position: absolute;
            bottom: 40%;
            z-index: 2;
        }

        .builder-1 {
            left: 25%;
        }

        .builder-2 {
            right: 30%;
        }

        .builder-body {
            width: 40px;
            height: 80px;
            background: linear-gradient(180deg, #FFD700 0%, #FFD700 30%, #1E90FF 30%, #1E90FF 100%);
            border-radius: 20px 20px 5px 5px;
            position: relative;
        }

        .builder-body::before {
            content: '';
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 30px;
            background: #FFE4C4;
            border-radius: 50%;
        }

        .builder-body::after {
            content: '';
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            width: 35px;
            height: 15px;
            background: #FFD700;
            border-radius: 50% 50% 0 0;
        }

        .hammer {
            position: absolute;
            top: 10px;
            right: -30px;
            width: 8px;
            height: 40px;
            background: #8B4513;
            transform-origin: bottom center;
            animation: hammerSwing 0.8s ease-in-out infinite;
        }

        .hammer::before {
            content: '';
            position: absolute;
            top: -12px;
            left: -8px;
            width: 24px;
            height: 15px;
            background: #696969;
            border-radius: 3px;
        }

        .builder-2 .hammer {
            animation-delay: 0.4s;
        }

        @keyframes hammerSwing {
            0%, 100% { transform: rotate(-30deg); }
            50% { transform: rotate(30deg); }
        }

        .builders-text {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'VT323', monospace;
            font-size: 3rem;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            letter-spacing: 0.2em;
        }

        /* Terminal fade effect */
        .explore-page.transparent-fade {
            animation: terminalFade 3s ease-in-out forwards;
        }

        @keyframes terminalFade {
            0% {
                background-color: rgba(0, 0, 0, 1);
            }
            100% {
                background-color: rgba(0, 0, 0, 0.15);
            }
        }

        .explore-page.transparent-fade .explore-container {
            animation: textFade 3s ease-in-out forwards;
        }

        @keyframes textFade {
            0% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
            100% {
                opacity: 0.3;
            }
        }

        /* Close button for transparent effect */
        .transparent-close-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10001;
            width: 50px;
            height: 50px;
            border: 2px solid #34ff35;
            background: rgba(0, 0, 0, 0.7);
            color: #34ff35;
            font-size: 2rem;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.5s ease, transform 0.2s ease, background-color 0.2s ease;
            font-family: 'VT323', monospace;
            text-shadow: 0 0 8px rgba(52, 255, 53, 0.6);
        }

        .transparent-close-btn.visible {
            opacity: 1;
        }

        .transparent-close-btn:hover {
            background: rgba(52, 255, 53, 0.2);
            transform: scale(1.1);
        }

        /* Theater Frame Overlay - Permanent curtain frame */
        #theater-frame-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: fill;
            z-index: 10000;
            pointer-events: none;
            background: transparent;
            opacity: 1;
        }

        /* MST3K Theater Overlay - Permanent silhouettes at bottom */
        #global-mst3k-overlay {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto;
            z-index: 10001;
            pointer-events: none;
            background: transparent;
            opacity: 1;
        }
    </style>

    <script type="module">
        // ========================================
        // Firebase Configuration
        // ========================================
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, onValue } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

        // Initialize Firebase with your project credentials
        const firebaseConfig = {
            apiKey: "AIzaSyC9Ga6OROaym45ezFh_vJ2WFMVUACkMGXY",
            authDomain: "imaginecraft-live.firebaseapp.com",
            databaseURL: "https://imaginecraft-live-default-rtdb.firebaseio.com",
            projectId: "imaginecraft-live",
            storageBucket: "imaginecraft-live.firebasestorage.app",
            messagingSenderId: "962150460666",
            appId: "1:962150460666:web:382bff8cdb23c191c16d43"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // ========================================
        // State Management
        // ========================================

        // Remote configuration (loaded from Firebase)
        let remoteConfig = null;

        // Fallback hardcoded defaults (used if config.json fetch fails)
        // Helper functions to get data from remote config only
        function getConfigThoughts() {
            return remoteConfig && remoteConfig.thoughts ? [...remoteConfig.thoughts] : null;
        }
        function getConfigResponses() {
            return remoteConfig && remoteConfig.responses ? [...remoteConfig.responses] : null;
        }
        function getConfigHeroText() {
            return remoteConfig && remoteConfig.heroText ? remoteConfig.heroText : null;
        }
        function getConfigActions() {
            if (remoteConfig && remoteConfig.actions) {
                return remoteConfig.actions.map(a => ({...a}));
            }
            return null;
        }
        function getConfigActiveStates() {
            return remoteConfig && remoteConfig.activeStates ? [...remoteConfig.activeStates] : null;
        }
        function getConfigYesRedirectIndices() {
            return remoteConfig && remoteConfig.yesRedirectIndices ? [...remoteConfig.yesRedirectIndices] : null;
        }
        function getConfigNoRedirectIndices() {
            return remoteConfig && remoteConfig.noRedirectIndices ? [...remoteConfig.noRedirectIndices] : null;
        }
        function getConfigChoiceATexts() {
            return remoteConfig && remoteConfig.choiceATexts ? [...remoteConfig.choiceATexts] : null;
        }
        function getConfigChoiceBTexts() {
            return remoteConfig && remoteConfig.choiceBTexts ? [...remoteConfig.choiceBTexts] : null;
        }
        function getConfigChoiceAActions() {
            return remoteConfig && remoteConfig.choiceAActions ? remoteConfig.choiceAActions.map(a => ({...a})) : null;
        }
        function getConfigChoiceBActions() {
            return remoteConfig && remoteConfig.choiceBActions ? remoteConfig.choiceBActions.map(a => ({...a})) : null;
        }
        function getConfigTypingSpeeds() {
            return remoteConfig && remoteConfig.typingSpeeds ? [...remoteConfig.typingSpeeds] : null;
        }
        function getConfigMoods() {
            return remoteConfig && remoteConfig.moods ? [...remoteConfig.moods] : null;
        }
        function getConfigSettings() {
            if (remoteConfig && remoteConfig.settings) {
                return remoteConfig.settings;
            }
            return null;
        }
        function getConfigSecretCommands() {
            if (remoteConfig && remoteConfig.secretCommands) {
                return remoteConfig.secretCommands.map(cmd => ({...cmd}));
            }
            return null;
        }
        function getConfigBuildersMedia() {
            return remoteConfig && remoteConfig.buildersMedia ? {...remoteConfig.buildersMedia} : null;
        }
        function getConfigBootScript() {
            return remoteConfig && remoteConfig.bootScript ? remoteConfig.bootScript : null;
        }
        function getConfigGlobalAmbientAudioURL() {
            return remoteConfig && remoteConfig.globalAmbientAudioURL ? remoteConfig.globalAmbientAudioURL : '';
        }
        function getConfigSceneAudioOverrides() {
            if (remoteConfig && remoteConfig.sceneAudioOverrides) {
                return remoteConfig.sceneAudioOverrides.map(s => ({...s}));
            }
            return [];
        }

        // Firebase real-time listener for configuration
        let configLoaded = false;
        let configPromise = null;

        // Initialize Firebase listener
        function initializeFirebaseListener() {
            return new Promise((resolve) => {
                const configRef = ref(db, 'siteConfig');
                let timeoutId;

                // Set a 3-second timeout - if Firebase doesn't respond, proceed anyway
                timeoutId = setTimeout(() => {
                    if (!configLoaded) {
                        console.warn('Firebase timeout after 3 seconds - proceeding with defaults');
                        remoteConfig = null;
                        configLoaded = true;
                        resolve();
                    }
                }, 3000);

                onValue(configRef, (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        const previousTypingSpeed = remoteConfig?.settings?.typingSpeed;
                        remoteConfig = data;
                        console.log('Firebase config loaded/updated successfully');

                        // If this is the first load, resolve the promise
                        if (!configLoaded) {
                            clearTimeout(timeoutId);
                            configLoaded = true;
                            resolve();
                        } else {
                            // If config was already loaded, this is an update
                            // Check if typing speed changed - update in real-time without reload
                            const newTypingSpeed = data?.settings?.typingSpeed;
                            if (newTypingSpeed !== undefined && newTypingSpeed !== previousTypingSpeed) {
                                if (typeof updateTypingSpeed === 'function') {
                                    updateTypingSpeed(newTypingSpeed);
                                }
                            }
                            console.log('Config updated in real-time');
                        }
                    } else {
                        console.warn('No config data found in Firebase');
                        remoteConfig = null;
                        if (!configLoaded) {
                            clearTimeout(timeoutId);
                            configLoaded = true;
                            resolve();
                        }
                    }
                }, (error) => {
                    console.error('Firebase listener error:', error);
                    remoteConfig = null;
                    if (!configLoaded) {
                        clearTimeout(timeoutId);
                        configLoaded = true;
                        resolve();
                    }
                });
            });
        }

        // Start Firebase listener immediately
        configPromise = initializeFirebaseListener();

        // Load data from config only (no localStorage)
        function loadThoughts() {
            return getConfigThoughts();
        }

        function loadResponses() {
            return getConfigResponses();
        }

        function loadHeroText() {
            return getConfigHeroText();
        }

        function loadActions() {
            return getConfigActions();
        }

        function loadActiveStates() {
            return getConfigActiveStates();
        }

        function loadYesRedirectIndices() {
            return getConfigYesRedirectIndices();
        }

        function loadNoRedirectIndices() {
            return getConfigNoRedirectIndices();
        }

        function loadChoiceATexts() {
            return getConfigChoiceATexts();
        }

        function loadChoiceBTexts() {
            return getConfigChoiceBTexts();
        }

        function loadChoiceAActions() {
            return getConfigChoiceAActions();
        }

        function loadChoiceBActions() {
            return getConfigChoiceBActions();
        }

        function loadTypingSpeeds() {
            return getConfigTypingSpeeds();
        }

        function loadMoods() {
            return getConfigMoods();
        }

        function loadGlobalAmbientAudioURL() {
            return getConfigGlobalAmbientAudioURL();
        }

        function loadSceneAudioOverrides() {
            return getConfigSceneAudioOverrides();
        }

        function loadRandomizeEnabled() {
            const settings = getConfigSettings();
            return settings ? (settings.randomizeEnabled || false) : false;
        }

        function loadBootSequenceEnabled() {
            const settings = getConfigSettings();
            return settings ? (settings.bootSequenceEnabled !== undefined ? settings.bootSequenceEnabled : true) : true;
        }

        function loadBootScript() {
            const bootScript = getConfigBootScript();
            // Default boot script if none in config
            const defaultBootScript = 'CORE_INIT: OK\nMEM_LOAD: 1024KB\nDRV_MOUNT: /assets\nNET_STACK: READY\nSYS_CHECK: COMPLETE';
            return bootScript || defaultBootScript;
        }

        function loadBackgroundImageUrl() {
            return remoteConfig && remoteConfig.backgroundImageUrl ? remoteConfig.backgroundImageUrl : '';
        }

        function loadIntermissionImageUrl() {
            return remoteConfig && remoteConfig.intermissionImageUrl ? remoteConfig.intermissionImageUrl : 'https://via.placeholder.com/1920x1080?text=IMAGE+PENDING';
        }

        function loadTechDifficultyImageUrl() {
            return remoteConfig && remoteConfig.techDifficultyImageUrl ? remoteConfig.techDifficultyImageUrl : 'https://via.placeholder.com/1920x1080?text=IMAGE+PENDING';
        }

        function loadFinImageUrl() {
            return remoteConfig && remoteConfig.finImageUrl ? remoteConfig.finImageUrl : 'https://via.placeholder.com/1920x1080?text=IMAGE+PENDING';
        }

        function loadMeltdownMessage() {
            return remoteConfig && remoteConfig.meltdownMessage ? remoteConfig.meltdownMessage : 'CRITICAL SYSTEM FAILURE - INITIATING EMERGENCY SHUTDOWN';
        }

        function loadMeltdownAudioURL() {
            return remoteConfig && remoteConfig.meltdownAudioURL ? remoteConfig.meltdownAudioURL : '';
        }

        function loadMst3kOverlayURL() {
            return remoteConfig && remoteConfig.mst3kOverlayURL ? remoteConfig.mst3kOverlayURL : '';
        }

        function loadMst3kGlowIntensity() {
            return remoteConfig && remoteConfig.mst3kGlowIntensity !== undefined ? remoteConfig.mst3kGlowIntensity : 0.6;
        }

        function loadTheaterFrameURL() {
            return remoteConfig && remoteConfig.theaterFrameURL ? remoteConfig.theaterFrameURL : '';
        }

        // Background image loading state
        let backgroundImageReady = false;
        let backgroundImageLoadPromise = null;

        // Load the opening background image with 3-second timeout
        function loadOpeningBackgroundImage() {
            const backgroundImageUrl = loadBackgroundImageUrl();
            const openingBackground = document.getElementById('openingBackground');
            const openingBackgroundImage = document.getElementById('openingBackgroundImage');

            if (!backgroundImageUrl || !openingBackground || !openingBackgroundImage) {
                console.log('No background image URL configured or elements not found');
                backgroundImageReady = true;
                return Promise.resolve();
            }

            console.log('Loading background image:', backgroundImageUrl);

            backgroundImageLoadPromise = new Promise((resolve) => {
                let imageLoaded = false;
                let timeoutId;

                // Set 3-second timeout
                timeoutId = setTimeout(() => {
                    if (!imageLoaded) {
                        console.warn('Background image load timeout after 3 seconds - proceeding anyway');
                        imageLoaded = true;
                        backgroundImageReady = true;

                        // Fallback: Ensure boot overlay is removed 1 second after timeout
                        setTimeout(() => {
                            const bootOverlay = document.getElementById('bootSequenceOverlay');
                            if (bootOverlay) {
                                bootOverlay.style.display = 'none';
                                console.log('Fallback: Boot overlay forcibly hidden after image timeout');
                            }
                        }, 1000);

                        resolve();
                    }
                }, 3000);

                // Load the image
                openingBackgroundImage.onload = () => {
                    if (!imageLoaded) {
                        console.log('Background image loaded successfully');
                        clearTimeout(timeoutId);
                        imageLoaded = true;
                        backgroundImageReady = true;
                        // Don't show yet - will be revealed when boot overlay fades

                        // Fallback: Ensure boot overlay is removed 1 second after image loads
                        // This guarantees the black screen vanishes even if message channel fails
                        setTimeout(() => {
                            const bootOverlay = document.getElementById('bootSequenceOverlay');
                            if (bootOverlay) {
                                bootOverlay.style.display = 'none';
                                console.log('Fallback: Boot overlay forcibly hidden after image load');
                            }
                        }, 1000);

                        resolve();
                    }
                };

                openingBackgroundImage.onerror = () => {
                    if (!imageLoaded) {
                        console.warn('Background image failed to load');
                        clearTimeout(timeoutId);
                        imageLoaded = true;
                        backgroundImageReady = true;

                        // Fallback: Ensure boot overlay is removed 1 second after error
                        setTimeout(() => {
                            const bootOverlay = document.getElementById('bootSequenceOverlay');
                            if (bootOverlay) {
                                bootOverlay.style.display = 'none';
                                console.log('Fallback: Boot overlay forcibly hidden after image error');
                            }
                        }, 1000);

                        resolve();
                    }
                };

                // Start loading
                openingBackgroundImage.src = backgroundImageUrl;
            });

            return backgroundImageLoadPromise;
        }

        // Check if boot sequence has already played this session
        function hasBootSequencePlayedThisSession() {
            try {
                return sessionStorage.getItem('imaginecraft_boot_sequence_played') === 'true';
            } catch (e) {
                return false;
            }
        }

        // Mark boot sequence as played for this session
        function markBootSequencePlayed() {
            try {
                sessionStorage.setItem('imaginecraft_boot_sequence_played', 'true');
            } catch (e) {
                console.warn('Failed to mark boot sequence as played:', e);
            }
        }

        // ========================================
        // Cinematic State Overlays
        // ========================================

        // Initialize cinematic overlay images from Firebase config
        function initializeCinematicOverlays() {
            const intermissionImageUrl = loadIntermissionImageUrl();
            const techDifficultyImageUrl = loadTechDifficultyImageUrl();
            const finImageUrl = loadFinImageUrl();
            const mst3kOverlayURL = loadMst3kOverlayURL();
            const mst3kGlowIntensity = loadMst3kGlowIntensity();
            const theaterFrameURL = loadTheaterFrameURL();

            const intermissionImage = document.getElementById('intermissionImage');
            const techDifficultyImage = document.getElementById('techDifficultyImage');
            const finImage = document.getElementById('finImage');
            const mst3kOverlay = document.getElementById('global-mst3k-overlay');
            const theaterFrame = document.getElementById('theater-frame-overlay');

            if (intermissionImage) intermissionImage.src = intermissionImageUrl;
            if (techDifficultyImage) techDifficultyImage.src = techDifficultyImageUrl;
            if (finImage) finImage.src = finImageUrl;

            // Initialize MST3K overlay - show if URL is provided and apply glow effect
            if (mst3kOverlay && mst3kOverlayURL) {
                mst3kOverlay.src = mst3kOverlayURL;
                mst3kOverlay.style.display = 'block';
                mst3kOverlay.style.filter = `drop-shadow(0 -10px 15px rgba(0, 255, 0, ${mst3kGlowIntensity}))`;
            }

            // Initialize Theater Frame overlay - show if URL is provided and apply glow effect
            if (theaterFrame && theaterFrameURL) {
                theaterFrame.src = theaterFrameURL;
                theaterFrame.style.display = 'block';
                theaterFrame.style.filter = `drop-shadow(0 5px 15px rgba(0, 255, 0, ${mst3kGlowIntensity}))`;
            }

            console.log('Cinematic overlays initialized:', {
                intermissionImageUrl,
                techDifficultyImageUrl,
                finImageUrl,
                mst3kOverlayURL,
                theaterFrameURL
            });
        }

        // Show intermission overlay
        function showIntermissionOverlay() {
            const overlay = document.getElementById('intermissionOverlay');
            if (overlay) {
                overlay.classList.add('active');
                overlay.style.display = 'flex';
                console.log('Intermission overlay shown');
            }
        }

        // Hide intermission overlay
        function hideIntermissionOverlay() {
            const overlay = document.getElementById('intermissionOverlay');
            if (overlay) {
                overlay.classList.remove('active');
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 1000); // Wait for fade out transition
                console.log('Intermission overlay hidden');
            }
        }

        // Show technical difficulty overlay
        function showTechDifficultyOverlay() {
            const overlay = document.getElementById('techDifficultyOverlay');
            if (overlay) {
                overlay.classList.add('active');
                overlay.style.display = 'flex';
                console.log('Technical Difficulty overlay shown');
            }
        }

        // Hide technical difficulty overlay
        function hideTechDifficultyOverlay() {
            const overlay = document.getElementById('techDifficultyOverlay');
            if (overlay) {
                overlay.classList.remove('active');
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 1000); // Wait for fade out transition
                console.log('Technical Difficulty overlay hidden');
            }
        }

        // Show fin overlay
        function showFinOverlay() {
            const overlay = document.getElementById('finOverlay');
            if (overlay) {
                overlay.classList.add('active');
                overlay.style.display = 'flex';
                console.log('Fin overlay shown');
            }
        }

        // Hide fin overlay
        function hideFinOverlay() {
            const overlay = document.getElementById('finOverlay');
            if (overlay) {
                overlay.classList.remove('active');
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 1000); // Wait for fade out transition
                console.log('Fin overlay hidden');
            }
        }

        // Track terminal error (for tech difficulty overlay)
        function trackTerminalError() {
            state.consecutiveErrors++;
            console.log('Terminal error tracked. Consecutive errors:', state.consecutiveErrors);

            if (state.consecutiveErrors >= 3) {
                console.log('3 consecutive errors detected! Triggering tech difficulty overlay.');
                showTechDifficultyOverlay();
                // Reset error counter
                state.consecutiveErrors = 0;
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    hideTechDifficultyOverlay();
                }, 5000);
            }
        }

        // Reset error counter (when user has successful interaction)
        function resetTerminalErrors() {
            state.consecutiveErrors = 0;
        }

        // Track user activity (for intermission overlay)
        function trackUserActivity() {
            state.lastActivityTime = Date.now();

            // Clear existing inactivity timeout
            if (state.inactivityTimeout) {
                clearTimeout(state.inactivityTimeout);
            }

            // Set new 120-second inactivity timeout
            state.inactivityTimeout = setTimeout(() => {
                console.log('120 seconds of inactivity detected! Triggering intermission overlay.');
                showIntermissionOverlay();
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    hideIntermissionOverlay();
                    // Restart inactivity tracking
                    trackUserActivity();
                }, 10000);
            }, 120000); // 120 seconds = 2 minutes
        }

        // These will be initialized after config loads
        let bootSequenceEnabled = true; // Placeholder
        let systemMood = 'stable'; // Placeholder
        let secretCommands = []; // Placeholder

        function loadSystemMood() {
            const settings = getConfigSettings();
            return settings && settings.systemMood ? settings.systemMood : 'stable';
        }

        // ========================================
        // Secret Commands System
        // ========================================

        function loadSecretCommands() {
            return getConfigSecretCommands() || [];
        }

        // Function to initialize config-dependent values
        function initializeConfigDependentValues() {
            bootSequenceEnabled = loadBootSequenceEnabled();
            systemMood = loadSystemMood();
            secretCommands = loadSecretCommands();
            meltdownMessage = loadMeltdownMessage();
            meltdownAudioURL = loadMeltdownAudioURL();
        }

        // Extract meltdown triggers from thoughts with [] brackets
        function extractMeltdownTriggers(thoughts) {
            const triggers = [];
            const bracketRegex = /\[([^\]]+)\]/g;

            for (const thought of thoughts) {
                let match;
                while ((match = bracketRegex.exec(thought)) !== null) {
                    const trigger = match[1].toUpperCase().trim();
                    if (trigger && !triggers.includes(trigger)) {
                        triggers.push(trigger);
                    }
                }
            }

            return triggers;
        }

        // Strip meltdown triggers from thought text for display
        function stripMeltdownTriggers(text) {
            return text.replace(/\[([^\]]+)\]/g, '$1');
        }

        // Keystroke buffer for command detection
        let keystrokeBuffer = '';
        const maxBufferSize = 20; // Maximum characters to track
        let matrixToggleState = false; // Track matrix toggle state

        // Meltdown triggers extracted from thoughts
        let meltdownTriggers = [];
        let meltdownMessage = '';
        let meltdownAudioURL = '';

        // Secret command visual feedback
        function showCommandFeedback() {
            const explorePage = document.querySelector('.explore-page');
            if (explorePage) {
                explorePage.classList.add('secret-command-activated');
                // Remove the class after animation completes
                setTimeout(() => {
                    explorePage.classList.remove('secret-command-activated');
                }, 600);
            }
        }

        // Execute secret command action
        function executeSecretCommand(command) {
            showCommandFeedback();

            switch (command.action) {
                case 'earthquake':
                    triggerSecretEarthquake();
                    break;
                case 'matrix':
                    toggleMatrixAnimation();
                    break;
                case 'warp':
                    triggerWarpAnimation();
                    break;
                case 'transparent':
                    triggerTransparentAnimation();
                    break;
                case 'redirect':
                    if (command.url) {
                        setTimeout(() => {
                            window.location.href = command.url;
                        }, 400);
                    }
                    break;
                case 'custom':
                    // For future custom actions
                    if (command.customFunction) {
                        try {
                            eval(command.customFunction);
                        } catch (e) {
                            console.warn('Failed to execute custom command:', e);
                        }
                    }
                    break;
            }
        }

        // Execute meltdown sequence
        function executeMeltdown() {
            console.log('MELTDOWN TRIGGERED!');

            // Preserve audio state during meltdown effect
            preserveAudioState();

            // Stop all animations and input immediately
            state.isUserTyping = true;
            state.isSelected = true;
            state.isAnimating = false;
            stopCycling();

            // Clear any existing timeouts
            if (state.animationTimeout) clearTimeout(state.animationTimeout);
            if (state.cycleTimeout) clearTimeout(state.cycleTimeout);
            if (state.idleTimeout) clearTimeout(state.idleTimeout);

            // Hide cursor
            const cursorElement = document.getElementById('cursor');
            if (cursorElement) {
                cursorElement.classList.remove('visible');
            }

            // Hide choice buttons if visible
            const choiceContainer = document.querySelector('.choice-buttons-container');
            if (choiceContainer) {
                choiceContainer.style.display = 'none';
            }

            // Clear thought element and prepare for meltdown message
            const thoughtElement = document.getElementById('thought');
            thoughtElement.classList.remove('fade-out', 'fade-in');
            thoughtElement.classList.add('visible', 'meltdown-text');
            thoughtElement.textContent = '';

            // Rapidly type the meltdown message in red
            let charIndex = 0;
            const typingSpeed = 20; // Very fast typing (20ms per character)

            function typeMeltdownChar() {
                if (charIndex < meltdownMessage.length) {
                    thoughtElement.textContent += meltdownMessage[charIndex];
                    charIndex++;
                    setTimeout(typeMeltdownChar, typingSpeed);
                } else {
                    // After message is typed, trigger pixel melt
                    setTimeout(() => {
                        triggerPixelMelt();
                    }, 500);
                }
            }

            typeMeltdownChar();
        }

        // Trigger meltdown from Yes/No button clicks
        function triggerMeltdown() {
            console.log('SYSTEM MELTDOWN TRIGGERED FROM BUTTON CLICK!');

            // Preserve audio state during meltdown effect
            preserveAudioState();

            // Immediately disable Yes/No buttons to prevent double-clicks
            const yesBtn = document.getElementById('choiceBtnYes');
            const noBtn = document.getElementById('choiceBtnNo');
            if (yesBtn) {
                yesBtn.disabled = true;
                yesBtn.style.pointerEvents = 'none';
            }
            if (noBtn) {
                noBtn.disabled = true;
                noBtn.style.pointerEvents = 'none';
            }

            // Stop all animations and input immediately
            state.isUserTyping = true;
            state.isSelected = true;
            state.isAnimating = false;
            state.waitingForChoice = false;
            stopCycling();

            // Clear any existing timeouts
            if (state.animationTimeout) clearTimeout(state.animationTimeout);
            if (state.cycleTimeout) clearTimeout(state.cycleTimeout);
            if (state.idleTimeout) clearTimeout(state.idleTimeout);

            // Hide cursor
            const cursorElement = document.getElementById('exploreCursor');
            if (cursorElement) {
                cursorElement.classList.remove('visible');
            }

            // Hide choice buttons
            const choiceContainer = document.getElementById('choiceButtonsContainer');
            if (choiceContainer) {
                choiceContainer.style.display = 'none';
            }

            // Clear terminal and prepare for meltdown message
            const thoughtElement = document.getElementById('currentThought');
            if (thoughtElement) {
                thoughtElement.textContent = '';
                thoughtElement.classList.remove('fade-out', 'fade-in');
                thoughtElement.classList.add('visible', 'meltdown-text');
            }

            // Reset state text
            state.currentText = '';

            // Rapidly type the meltdown message in red
            let charIndex = 0;
            const typingSpeed = 20; // Very fast typing (20ms per character)

            function typeMeltdownChar() {
                if (charIndex < meltdownMessage.length) {
                    thoughtElement.textContent += meltdownMessage[charIndex];
                    charIndex++;
                    setTimeout(typeMeltdownChar, typingSpeed);
                } else {
                    // After message is typed, apply pixel-melt CSS class and trigger melt
                    setTimeout(() => {
                        // Apply pixel-melt class to terminal container
                        const terminalBody = document.getElementById('terminal-body');
                        const terminalContainer = document.getElementById('terminal-container');
                        const explorePage = document.querySelector('.explore-page');

                        if (terminalBody) {
                            terminalBody.classList.add('pixel-melt');
                        }
                        if (terminalContainer) {
                            terminalContainer.classList.add('pixel-melt');
                        }
                        if (explorePage) {
                            explorePage.classList.add('pixel-melt');
                        }
                        if (thoughtElement) {
                            thoughtElement.classList.add('pixel-melt');
                        }

                        // Trigger full pixel melt sequence
                        triggerPixelMelt();
                    }, 500);
                }
            }

            typeMeltdownChar();
        }

        // Trigger pixel melt animation and display overlay
        function triggerPixelMelt() {
            const explorePage = document.querySelector('.explore-page');
            const thoughtElement = document.getElementById('thought');

            // Add melt animation class
            if (explorePage) {
                explorePage.classList.add('pixel-melt');
            }
            if (thoughtElement) {
                thoughtElement.classList.add('pixel-melt');
            }

            // Wait for melt animation to complete (1 second)
            setTimeout(() => {
                // Show tech difficulty overlay
                const overlay = document.getElementById('techDifficultyOverlay');
                if (overlay) {
                    overlay.classList.add('active');
                    overlay.style.display = 'flex';
                }

                // Play meltdown audio if URL is provided
                if (meltdownAudioURL) {
                    const audio = new Audio(meltdownAudioURL);
                    audio.volume = 0.5;
                    audio.play().catch(e => console.warn('Failed to play meltdown audio:', e));
                }

                // Auto-refresh page after 10 seconds
                setTimeout(() => {
                    location.reload();
                }, 10000);
            }, 1000);
        }

        // Trigger earthquake without navigation (for secret command)
        function triggerSecretEarthquake() {
            const explorePage = document.querySelector('.explore-page');
            const terminalOverlay = document.getElementById('terminalOverlay');
            const background = document.getElementById('mainSiteBackground');
            const iframe = document.getElementById('mainSiteFrame');

            // Load main site if not already loaded
            if (iframe && !iframe.src) {
                iframe.src = 'main.html';
            }

            // Show background
            if (background) {
                background.classList.add('active');
            }

            // Apply quake time
            const actualQuakeTime = applyQuakeTimeVariable();
            const durationMs = actualQuakeTime * 1000;

            // Phase 1: Earthquake shake
            explorePage.classList.add('earthquake-shake');

            // After shake, split the terminal
            setTimeout(() => {
                terminalOverlay.classList.add('active');
                explorePage.style.visibility = 'hidden';

                setTimeout(() => {
                    terminalOverlay.classList.add('splitting');

                    // Navigate after split
                    setTimeout(() => {
                        window.location.href = 'main.html';
                    }, 800);
                }, 50);
            }, durationMs);
        }

        // Toggle matrix animation on/off
        function toggleMatrixAnimation() {
            if (state.matrixActive) {
                // Matrix is running - stop it
                const canvas = document.getElementById('matrixCanvas');
                if (canvas) {
                    canvas.classList.add('fade-out');
                    setTimeout(() => {
                        canvas.classList.remove('active', 'fade-out');
                        state.matrixActive = false;
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }, 500);
                }
            } else {
                // Start infinite matrix (not timed)
                triggerInfiniteMatrix();
            }
        }

        // Trigger matrix animation that runs until toggled off
        function triggerInfiniteMatrix() {
            if (state.matrixActive) return;

            state.matrixActive = true;
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.classList.remove('fade-out');
            canvas.classList.add('active');

            const fontSize = 14;
            const columns = Math.floor(canvas.width / fontSize);
            const drops = Array(columns).fill(1);

            function draw() {
                if (!state.matrixActive) return;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#34ff35';
                ctx.font = fontSize + 'px VT323, monospace';
                ctx.shadowColor = 'rgba(52, 255, 53, 0.5)';
                ctx.shadowBlur = 4;

                for (let i = 0; i < drops.length; i++) {
                    const char = Math.random() > 0.5 ? '1' : '0';
                    ctx.fillText(char, i * fontSize, drops[i] * fontSize);

                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }

                state.matrixAnimationId = requestAnimationFrame(draw);
            }

            draw();
        }

        // Trigger Star Wars style warp/hyperspace animation
        function triggerWarpAnimation() {
            // Preserve audio state during warp effect
            preserveAudioState();

            // Create warp container
            const warpContainer = document.createElement('div');
            warpContainer.id = 'warpContainer';
            warpContainer.className = 'warp-container';
            document.body.appendChild(warpContainer);

            // Create canvas for starfield
            const canvas = document.createElement('canvas');
            canvas.id = 'warpCanvas';
            canvas.className = 'warp-canvas';
            warpContainer.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Star properties
            const stars = [];
            const numStars = 400;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Initialize stars at random positions
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width - centerX,
                    y: Math.random() * canvas.height - centerY,
                    z: Math.random() * 1500 + 500,
                    speed: Math.random() * 2 + 1
                });
            }

            let animationId;
            let startTime = Date.now();
            const warpDuration = 3000; // 3 seconds of warping

            function drawStars() {
                const elapsed = Date.now() - startTime;

                // Clear with fade trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Calculate warp intensity (accelerates over time)
                const progress = Math.min(elapsed / warpDuration, 1);
                const warpSpeed = 20 + (progress * 80); // Accelerate from 20 to 100

                for (let i = 0; i < stars.length; i++) {
                    const star = stars[i];

                    // Move star toward viewer
                    star.z -= warpSpeed * star.speed;

                    // Reset star if it passes the viewer
                    if (star.z <= 0) {
                        star.x = Math.random() * canvas.width - centerX;
                        star.y = Math.random() * canvas.height - centerY;
                        star.z = 1500;
                        star.speed = Math.random() * 2 + 1;
                    }

                    // Project 3D position to 2D
                    const scale = 500 / star.z;
                    const x2d = star.x * scale + centerX;
                    const y2d = star.y * scale + centerY;

                    // Calculate previous position for streak
                    const prevZ = star.z + warpSpeed * star.speed;
                    const prevScale = 500 / prevZ;
                    const prevX = star.x * prevScale + centerX;
                    const prevY = star.y * prevScale + centerY;

                    // Draw star streak (line from previous to current position)
                    const streakLength = Math.min(1, progress * 2); // Streaks grow with warp
                    const brightness = Math.min(255, 100 + (1500 - star.z) / 5);

                    ctx.beginPath();
                    ctx.moveTo(prevX, prevY);
                    ctx.lineTo(x2d, y2d);
                    ctx.strokeStyle = `rgba(${brightness}, ${brightness}, ${Math.min(255, brightness + 50)}, ${0.5 + streakLength * 0.5})`;
                    ctx.lineWidth = 1 + scale * 2 * streakLength;
                    ctx.stroke();

                    // Draw bright point at end of streak
                    ctx.beginPath();
                    ctx.arc(x2d, y2d, Math.max(0.5, scale * 1.5), 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 + streakLength * 0.2})`;
                    ctx.fill();
                }

                // Continue animation or transition to galaxy
                if (elapsed < warpDuration) {
                    animationId = requestAnimationFrame(drawStars);
                } else {
                    // Warp complete - show galaxy reveal
                    cancelAnimationFrame(animationId);
                    showGalaxyReveal(warpContainer);
                }
            }

            // Start warp animation
            warpContainer.classList.add('active');
            drawStars();
        }

        // Show galaxy image after warp
        function showGalaxyReveal(warpContainer) {
            // Create galaxy container
            const galaxyDiv = document.createElement('div');
            galaxyDiv.className = 'galaxy-reveal';

            // Placeholder galaxy image (colorful nebula/galaxy)
            galaxyDiv.innerHTML = `
                <div class="galaxy-content">
                    <div class="galaxy-placeholder">
                        <div class="galaxy-stars"></div>
                        <div class="galaxy-nebula"></div>
                        <div class="galaxy-center"></div>
                    </div>
                    <p class="galaxy-text">Destination: Unknown Galaxy</p>
                </div>
            `;

            warpContainer.appendChild(galaxyDiv);

            // Fade out canvas, fade in galaxy
            const canvas = warpContainer.querySelector('.warp-canvas');
            canvas.classList.add('fade-out');

            setTimeout(() => {
                galaxyDiv.classList.add('visible');
            }, 100);

            // Auto-close after viewing
            setTimeout(() => {
                warpContainer.classList.add('closing');
                setTimeout(() => {
                    warpContainer.remove();
                }, 1000);
            }, 4000);
        }

        function loadBuildersMedia() {
            return getConfigBuildersMedia() || { type: 'image', url: '' };
        }

        // Trigger Transparent animation - reveals builders behind the terminal
        function triggerTransparentAnimation() {
            const buildersMedia = loadBuildersMedia();

            // Create builders background container
            const buildersContainer = document.createElement('div');
            buildersContainer.id = 'buildersContainer';
            buildersContainer.className = 'builders-container';

            // Add media content (image or video)
            if (buildersMedia.url) {
                if (buildersMedia.type === 'video') {
                    buildersContainer.innerHTML = `
                        <video class="builders-media" autoplay loop muted playsinline>
                            <source src="${buildersMedia.url}" type="video/mp4">
                        </video>
                    `;
                } else {
                    buildersContainer.innerHTML = `
                        <img class="builders-media" src="${buildersMedia.url}" alt="Construction Crew">
                    `;
                }
            } else {
                // Placeholder if no URL set - CSS animated construction scene
                buildersContainer.innerHTML = `
                    <div class="builders-placeholder">
                        <div class="builder builder-1">
                            <div class="builder-body"></div>
                            <div class="hammer"></div>
                        </div>
                        <div class="builder builder-2">
                            <div class="builder-body"></div>
                            <div class="hammer"></div>
                        </div>
                        <div class="scaffold"></div>
                        <div class="scaffold scaffold-2"></div>
                        <p class="builders-text">UNDER CONSTRUCTION</p>
                    </div>
                `;
            }

            // Insert builders behind the terminal
            document.body.insertBefore(buildersContainer, document.body.firstChild);

            // Get terminal elements
            const explorePage = document.querySelector('.explore-page');
            const bootOverlay = document.getElementById('bootSequenceOverlay');

            // Add close button overlay
            const closeBtn = document.createElement('button');
            closeBtn.className = 'transparent-close-btn';
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = () => closeTransparentEffect(buildersContainer, explorePage, closeBtn);
            document.body.appendChild(closeBtn);

            // Trigger fade animation
            requestAnimationFrame(() => {
                buildersContainer.classList.add('active');
                explorePage.classList.add('transparent-fade');
                if (bootOverlay) {
                    bootOverlay.style.display = 'none';
                }
                closeBtn.classList.add('visible');
            });
        }

        // Close transparent effect
        function closeTransparentEffect(buildersContainer, explorePage, closeBtn) {
            explorePage.classList.remove('transparent-fade');
            closeBtn.classList.remove('visible');

            setTimeout(() => {
                buildersContainer.remove();
                closeBtn.remove();
            }, 1000);
        }

        // Check keystroke buffer for matching commands
        function checkSecretCommands() {
            const buffer = keystrokeBuffer.toUpperCase();

            for (const command of secretCommands) {
                if (!command.enabled) continue;

                const keyword = command.keyword.toUpperCase();
                if (buffer.endsWith(keyword)) {
                    // Command matched! Clear buffer and execute
                    keystrokeBuffer = '';
                    executeSecretCommand(command);
                    return true;
                }
            }
            return false;
        }

        // Check keystroke buffer for meltdown triggers
        function checkMeltdownTriggers() {
            const buffer = keystrokeBuffer.toUpperCase();

            for (const trigger of meltdownTriggers) {
                if (buffer.endsWith(trigger)) {
                    // Meltdown trigger matched! Clear buffer and execute
                    keystrokeBuffer = '';
                    executeMeltdown();
                    return true;
                }
            }
            return false;
        }

        // Global keydown listener for secret commands
        document.addEventListener('keydown', (event) => {
            // Track user activity for inactivity detection
            trackUserActivity();

            // Only track printable characters
            if (event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {
                keystrokeBuffer += event.key;

                // Trim buffer if too long
                if (keystrokeBuffer.length > maxBufferSize) {
                    keystrokeBuffer = keystrokeBuffer.slice(-maxBufferSize);
                }

                // Check for command matches
                const commandMatched = checkSecretCommands();
                if (commandMatched) {
                    // Reset error counter on successful command
                    resetTerminalErrors();
                    return;
                }

                // Check for meltdown triggers (only if no secret command matched)
                const meltdownMatched = checkMeltdownTriggers();
                if (meltdownMatched) {
                    return;
                }
            }
        });

        // Fisher-Yates shuffle algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // These will be initialized after config loads
        let allThoughts = [];
        let allResponses = [];
        let heroText = '';
        let actions = [];
        let activeStates = [];
        let randomizeEnabled = false;
        let activeIndices = [];
        let thoughts = [];
        let responses = [];
        let allYesRedirectIndices = [];
        let allNoRedirectIndices = [];
        let allChoiceATexts = [];
        let allChoiceBTexts = [];
        let allChoiceAActions = [];
        let allChoiceBActions = [];
        let allTypingSpeeds = [];
        let allMoods = [];
        let allSceneAudioOverrides = [];
        let yesRedirectIndices = [];
        let noRedirectIndices = [];
        let choiceATexts = [];
        let choiceBTexts = [];
        let choiceAActions = [];
        let choiceBActions = [];
        let typingSpeeds = [];
        let moods = [];
        let sceneAudioOverrides = [];
        let globalAmbientAudioURL = '';

        // Function to load and process thoughts/responses data
        function initializeContentData() {
            allThoughts = loadThoughts();
            allResponses = loadResponses();
            heroText = loadHeroText();
            actions = loadActions();
            activeStates = loadActiveStates();
            allYesRedirectIndices = loadYesRedirectIndices();
            allNoRedirectIndices = loadNoRedirectIndices();
            allChoiceATexts = loadChoiceATexts() || [];
            allChoiceBTexts = loadChoiceBTexts() || [];
            allChoiceAActions = loadChoiceAActions() || [];
            allChoiceBActions = loadChoiceBActions() || [];
            allTypingSpeeds = loadTypingSpeeds() || [];
            allMoods = loadMoods() || [];
            allSceneAudioOverrides = loadSceneAudioOverrides() || [];
            globalAmbientAudioURL = loadGlobalAmbientAudioURL() || '';
            randomizeEnabled = loadRandomizeEnabled();

            // Comprehensive null checks - ensure ALL data exists before processing
            if (!allThoughts || !allResponses || !heroText || !activeStates || !allYesRedirectIndices || !allNoRedirectIndices) {
                console.warn('Config not loaded from Firebase, showing initialization state');
                allThoughts = ['System Initializing...'];
                allResponses = ['No configuration data found. Please contact the administrator.'];
                heroText = 'SYSTEM INITIALIZING...';
                actions = [{ type: 'none', url: '', logo: '', linkText: 'Click here' }];
                activeStates = [true];
                allYesRedirectIndices = [''];
                allNoRedirectIndices = [''];
                allChoiceATexts = [''];
                allChoiceBTexts = [''];
                allChoiceAActions = [{ type: 'none', endAction: false }];
                allChoiceBActions = [{ type: 'none', endAction: false }];
                allTypingSpeeds = [100];
                allMoods = ['stable'];
                allSceneAudioOverrides = [{ url: '', loop: true }];
                randomizeEnabled = false;
            }

            // Additional safety check: ensure arrays have valid length
            if (!Array.isArray(allThoughts) || allThoughts.length === 0) {
                console.error('Invalid thoughts data, using fallback');
                allThoughts = ['System Offline'];
                allResponses = ['Unable to load content. Please try again later.'];
                heroText = 'SYSTEM OFFLINE';
                actions = [{ type: 'none', url: '', logo: '', linkText: 'Click here' }];
                activeStates = [true];
                allYesRedirectIndices = [''];
                allNoRedirectIndices = [''];
                allChoiceATexts = [''];
                allChoiceBTexts = [''];
                allChoiceAActions = [{ type: 'none', endAction: false }];
                allChoiceBActions = [{ type: 'none', endAction: false }];
                allTypingSpeeds = [100];
                allMoods = ['stable'];
                allSceneAudioOverrides = [{ url: '', loop: true }];
                randomizeEnabled = false;
            }

            // Reset arrays
            activeIndices = [];
            thoughts = [];
            responses = [];
            yesRedirectIndices = [];
            noRedirectIndices = [];
            choiceATexts = [];
            choiceBTexts = [];
            choiceAActions = [];
            choiceBActions = [];
            typingSpeeds = [];
            moods = [];
            sceneAudioOverrides = [];

            // Filter to only include active thoughts and track their original indices
            for (let i = 0; i < allThoughts.length; i++) {
                // Default to active if no state is set
                if (activeStates[i] !== false) {
                    activeIndices.push(i);
                    thoughts.push(allThoughts[i]);
                    responses.push(allResponses[i]);
                    yesRedirectIndices.push(allYesRedirectIndices[i] || '');
                    noRedirectIndices.push(allNoRedirectIndices[i] || '');
                    choiceATexts.push(allChoiceATexts[i] || '');
                    choiceBTexts.push(allChoiceBTexts[i] || '');
                    choiceAActions.push(allChoiceAActions[i] || { type: 'none', endAction: false });
                    choiceBActions.push(allChoiceBActions[i] || { type: 'none', endAction: false });
                    typingSpeeds.push(allTypingSpeeds[i] !== undefined ? allTypingSpeeds[i] : 100);
                    moods.push(allMoods[i] || 'stable');
                    sceneAudioOverrides.push(allSceneAudioOverrides[i] || { url: '', loop: true });
                }
            }

            // Apply randomization if enabled
            if (randomizeEnabled && activeIndices.length > 0) {
                // Create array of indices into the active arrays
                const indices = activeIndices.map((_, idx) => idx);

                // Shuffle the indices
                const shuffledIndices = shuffleArray(indices);

                // Take up to 3 (or fewer if not enough active questions)
                const selectedCount = Math.min(3, shuffledIndices.length);
                const selectedIndices = shuffledIndices.slice(0, selectedCount);

                // Rebuild arrays with only the selected items
                const newActiveIndices = [];
                const newThoughts = [];
                const newResponses = [];
                const newYesRedirectIndices = [];
                const newNoRedirectIndices = [];
                const newChoiceATexts = [];
                const newChoiceBTexts = [];
                const newChoiceAActions = [];
                const newChoiceBActions = [];
                const newTypingSpeeds = [];
                const newMoods = [];
                const newSceneAudioOverrides = [];

                for (const idx of selectedIndices) {
                    newActiveIndices.push(activeIndices[idx]);
                    newThoughts.push(thoughts[idx]);
                    newResponses.push(responses[idx]);
                    newYesRedirectIndices.push(yesRedirectIndices[idx]);
                    newNoRedirectIndices.push(noRedirectIndices[idx]);
                    newChoiceATexts.push(choiceATexts[idx]);
                    newChoiceBTexts.push(choiceBTexts[idx]);
                    newChoiceAActions.push(choiceAActions[idx]);
                    newChoiceBActions.push(choiceBActions[idx]);
                    newTypingSpeeds.push(typingSpeeds[idx]);
                    newMoods.push(moods[idx]);
                    newSceneAudioOverrides.push(sceneAudioOverrides[idx]);
                }

                activeIndices = newActiveIndices;
                thoughts = newThoughts;
                responses = newResponses;
                yesRedirectIndices = newYesRedirectIndices;
                noRedirectIndices = newNoRedirectIndices;
                choiceATexts = newChoiceATexts;
                choiceBTexts = newChoiceBTexts;
                choiceAActions = newChoiceAActions;
                choiceBActions = newChoiceBActions;
                typingSpeeds = newTypingSpeeds;
                moods = newMoods;
                sceneAudioOverrides = newSceneAudioOverrides;
            }

            // Extract meltdown triggers from all thoughts (including inactive ones)
            meltdownTriggers = extractMeltdownTriggers(allThoughts);
            console.log('Meltdown triggers extracted:', meltdownTriggers);
        }

        function loadMatrixFadeDuration() {
            const settings = getConfigSettings();
            return settings && settings.matrixFadeDuration ? settings.matrixFadeDuration : 1.5;
        }

        let matrixFadeDuration = 1.5; // Placeholder

        function loadEarthquakeDuration() {
            const settings = getConfigSettings();
            return settings && settings.earthquakeDuration ? settings.earthquakeDuration : 1.5;
        }

        let earthquakeDuration = 1.5; // Placeholder

        function loadCurtainDuration() {
            const settings = getConfigSettings();
            return settings && settings.curtainDuration ? settings.curtainDuration : 4;
        }

        let curtainDuration = 4; // Placeholder

        function loadChoiceButtonsEnabled() {
            const settings = getConfigSettings();
            return settings && settings.choiceButtonsEnabled !== undefined ? settings.choiceButtonsEnabled : false;
        }

        let choiceButtonsEnabled = false; // Placeholder

        // Function to initialize settings after config loads
        function initializeSettings() {
            matrixFadeDuration = loadMatrixFadeDuration();
            earthquakeDuration = loadEarthquakeDuration();
            curtainDuration = loadCurtainDuration();
            choiceButtonsEnabled = loadChoiceButtonsEnabled();
        }

        let state = {
            currentIndex: 0,
            isUserTyping: false,
            isSelected: false,
            selectedIndex: null,
            cycleTimeout: null,
            animationTimeout: null,
            idleTimeout: null,        // Timeout for auto-cycling when no choice is made
            isAnimating: false,
            currentText: '',
            targetText: '',
            matrixActive: false,
            matrixAnimationId: null,
            waitingForChoice: false,  // Whether we're waiting for Yes/No button click
            heroTyped: false,         // Whether the hero text has been typed
            currentAudio: null,       // Pre-loaded audio object for manual playback
            capturingName: false,     // Whether we're capturing user's name
            userName: '',             // Global variable to store captured user name
            consecutiveErrors: 0,     // Track consecutive terminal errors for tech difficulty overlay
            inactivityTimeout: null,  // Timeout for 120s inactivity detection
            lastActivityTime: Date.now(), // Track last user activity
            terminalLocked: false     // Lock terminal during action animations
        };

        // ========================================
        // Terminal Lock Functions (for action animations)
        // ========================================

        function lockTerminal() {
            state.terminalLocked = true;
            // Disable choice buttons visually
            const choiceBtnYes = document.getElementById('choiceBtnYes');
            const choiceBtnNo = document.getElementById('choiceBtnNo');
            if (choiceBtnYes) choiceBtnYes.classList.add('disabled');
            if (choiceBtnNo) choiceBtnNo.classList.add('disabled');
        }

        function unlockTerminal() {
            state.terminalLocked = false;
            // Re-enable choice buttons
            const choiceBtnYes = document.getElementById('choiceBtnYes');
            const choiceBtnNo = document.getElementById('choiceBtnNo');
            if (choiceBtnYes) choiceBtnYes.classList.remove('disabled');
            if (choiceBtnNo) choiceBtnNo.classList.remove('disabled');
        }

        // Get the delay for each action type (in ms)
        function getActionDelay(actionType) {
            switch (actionType) {
                case 'supernova-flash':
                case 'spaghettify':
                    return 2500;
                case 'hull-breach':
                    return 1500;
                case 'recursive-reality':
                    return 3500;
                case 'quantum-leak':
                    return 3000;
                case 'hypnotic-spiral':
                    return 5500;
                default:
                    return 0;
            }
        }

        // Trigger action animation without FIN overlay (for non-end-action transitions)
        // Calls the callback after the animation delay
        function triggerTransitionAnimation(actionType, callback) {
            const delay = getActionDelay(actionType);
            if (delay === 0) {
                // No animation needed, execute callback immediately
                if (callback) callback();
                return;
            }

            // Lock the terminal during animation
            lockTerminal();

            switch (actionType) {
                case 'supernova-flash':
                    triggerSupernovaTransition(callback, delay);
                    break;
                case 'spaghettify':
                    triggerSpaghettifyTransition(callback, delay);
                    break;
                case 'hull-breach':
                    triggerHullBreachTransition(callback, delay);
                    break;
                case 'recursive-reality':
                    triggerRecursiveRealityTransition(callback, delay);
                    break;
                case 'quantum-leak':
                    triggerQuantumLeakTransition(callback, delay);
                    break;
                case 'hypnotic-spiral':
                    triggerHypnoticSpiralTransition(callback, delay);
                    break;
                default:
                    unlockTerminal();
                    if (callback) callback();
            }
        }

        // Supernova transition animation (without FIN)
        function triggerSupernovaTransition(callback, delay) {
            console.log('SUPERNOVA TRANSITION TRIGGERED');

            // Create overlay element
            const overlay = document.createElement('div');
            overlay.id = 'supernovaTransitionOverlay';
            overlay.className = 'supernova-overlay';
            document.body.appendChild(overlay);

            // Phase 1: Blinding white flash
            overlay.classList.add('active', 'white-flash');

            // Phase 2: Transition to celestial purple (after 1s)
            setTimeout(() => {
                overlay.classList.remove('white-flash');
                overlay.classList.add('celestial-purple');
            }, 1000);

            // After delay, fade out and execute callback
            setTimeout(() => {
                overlay.classList.add('fade-out');
                unlockTerminal();
                if (callback) callback();
                setTimeout(() => {
                    overlay.remove();
                }, 500);
            }, delay);
        }

        // Spaghettify transition animation (without FIN)
        function triggerSpaghettifyTransition(callback, delay) {
            console.log('SPAGHETTIFY TRANSITION TRIGGERED');

            const explorePage = document.querySelector('.explore-page');
            const terminalBody = document.getElementById('terminal-body');
            const thoughtElement = document.getElementById('currentThought');

            // Create black hole overlay
            const overlay = document.createElement('div');
            overlay.id = 'blackHoleTransitionOverlay';
            overlay.className = 'black-hole-overlay';

            // Create the event horizon (center point)
            const eventHorizon = document.createElement('div');
            eventHorizon.className = 'event-horizon';
            overlay.appendChild(eventHorizon);

            document.body.appendChild(overlay);
            overlay.classList.add('active');

            // Apply spaghettify effect to text elements
            if (explorePage) explorePage.classList.add('spaghettify');
            if (terminalBody) terminalBody.classList.add('spaghettify');
            if (thoughtElement) thoughtElement.classList.add('spaghettify');

            // After delay, fade out and execute callback
            setTimeout(() => {
                overlay.classList.add('fade-out');
                if (explorePage) explorePage.classList.remove('spaghettify');
                if (terminalBody) terminalBody.classList.remove('spaghettify');
                if (thoughtElement) thoughtElement.classList.remove('spaghettify');
                unlockTerminal();
                if (callback) callback();
                setTimeout(() => {
                    overlay.remove();
                }, 500);
            }, delay);
        }

        // Hull Breach transition animation (without FIN)
        function triggerHullBreachTransition(callback, delay) {
            console.log('HULL BREACH TRANSITION TRIGGERED');

            // Play depressurization sound if not muted
            if (!globalAudioMuted) {
                const depressSound = new Audio('assets/audio/hull-breach.mp3');
                depressSound.volume = 0.7;
                depressSound.play().catch(e => console.log('Hull breach audio failed:', e));
            }

            // Create hull breach overlay
            const overlay = document.createElement('div');
            overlay.id = 'hullBreachTransitionOverlay';
            overlay.className = 'hull-breach-overlay';
            document.body.appendChild(overlay);
            overlay.classList.add('active');

            // Apply hull breach wipe effect to terminal
            const explorePage = document.querySelector('.explore-page');
            const thoughtElement = document.getElementById('currentThought');

            if (explorePage) explorePage.classList.add('hull-breach-wipe');
            if (thoughtElement) thoughtElement.classList.add('hull-breach-wipe');

            // Rapid text wipe animation
            if (thoughtElement) {
                const currentText = thoughtElement.textContent;
                let charIndex = currentText.length;
                const wipeInterval = setInterval(() => {
                    if (charIndex > 0) {
                        charIndex -= 3; // Remove 3 chars at a time for rapid wipe
                        thoughtElement.textContent = currentText.substring(0, Math.max(0, charIndex));
                    } else {
                        clearInterval(wipeInterval);
                    }
                }, 30);
            }

            // After delay, fade out and execute callback
            setTimeout(() => {
                overlay.classList.add('fade-out');
                if (explorePage) explorePage.classList.remove('hull-breach-wipe');
                if (thoughtElement) thoughtElement.classList.remove('hull-breach-wipe');
                unlockTerminal();
                if (callback) callback();
                setTimeout(() => {
                    overlay.remove();
                }, 500);
            }, delay);
        }

        // ========================================
        // Layered Audio System
        // ========================================
        const audioState = {
            globalAmbient: null,           // Audio element for global ambient loop
            sceneAudio: null,              // Audio element for scene-specific audio
            currentSceneAudioURL: null,    // Currently playing scene audio URL
            userHasInteracted: false,      // Whether user has clicked to enable audio
            crossFadeDuration: 2000,       // Cross-fade duration in ms
            fadeInterval: null,            // Interval for fade animation
            targetVolume: 0.5              // Default volume level
        };

        // Global audio mute flag - set by Entry Page audio preference
        let globalAudioMuted = false;

        // Initialize global ambient audio (call after config loads)
        function initializeGlobalAmbientAudio() {
            if (!globalAmbientAudioURL) {
                console.log('No global ambient audio URL configured');
                return;
            }

            audioState.globalAmbient = new Audio(globalAmbientAudioURL);
            audioState.globalAmbient.loop = true;
            audioState.globalAmbient.volume = 0;
            audioState.globalAmbient.preload = 'auto';
            console.log('Global ambient audio initialized:', globalAmbientAudioURL);
        }

        // Start global ambient audio on first user interaction
        function startAmbientAudioOnFirstClick() {
            if (audioState.userHasInteracted) return;
            audioState.userHasInteracted = true;

            // Check if audio is globally muted by user preference
            if (globalAudioMuted) {
                console.log('Global audio muted by user preference - skipping ambient audio');
                document.removeEventListener('click', startAmbientAudioOnFirstClick);
                document.removeEventListener('keydown', startAmbientAudioOnFirstClick);
                return;
            }

            if (audioState.globalAmbient) {
                audioState.globalAmbient.play()
                    .then(() => {
                        console.log('Global ambient audio started');
                        fadeAudioIn(audioState.globalAmbient, audioState.targetVolume, audioState.crossFadeDuration);
                    })
                    .catch(err => console.warn('Failed to start ambient audio:', err));
            }

            // Remove the listener after first interaction
            document.removeEventListener('click', startAmbientAudioOnFirstClick);
            document.removeEventListener('keydown', startAmbientAudioOnFirstClick);
        }

        // Fade audio volume in
        function fadeAudioIn(audio, targetVolume, duration) {
            if (!audio) return;
            const steps = 20;
            const stepDuration = duration / steps;
            const volumeStep = targetVolume / steps;
            let currentStep = 0;

            const interval = setInterval(() => {
                currentStep++;
                audio.volume = Math.min(targetVolume, volumeStep * currentStep);
                if (currentStep >= steps) {
                    clearInterval(interval);
                    audio.volume = targetVolume;
                }
            }, stepDuration);
        }

        // Fade audio volume out
        function fadeAudioOut(audio, duration, callback) {
            if (!audio) {
                if (callback) callback();
                return;
            }
            const steps = 20;
            const stepDuration = duration / steps;
            const volumeStep = audio.volume / steps;
            const startVolume = audio.volume;
            let currentStep = 0;

            const interval = setInterval(() => {
                currentStep++;
                audio.volume = Math.max(0, startVolume - (volumeStep * currentStep));
                if (currentStep >= steps) {
                    clearInterval(interval);
                    audio.volume = 0;
                    audio.pause();
                    if (callback) callback();
                }
            }, stepDuration);
        }

        // Handle scene audio transition with cross-fade
        function handleSceneAudioTransition(sceneIndex) {
            const sceneOverride = sceneAudioOverrides[sceneIndex];
            const newAudioURL = sceneOverride?.url || '';
            const shouldLoop = sceneOverride?.loop !== false;

            // If audio is globally muted, skip audio transitions
            if (globalAudioMuted) return;

            // If no user interaction yet, skip audio transitions
            if (!audioState.userHasInteracted) return;

            // Case 1: Scene has override audio
            if (newAudioURL && newAudioURL !== audioState.currentSceneAudioURL) {
                console.log('Transitioning to scene audio:', newAudioURL);

                // Fade out current audio (either scene or global)
                const audioToFadeOut = audioState.sceneAudio || audioState.globalAmbient;

                // Create new scene audio
                const newSceneAudio = new Audio(newAudioURL);
                newSceneAudio.loop = shouldLoop;
                newSceneAudio.volume = 0;
                newSceneAudio.preload = 'auto';

                // Cross-fade
                fadeAudioOut(audioToFadeOut, audioState.crossFadeDuration, () => {
                    // Stop global ambient during scene override (but don't destroy it)
                    if (audioState.globalAmbient) {
                        audioState.globalAmbient.pause();
                    }
                });

                newSceneAudio.play()
                    .then(() => {
                        fadeAudioIn(newSceneAudio, audioState.targetVolume, audioState.crossFadeDuration);
                        // Clean up old scene audio if exists
                        if (audioState.sceneAudio && audioState.sceneAudio !== audioState.globalAmbient) {
                            audioState.sceneAudio.pause();
                            audioState.sceneAudio = null;
                        }
                        audioState.sceneAudio = newSceneAudio;
                        audioState.currentSceneAudioURL = newAudioURL;
                    })
                    .catch(err => console.warn('Failed to play scene audio:', err));
            }
            // Case 2: No scene override, return to global ambient
            else if (!newAudioURL && audioState.currentSceneAudioURL) {
                console.log('Returning to global ambient audio');

                // Fade out scene audio
                fadeAudioOut(audioState.sceneAudio, audioState.crossFadeDuration, () => {
                    audioState.sceneAudio = null;
                    audioState.currentSceneAudioURL = null;

                    // Fade in global ambient
                    if (audioState.globalAmbient) {
                        audioState.globalAmbient.play()
                            .then(() => {
                                fadeAudioIn(audioState.globalAmbient, audioState.targetVolume, audioState.crossFadeDuration);
                            })
                            .catch(err => console.warn('Failed to resume ambient audio:', err));
                    }
                });
            }
            // Case 3: Same scene audio or no audio at all - do nothing
        }

        // Preserve audio state during effects (call before meltdown/warp)
        function preserveAudioState() {
            // Audio continues playing - no action needed
            // This function exists as a hook for future enhancements
            console.log('Audio state preserved during effect');
        }

        // Restore audio state after effects (if needed)
        function restoreAudioState() {
            // Audio should have continued playing
            // This function exists as a hook for future enhancements
            console.log('Audio state restored after effect');
        }

        function loadTypingSpeed() {
            const settings = getConfigSettings();
            return settings && settings.typingSpeed ? settings.typingSpeed : 150;
        }

        let baseTypingSpeed = loadTypingSpeed();

        // Check if instant mode is enabled (speed <= 10ms)
        function isInstantMode() {
            return baseTypingSpeed <= 10;
        }

        // Timing configuration (in ms) - uses admin-configurable base speed
        // Adjusted based on system mood
        // When baseTypingSpeed < 30ms, minimizes variance for data-stream effect
        function getTimingConfig() {
            const isFastMode = baseTypingSpeed < 30;

            // In fast mode (< 30ms), minimize variance for smooth data-stream effect
            const base = {
                initialDelay: isFastMode ? 500 : 3000,
                typeSpeedMin: isFastMode ? baseTypingSpeed : Math.max(10, baseTypingSpeed - 50),
                typeSpeedMax: isFastMode ? baseTypingSpeed + 5 : baseTypingSpeed + 100,
                punctuationPause: isFastMode ? baseTypingSpeed * 2 : 500,
                backspaceSpeedMin: isFastMode ? baseTypingSpeed : 50,
                backspaceSpeedMax: isFastMode ? baseTypingSpeed + 5 : 100,
                linger: 4000
            };

            switch (systemMood) {
                case 'glitchy':
                    // Glitchy: More irregular, stuttered rhythm with wider variance
                    // In fast mode, reduce the glitchy variance significantly
                    return {
                        ...base,
                        typeSpeedMin: isFastMode ? baseTypingSpeed : Math.max(10, baseTypingSpeed - 100),
                        typeSpeedMax: isFastMode ? baseTypingSpeed + 10 : baseTypingSpeed + 200,
                        punctuationPause: isFastMode ? baseTypingSpeed * 3 : (Math.random() > 0.5 ? 800 : 200),
                        backspaceSpeedMin: isFastMode ? baseTypingSpeed : 30,
                        backspaceSpeedMax: isFastMode ? baseTypingSpeed + 10 : 150,
                        linger: 3000
                    };
                case 'urgent':
                    // Urgent: Much faster typing
                    return {
                        ...base,
                        initialDelay: isFastMode ? 300 : 1500,
                        typeSpeedMin: isFastMode ? baseTypingSpeed : Math.max(10, Math.floor(baseTypingSpeed * 0.3)),
                        typeSpeedMax: isFastMode ? baseTypingSpeed + 3 : Math.floor(baseTypingSpeed * 0.5),
                        punctuationPause: isFastMode ? baseTypingSpeed : 150,
                        backspaceSpeedMin: isFastMode ? baseTypingSpeed : 20,
                        backspaceSpeedMax: isFastMode ? baseTypingSpeed + 3 : 50,
                        linger: 2000
                    };
                default: // 'stable'
                    return base;
            }
        }

        let timing = getTimingConfig();

        // Function to update typing speed settings in real-time
        function updateTypingSpeed(newSpeed) {
            baseTypingSpeed = newSpeed;
            timing = getTimingConfig();
            console.log('Typing speed updated to:', newSpeed, 'ms, instant mode:', isInstantMode());
        }

        // Apply scene-specific atmosphere (per-page typing speed and mood)
        function applySceneAtmosphere(index) {
            // Get per-page typing speed (clamp to 10-200ms range)
            const pageSpeed = typingSpeeds[index] !== undefined ? typingSpeeds[index] : 100;
            baseTypingSpeed = Math.max(10, Math.min(200, pageSpeed));

            // Get per-page mood
            const pageMood = moods[index] || 'stable';
            systemMood = pageMood;

            // Recalculate timing based on new speed and mood
            timing = getTimingConfig();

            // Apply mood-specific CSS class to explore page
            const explorePage = document.querySelector('.explore-page');
            if (explorePage) {
                // Remove all mood classes first
                explorePage.classList.remove('mood-stable', 'mood-glitchy', 'mood-urgent');
                // Apply the new mood class (don't add for stable - it's the default)
                if (pageMood !== 'stable') {
                    explorePage.classList.add(`mood-${pageMood}`);
                }
            }

            // Handle scene audio transition (cross-fade)
            handleSceneAudioTransition(index);

            console.log('Scene atmosphere applied - Speed:', baseTypingSpeed, 'ms, Mood:', pageMood);
        }

        // Helper function for random delay between min and max
        function randomDelay(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Check if character is punctuation
        function isPunctuation(char) {
            return ['.', ',', '!', '?', ';', ':'].includes(char);
        }

        // Check for reduced motion preference
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        // ========================================
        // DOM Elements
        // ========================================
        const thoughtElement = document.getElementById('currentThought');
        const inputElement = document.getElementById('exploreInput');
        const panelsContainer = document.getElementById('explorePanels');
        const cursorElement = document.getElementById('exploreCursor');
        const choiceButtonsContainer = document.getElementById('choiceButtonsContainer');
        const choiceBtnYes = document.getElementById('choiceBtnYes');
        const choiceBtnNo = document.getElementById('choiceBtnNo');
        const heroElement = document.getElementById('exploreQuestion');

        // ========================================
        // Typing Animation
        // ========================================

        // Glitchy mode typing helper - occasionally repeats or stutters
        // In fast mode (< 30ms), minimize stutter for data-stream effect
        function getGlitchyDelay(baseMin, baseMax) {
            const isFastMode = baseTypingSpeed < 30;

            // In fast mode, reduce glitch chance to 3% and minimize stutter variance
            const glitchChance = isFastMode ? 0.03 : 0.15;

            if (Math.random() < glitchChance) {
                const glitchType = Math.random();
                if (glitchType < 0.3) {
                    // Very fast burst - in fast mode, keep it minimal
                    return isFastMode ? randomDelay(baseMin, baseMax) : randomDelay(10, 30);
                } else if (glitchType < 0.6) {
                    // Long stutter pause - in fast mode, just a tiny pause
                    return isFastMode ? randomDelay(baseMin, baseMin + 10) : randomDelay(300, 600);
                } else {
                    // Normal with jitter - in fast mode, minimal jitter
                    const jitter = isFastMode ? (Math.random() > 0.5 ? 2 : -1) : (Math.random() > 0.5 ? 100 : -30);
                    return randomDelay(baseMin, baseMax) + jitter;
                }
            }
            return randomDelay(baseMin, baseMax);
        }

        // Helper function to parse text with {backspace} syntax
        // Returns array of segments: { type: 'regular'|'backspace', text: string }
        function parseBackspaceSegments(text) {
            const segments = [];
            let currentPos = 0;
            const regex = /\{([^}]+)\}/g;
            let match;

            while ((match = regex.exec(text)) !== null) {
                // Add regular text before the match
                if (match.index > currentPos) {
                    segments.push({
                        type: 'regular',
                        text: text.substring(currentPos, match.index)
                    });
                }

                // Add backspace segment
                segments.push({
                    type: 'backspace',
                    text: match[1]
                });

                currentPos = regex.lastIndex;
            }

            // Add remaining text
            if (currentPos < text.length) {
                segments.push({
                    type: 'regular',
                    text: text.substring(currentPos)
                });
            }

            return segments;
        }

        // Helper function to replace <<name>> placeholder with user's name
        // This runs FIRST before {backspace} and [meltdown] processing
        function replaceName(text) {
            if (!text.includes('<<name>>')) return text;

            // Check localStorage first (persistent), then sessionStorage, then default
            const userName = localStorage.getItem('userName') ||
                           sessionStorage.getItem('imaginecraft_user_name') ||
                           'Friend';

            return text.replace(/<<name>>/g, userName);
        }

        // Helper function to strip backspace syntax from text for direct display
        // Removes {text} portions to show the final intended text
        function stripBackspaceSyntax(text) {
            // Replace {text} with empty string to show only the final text
            return text.replace(/\{[^}]+\}/g, '');
        }

        // Helper function to process segments and type them with backspace effects
        function typeWithBackspaceEffect(segments, segmentIndex, charIndex, callback) {
            if (state.isUserTyping || state.isSelected) return;

            // If we've processed all segments, call the callback
            if (segmentIndex >= segments.length) {
                if (callback) callback();
                return;
            }

            const segment = segments[segmentIndex];

            if (segment.type === 'regular') {
                // Type regular text character by character
                if (charIndex < segment.text.length) {
                    state.currentText += segment.text[charIndex];
                    thoughtElement.textContent = state.currentText;

                    // Calculate delay - longer after punctuation, variable otherwise
                    let delay = 0;
                    if (!prefersReducedMotion) {
                        const currentChar = segment.text[charIndex];
                        if (isPunctuation(currentChar)) {
                            delay = systemMood === 'glitchy'
                                ? (Math.random() > 0.5 ? timing.punctuationPause * 1.5 : timing.punctuationPause * 0.3)
                                : timing.punctuationPause;
                        } else {
                            delay = systemMood === 'glitchy'
                                ? getGlitchyDelay(timing.typeSpeedMin, timing.typeSpeedMax)
                                : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                        }
                    }

                    state.animationTimeout = setTimeout(() => {
                        typeWithBackspaceEffect(segments, segmentIndex, charIndex + 1, callback);
                    }, delay);
                } else {
                    // Move to next segment
                    typeWithBackspaceEffect(segments, segmentIndex + 1, 0, callback);
                }
            } else if (segment.type === 'backspace') {
                // Type the mistake, pause, then backspace it
                if (charIndex < segment.text.length) {
                    // Typing the mistake
                    state.currentText += segment.text[charIndex];
                    thoughtElement.textContent = state.currentText;

                    let delay = 0;
                    if (!prefersReducedMotion) {
                        delay = systemMood === 'glitchy'
                            ? getGlitchyDelay(timing.typeSpeedMin, timing.typeSpeedMax)
                            : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                    }

                    state.animationTimeout = setTimeout(() => {
                        typeWithBackspaceEffect(segments, segmentIndex, charIndex + 1, callback);
                    }, delay);
                } else {
                    // Finished typing the mistake, now pause and backspace
                    const mistakeLength = segment.text.length;

                    state.animationTimeout = setTimeout(() => {
                        // Backspace the mistake character by character (faster than typing)
                        backspaceNCharacters(mistakeLength, () => {
                            // Move to next segment after backspacing
                            typeWithBackspaceEffect(segments, segmentIndex + 1, 0, callback);
                        });
                    }, 500); // 500ms pause before backspacing
                }
            }
        }

        // Helper function to backspace N characters quickly
        function backspaceNCharacters(count, callback) {
            if (state.isUserTyping || state.isSelected) return;

            if (count > 0 && state.currentText.length > 0) {
                state.currentText = state.currentText.substring(0, state.currentText.length - 1);
                thoughtElement.textContent = state.currentText;

                // Backspace is faster than typing
                const delay = prefersReducedMotion ? 0 : randomDelay(timing.backspaceSpeedMin, timing.backspaceSpeedMax);

                state.animationTimeout = setTimeout(() => {
                    backspaceNCharacters(count - 1, callback);
                }, delay);
            } else {
                if (callback) callback();
            }
        }

        function typeCharacter(text, index, callback) {
            if (state.isUserTyping || state.isSelected) return;

            // Instant mode: bypass typing animation entirely
            if (isInstantMode() || prefersReducedMotion) {
                // Strip backspace syntax and display final text immediately
                state.currentText = stripBackspaceSyntax(text);
                thoughtElement.textContent = state.currentText;
                if (callback) callback();
                return;
            }

            // Check if text contains backspace syntax
            if (text.includes('{')) {
                // Parse and type with backspace effect
                const segments = parseBackspaceSegments(text);
                state.currentText = ''; // Reset current text
                typeWithBackspaceEffect(segments, 0, 0, callback);
            } else {
                // Original typing logic for text without backspace syntax
                if (index <= text.length) {
                    state.currentText = text.substring(0, index);
                    thoughtElement.textContent = state.currentText;

                    // Calculate delay - longer after punctuation, variable otherwise
                    let delay = 0;
                    const lastChar = text.charAt(index - 1);
                    if (isPunctuation(lastChar)) {
                        // Glitchy mood has random punctuation pauses
                        delay = systemMood === 'glitchy'
                            ? (Math.random() > 0.5 ? timing.punctuationPause * 1.5 : timing.punctuationPause * 0.3)
                            : timing.punctuationPause;
                    } else {
                        // Use glitchy delay for glitchy mood
                        delay = systemMood === 'glitchy'
                            ? getGlitchyDelay(timing.typeSpeedMin, timing.typeSpeedMax)
                            : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                    }

                    state.animationTimeout = setTimeout(() => {
                        typeCharacter(text, index + 1, callback);
                    }, delay);
                } else {
                    if (callback) callback();
                }
            }
        }

        function backspaceCharacter(callback) {
            if (state.isUserTyping || state.isSelected) return;

            if (state.currentText.length > 0) {
                state.currentText = state.currentText.substring(0, state.currentText.length - 1);
                thoughtElement.textContent = state.currentText;

                // Random jitter for backspace speed
                const delay = prefersReducedMotion ? 0 : randomDelay(timing.backspaceSpeedMin, timing.backspaceSpeedMax);

                state.animationTimeout = setTimeout(() => {
                    backspaceCharacter(callback);
                }, delay);
            } else {
                if (callback) callback();
            }
        }

        function showThought(index) {
            if (state.isUserTyping || state.isSelected || state.isAnimating) return;

            // Apply scene-specific atmosphere (typing speed and mood) before typing begins
            applySceneAtmosphere(index);

            state.isAnimating = true;
            const originalThought = thoughts[index];
            // Process in order: 1) Replace <<name>>, 2) Strip [meltdown] triggers
            const thought = stripMeltdownTriggers(replaceName(originalThought));
            state.targetText = thought;
            thoughtElement.dataset.index = index;

            // Make thought visible and start typing
            thoughtElement.classList.remove('fade-out');
            thoughtElement.classList.add('visible', 'fade-in');

            // Type out the thought character by character
            typeCharacter(thought, 0, () => {
                if (choiceButtonsEnabled) {
                    // CYOA Mode: Show choice buttons and wait indefinitely for user interaction
                    // No auto-cycle, no skip logic - buttons stay until user clicks
                    state.waitingForChoice = true;
                    state.isAnimating = false; // Allow user to interact
                    showChoiceButtons();
                } else {
                    // Legacy mode: Auto-cycle through thoughts with linger time
                    state.cycleTimeout = setTimeout(() => {
                        if (!state.isUserTyping && !state.isSelected) {
                            // Backspace the thought
                            backspaceCharacter(() => {
                                state.isAnimating = false;
                                // Move to next thought
                                state.currentIndex = (state.currentIndex + 1) % thoughts.length;
                                showThought(state.currentIndex);
                            });
                        }
                    }, timing.linger);
                }
            });
        }

        // Show choice buttons with animation
        function showChoiceButtons() {
            if (choiceButtonsContainer) {
                // Reset any previous selection state - remove ALL state classes
                choiceButtonsContainer.classList.remove('selection-made', 'fading-out');
                const yesBtn = document.getElementById('choiceBtnYes');
                const noBtn = document.getElementById('choiceBtnNo');

                // Thoroughly clean all button states to ensure responsiveness
                if (yesBtn) {
                    yesBtn.classList.remove('selected', 'btn-active', 'disabled');
                    // Set dynamic button text - use custom text or fallback to "Yes"
                    const choiceAText = choiceATexts[state.currentIndex];
                    yesBtn.textContent = (choiceAText && choiceAText.trim()) ? choiceAText : 'Yes';
                }
                if (noBtn) {
                    noBtn.classList.remove('selected', 'btn-active', 'disabled');
                    // Set dynamic button text - use custom text or fallback to "No"
                    const choiceBText = choiceBTexts[state.currentIndex];
                    noBtn.textContent = (choiceBText && choiceBText.trim()) ? choiceBText : 'No';
                }

                // Hide the New Question button in choice area
                hideNewQuestionButton('choice');

                choiceButtonsContainer.hidden = false;
                // Trigger animation after a brief delay
                setTimeout(() => {
                    choiceButtonsContainer.classList.add('visible');
                }, 50);
            }
        }

        // Hide choice buttons
        function hideChoiceButtons() {
            if (choiceButtonsContainer) {
                choiceButtonsContainer.classList.remove('visible');
                setTimeout(() => {
                    choiceButtonsContainer.hidden = true;
                }, 300); // Wait for fade out transition
            }
        }

        // Mark a choice button as selected (persistent visual state)
        function markChoiceSelection(choice) {
            if (!choiceButtonsContainer) return;

            // Add selection-made class to disable further interaction
            choiceButtonsContainer.classList.add('selection-made');

            // Add selected class to the chosen button
            const yesBtn = document.getElementById('choiceBtnYes');
            const noBtn = document.getElementById('choiceBtnNo');

            if (choice === 'yes' && yesBtn) {
                yesBtn.classList.add('selected');
            } else if (choice === 'no' && noBtn) {
                noBtn.classList.add('selected');
            }
        }

        // Reset choice buttons to initial state
        function resetChoiceButtons() {
            if (!choiceButtonsContainer) return;

            // Remove all state classes from container
            choiceButtonsContainer.classList.remove('selection-made', 'visible', 'fading-out');
            choiceButtonsContainer.hidden = true;

            // Remove all state classes from buttons
            const yesBtn = document.getElementById('choiceBtnYes');
            const noBtn = document.getElementById('choiceBtnNo');
            if (yesBtn) {
                yesBtn.classList.remove('selected', 'disabled', 'btn-active');
            }
            if (noBtn) {
                noBtn.classList.remove('selected', 'disabled', 'btn-active');
            }

            // Hide the New Question button in choice area
            hideNewQuestionButton('choice');
        }

        // Type out New Question button text character by character
        function typeNewQuestionText(btn, text, index, callback) {
            if (!btn) {
                if (callback) callback();
                return;
            }

            if (index <= text.length) {
                // Show cursor after text
                btn.innerHTML = text.substring(0, index) + '<span class="typing-cursor">â–ˆ</span>';

                const delay = prefersReducedMotion ? 0 : randomDelay(50, 100);
                setTimeout(() => {
                    typeNewQuestionText(btn, text, index + 1, callback);
                }, delay);
            } else {
                // Typing complete - show final text without cursor
                btn.textContent = text;
                if (callback) callback();
            }
        }

        // Show New Question button with typing animation
        function showNewQuestionButton(location) {
            let btn;
            if (location === 'choice') {
                btn = document.getElementById('newQuestionBtnChoice');
            } else if (typeof location === 'number') {
                btn = document.getElementById('newQuestionBtn' + location);
            }

            if (btn) {
                const buttonText = 'New Question';
                // Clear initial text for typing
                btn.textContent = '';
                // Make visible but not interactive during typing
                btn.classList.add('visible');
                btn.style.pointerEvents = 'none';

                // Type out the button text
                setTimeout(() => {
                    typeNewQuestionText(btn, buttonText, 0, () => {
                        // Enable interaction after typing completes
                        btn.style.pointerEvents = 'auto';
                    });
                }, 200);
            }
        }

        // Hide New Question button
        function hideNewQuestionButton(location) {
            let btn;
            if (location === 'choice') {
                btn = document.getElementById('newQuestionBtnChoice');
            } else if (typeof location === 'number') {
                btn = document.getElementById('newQuestionBtn' + location);
            }

            if (btn) {
                btn.classList.remove('visible');
                btn.style.pointerEvents = '';
                btn.textContent = 'New Question';
            }
        }

        // Hide all New Question buttons
        function hideAllNewQuestionButtons() {
            const choiceBtn = document.getElementById('newQuestionBtnChoice');
            if (choiceBtn) {
                choiceBtn.classList.remove('visible');
                choiceBtn.style.pointerEvents = '';
                choiceBtn.textContent = 'New Question';
            }

            // Loop through all possible panel buttons (up to 50 for dynamic thoughts)
            for (let i = 0; i < 50; i++) {
                const panelBtn = document.getElementById('newQuestionBtn' + i);
                if (panelBtn) {
                    panelBtn.classList.remove('visible');
                    panelBtn.style.pointerEvents = '';
                    panelBtn.textContent = 'New Question';
                }
            }
        }

        // Handle Yes button click (Choice A) - check for end action or redirect
        function handleChoiceYes() {
            // Check if terminal is locked (animation playing)
            if (state.terminalLocked) return;
            if (!state.waitingForChoice) return;

            // Get the per-choice action configuration for Choice A
            const choiceAction = choiceAActions[state.currentIndex] || { type: 'none', endAction: false };

            // CRITICAL: Check if this is an End Action (triggers action and stops story)
            if (choiceAction.endAction && choiceAction.type && choiceAction.type !== 'none') {
                // Immediately prevent multiple clicks
                state.waitingForChoice = false;

                // Add flash feedback effect
                const yesBtn = document.getElementById('choiceBtnYes');
                if (yesBtn) {
                    yesBtn.classList.add('btn-active');
                    setTimeout(() => {
                        yesBtn.classList.remove('btn-active');
                    }, 150);
                }

                // Mark selection made
                markChoiceSelection('yes');

                // Execute the end action based on type (stays on final frame, no navigation)
                executeChoiceAction(choiceAction.type);
                return;
            }

            // Immediately prevent multiple clicks
            state.waitingForChoice = false;

            // Add flash feedback effect
            const yesBtn = document.getElementById('choiceBtnYes');
            if (yesBtn) {
                yesBtn.classList.add('btn-active');
                setTimeout(() => {
                    yesBtn.classList.remove('btn-active');
                }, 150);
            }

            // Check if there's an action type that needs to play before navigation
            const hasTransitionAnimation = choiceAction.type && choiceAction.type !== 'none' && getActionDelay(choiceAction.type) > 0;

            // Define the navigation function
            const performNavigation = () => {
                // Check if there's a redirect index configured
                const redirectIndex = yesRedirectIndices[state.currentIndex];
                if (redirectIndex && redirectIndex !== '') {
                    // Convert to 0-based index (admin shows 1-based)
                    const targetIndex = parseInt(redirectIndex) - 1;

                    // Validate the target index
                    if (targetIndex >= 0 && targetIndex < thoughts.length) {
                        // Mark selection made
                        markChoiceSelection('yes');

                        // Hide choice buttons
                        hideChoiceButtons();

                        // Immediately clear the screen
                        thoughtElement.textContent = '';
                        state.currentText = '';

                        // Reset choice buttons for next thought
                        setTimeout(() => {
                            resetChoiceButtons();

                            // Jump to the specified index
                            state.currentIndex = targetIndex;
                            state.isAnimating = false;
                            showThought(state.currentIndex);
                        }, 100);
                    } else {
                        console.warn('Invalid yes redirect index:', redirectIndex);
                        // Fall back to advancing to next thought
                        advanceToNextThought('yes');
                    }
                } else {
                    // No redirect configured - advance to next story block
                    advanceToNextThought('yes');
                }
            };

            // If there's a transition animation, play it first then navigate
            if (hasTransitionAnimation) {
                // Lock terminal and play animation, then navigate
                triggerTransitionAnimation(choiceAction.type, performNavigation);
            } else {
                // No animation needed, navigate immediately
                performNavigation();
            }
        }

        // Helper function to advance to next thought (shared by Choice A and B)
        function advanceToNextThought(choice) {
            markChoiceSelection(choice);
            hideChoiceButtons();

            setTimeout(() => {
                thoughtElement.textContent = '';
                state.currentText = '';
                resetChoiceButtons();

                state.currentIndex = (state.currentIndex + 1) % thoughts.length;
                state.isAnimating = false;
                showThought(state.currentIndex);
            }, 200);
        }

        // Execute a choice-specific action (for End Actions)
        function executeChoiceAction(actionType) {
            switch (actionType) {
                case 'system-meltdown':
                    triggerMeltdown();
                    break;
                case 'trigger-fin':
                    showFinOverlay();
                    stopCycling();
                    break;
                case 'matrix':
                    triggerMatrixAnimation();
                    break;
                case 'contact':
                    openContactModal();
                    break;
                case 'supernova-flash':
                    triggerSupernovaFlash();
                    break;
                case 'spaghettify':
                    triggerSpaghettify();
                    break;
                case 'hull-breach':
                    triggerHullBreach();
                    break;
                case 'oxygen-depletion':
                    triggerOxygenDepletion();
                    break;
                case 'recursive-reality':
                    triggerRecursiveReality();
                    break;
                case 'quantum-leak':
                    triggerQuantumLeak();
                    break;
                case 'hypnotic-spiral':
                    triggerHypnoticSpiral();
                    break;
                default:
                    console.log('End action triggered:', actionType);
                    stopCycling();
            }
        }

        // Handle Choice B click - check for redirect or advance to next thought
        function triggerBackspaceAndNext(isTimeout = false) {
            // Check if terminal is locked (animation playing)
            if (state.terminalLocked) return;
            if (!state.waitingForChoice) return;

            // Immediately prevent multiple clicks
            state.waitingForChoice = false;

            const noBtn = document.getElementById('choiceBtnNo');

            if (noBtn) {
                // Flash effect
                noBtn.classList.add('btn-active');
                setTimeout(() => {
                    noBtn.classList.remove('btn-active');
                }, 180);
            }

            // Check if there's a redirect index configured
            const redirectIndex = noRedirectIndices[state.currentIndex];
            if (redirectIndex && redirectIndex !== '') {
                // Convert to 0-based index (admin shows 1-based)
                const targetIndex = parseInt(redirectIndex) - 1;

                // Validate the target index
                if (targetIndex >= 0 && targetIndex < thoughts.length) {
                    // Mark selection made
                    markChoiceSelection('no');
                    hideChoiceButtons();

                    // Clear the screen and jump to target
                    setTimeout(() => {
                        thoughtElement.textContent = '';
                        state.currentText = '';
                        resetChoiceButtons();

                        state.currentIndex = targetIndex;
                        state.isAnimating = false;
                        showThought(state.currentIndex);
                    }, 200);
                } else {
                    console.warn('Invalid no redirect index:', redirectIndex);
                    advanceToNextThought('no');
                }
            } else {
                // No redirect configured - advance to next thought
                advanceToNextThought('no');
            }
        }

        // Handle No button click (Choice B) - check for end action or redirect
        function handleChoiceNo() {
            // Check if terminal is locked (animation playing)
            if (state.terminalLocked) return;
            if (!state.waitingForChoice) return;

            // Get the per-choice action configuration for Choice B
            const choiceAction = choiceBActions[state.currentIndex] || { type: 'none', endAction: false };

            // CRITICAL: Check if this is an End Action (triggers action and stops story)
            if (choiceAction.endAction && choiceAction.type && choiceAction.type !== 'none') {
                // Immediately prevent multiple clicks
                state.waitingForChoice = false;

                // Add flash feedback effect
                const noBtn = document.getElementById('choiceBtnNo');
                if (noBtn) {
                    noBtn.classList.add('btn-active');
                    setTimeout(() => {
                        noBtn.classList.remove('btn-active');
                    }, 180);
                }

                // Mark selection made
                markChoiceSelection('no');

                // Execute the end action based on type (stays on final frame, no navigation)
                executeChoiceAction(choiceAction.type);
                return;
            }

            // Immediately prevent multiple clicks
            state.waitingForChoice = false;

            // Add flash feedback effect
            const noBtn = document.getElementById('choiceBtnNo');
            if (noBtn) {
                noBtn.classList.add('btn-active');
                setTimeout(() => {
                    noBtn.classList.remove('btn-active');
                }, 180);
            }

            // Check if there's an action type that needs to play before navigation
            const hasTransitionAnimation = choiceAction.type && choiceAction.type !== 'none' && getActionDelay(choiceAction.type) > 0;

            // Define the navigation function
            const performNavigation = () => {
                // Check if there's a redirect index configured
                const redirectIndex = noRedirectIndices[state.currentIndex];
                if (redirectIndex && redirectIndex !== '') {
                    // Convert to 0-based index (admin shows 1-based)
                    const targetIndex = parseInt(redirectIndex) - 1;

                    // Validate the target index
                    if (targetIndex >= 0 && targetIndex < thoughts.length) {
                        // Mark selection made
                        markChoiceSelection('no');
                        hideChoiceButtons();

                        // Clear the screen and jump to target
                        setTimeout(() => {
                            thoughtElement.textContent = '';
                            state.currentText = '';
                            resetChoiceButtons();

                            state.currentIndex = targetIndex;
                            state.isAnimating = false;
                            showThought(state.currentIndex);
                        }, 200);
                    } else {
                        console.warn('Invalid no redirect index:', redirectIndex);
                        advanceToNextThought('no');
                    }
                } else {
                    // No redirect configured - advance to next thought
                    advanceToNextThought('no');
                }
            };

            // If there's a transition animation, play it first then navigate
            if (hasTransitionAnimation) {
                // Lock terminal and play animation, then navigate
                triggerTransitionAnimation(choiceAction.type, performNavigation);
            } else {
                // No animation needed, navigate immediately
                performNavigation();
            }
        }

        function startCycling() {
            // Check if there are any active thoughts to cycle
            if (thoughts.length === 0) {
                // No active thoughts - show cursor but display fallback message
                cursorElement.classList.add('visible');
                thoughtElement.textContent = 'No questions available';
                thoughtElement.classList.add('visible', 'fade-in');
                return;
            }

            // If hero was typed, cursor is already visible and we skip the initial delay
            // (the 1.5s pause after hero typing serves as the delay)
            if (state.heroTyped) {
                showThought(state.currentIndex);
            } else {
                // Original behavior: Show cursor after initial delay, then start cycling thoughts
                state.cycleTimeout = setTimeout(() => {
                    cursorElement.classList.add('visible');
                    showThought(state.currentIndex);
                }, timing.initialDelay);
            }
        }

        function stopCycling() {
            clearTimeout(state.cycleTimeout);
            clearTimeout(state.animationTimeout);
            clearTimeout(state.idleTimeout);
            state.isAnimating = false;
        }

        // ========================================
        // Thought Selection
        // ========================================
        // Helper to get original index from filtered index
        function getOriginalIndex(filteredIndex) {
            if (typeof filteredIndex === 'number' && activeIndices[filteredIndex] !== undefined) {
                return activeIndices[filteredIndex];
            }
            return filteredIndex; // Return as-is for 'custom' or invalid
        }

        function selectThought(index) {
            // Track user activity
            trackUserActivity();
            // Reset error counter on successful interaction
            resetTerminalErrors();

            state.isSelected = true;
            state.selectedIndex = index;
            // Sync currentIndex for sequential cycling continuity
            if (typeof index === 'number') {
                state.currentIndex = index;
            }
            stopCycling();

            // If we're selecting a cycling thought, show the full text (without backspace syntax and meltdown triggers)
            if (typeof index === 'number' && thoughts[index]) {
                const cleanText = replaceName(stripBackspaceSyntax(stripMeltdownTriggers(thoughts[index])));
                thoughtElement.textContent = cleanText;
                state.currentText = cleanText;
            }

            // Lock the thought in place
            thoughtElement.classList.add('selected');
            thoughtElement.classList.remove('fade-out', 'fade-in');
            thoughtElement.setAttribute('aria-pressed', 'true');

            // Hide cursor from thought line (it will appear in response)
            cursorElement.classList.remove('visible');

            // Get the original index for panel lookup
            const originalIndex = getOriginalIndex(index);

            // Pre-load audio if this thought has an audio action
            const action = (typeof originalIndex === 'number' && actions[originalIndex]) ? actions[originalIndex] : null;
            if (action && action.type === 'audio' && action.url) {
                // Stop any previously loaded audio
                if (state.currentAudio) {
                    state.currentAudio.pause();
                    state.currentAudio = null;
                }
                // Pre-load the audio file (will not play automatically)
                state.currentAudio = new Audio(action.url);
                state.currentAudio.preload = 'auto';
            }

            // Show the corresponding panel using original index
            showPanel(index, originalIndex);
        }

        function showPanel(filteredIndex, originalIndex) {
            const panels = panelsContainer.querySelectorAll('.explore-panel');
            // Use original index for panel data-thought lookup, filtered index for responses array
            const panelId = typeof originalIndex === 'number' ? originalIndex : filteredIndex;

            panels.forEach(panel => {
                if (panel.dataset.thought === String(panelId)) {
                    panel.hidden = false;
                    panel.classList.add('visible');

                    // Get panel elements
                    const responseEl = panel.querySelector('.panel-response');
                    const textEl = panel.querySelector('.response-text');
                    const actionsEl = panel.querySelector('.explore-panel-actions');
                    const actionBtn = panel.querySelector('.explore-action-btn');

                    if (responseEl && textEl) {
                        // Get response from filtered responses array
                        const fullResponse = (typeof filteredIndex === 'number' && responses[filteredIndex])
                            ? responses[filteredIndex]
                            : "Every project starts with a conversation. Let's start ours.";
                        textEl.textContent = '';

                        // Clear action button text
                        if (actionBtn) {
                            const actionText = actionBtn.querySelector('.action-text');
                            if (actionText) actionText.textContent = '';
                            actionBtn.classList.add('hidden');
                        }

                        // Hide actions initially
                        if (actionsEl) actionsEl.classList.remove('visible');

                        // Start sequential typing: response -> action button
                        // Pass original index for action lookup
                        const processedResponse = replaceName(fullResponse);
                        typePanelResponse(textEl, actionsEl, actionBtn, processedResponse, 0, originalIndex);
                    }

                    // Focus the panel for accessibility
                    setTimeout(() => {
                        const focusTarget = panel.querySelector('.panel-response') || panel.querySelector('h2');
                        if (focusTarget) focusTarget.focus();
                    }, 100);
                } else {
                    panel.hidden = true;
                    panel.classList.remove('visible');
                    // Clear any response text when hiding
                    const textEl = panel.querySelector('.response-text');
                    const actionsEl = panel.querySelector('.explore-panel-actions');
                    if (textEl) textEl.textContent = '';
                    if (actionsEl) actionsEl.classList.remove('visible');
                }
            });

            panelsContainer.classList.add('visible');
        }

        function typePanelResponse(textEl, actionsEl, actionBtn, text, charIndex, panelIndex) {
            if (charIndex <= text.length) {
                // Show cursor after text
                textEl.innerHTML = text.substring(0, charIndex) + '<span class="typing-cursor">â–ˆ</span>';

                let delay = 0;
                if (!prefersReducedMotion) {
                    const lastChar = text.charAt(charIndex - 1);
                    if (isPunctuation(lastChar)) {
                        // Glitchy mood has random punctuation pauses
                        delay = systemMood === 'glitchy'
                            ? (Math.random() > 0.5 ? timing.punctuationPause * 1.5 : timing.punctuationPause * 0.3)
                            : timing.punctuationPause;
                    } else {
                        // Use glitchy delay for glitchy mood
                        delay = systemMood === 'glitchy'
                            ? getGlitchyDelay(timing.typeSpeedMin, timing.typeSpeedMax)
                            : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                    }
                }

                setTimeout(() => {
                    typePanelResponse(textEl, actionsEl, actionBtn, text, charIndex + 1, panelIndex);
                }, delay);
            } else {
                // Response typing complete - remove cursor from response
                textEl.textContent = text;

                // Show action button if this thought has an action configured
                showActionButton(actionsEl, actionBtn, panelIndex);
            }
        }

        function showActionButton(actionsEl, actionBtn, panelIndex) {
            // Check if this panel has an action
            const action = (typeof panelIndex === 'number' && actions[panelIndex]) ? actions[panelIndex] : null;
            const hasAction = action && action.type && action.type !== 'none';

            if (hasAction && actionBtn) {
                // Show actions container
                if (actionsEl) {
                    actionsEl.classList.add('visible');
                }

                const actionLinkText = replaceName(action.linkText || 'Click here');
                actionBtn.classList.remove('hidden');

                // Type out the action button text
                typeActionText(actionBtn, actionLinkText, 0, () => {
                    // Set up action button handler
                    actionBtn.classList.add('ready');
                    actionBtn.onclick = () => executeAction(action);

                    // Stop cursor blinking - typing is complete
                    cursorElement.classList.add('cursor-stopped');

                    // Show New Question button after action is ready
                    showNewQuestionButton(panelIndex);
                });
            } else {
                // No action configured - just stop cursor blinking
                cursorElement.classList.add('cursor-stopped');

                // Show New Question button even if no action
                if (typeof panelIndex === 'number') {
                    if (actionsEl) {
                        actionsEl.classList.add('visible');
                    }
                    showNewQuestionButton(panelIndex);
                }
            }
        }

        function typeActionText(btn, text, index, callback) {
            if (!btn) {
                if (callback) callback();
                return;
            }

            const textSpan = btn.querySelector('.action-text');
            if (!textSpan) {
                if (callback) callback();
                return;
            }

            if (index <= text.length) {
                // Show cursor after text
                textSpan.innerHTML = text.substring(0, index) + '<span class="typing-cursor">â–ˆ</span>';

                const delay = prefersReducedMotion ? 0 : randomDelay(60, 120);
                setTimeout(() => {
                    typeActionText(btn, text, index + 1, callback);
                }, delay);
            } else {
                // Typing complete - show final text without cursor
                textSpan.textContent = text;
                if (callback) callback();
            }
        }

        // ========================================
        // Action Execution
        // ========================================
        function executeAction(action) {
            if (!action || !action.type) return;

            switch (action.type) {
                case 'video':
                    openVideoModal(action.url);
                    break;
                case 'image':
                    openImageModal(action.url);
                    break;
                case 'logo':
                    printAsciiLogo(action.logo);
                    break;
                case 'matrix':
                    triggerMatrixAnimation();
                    break;
                case 'contact':
                    openContactModal();
                    break;
                case 'capture-name':
                    // Activate name capture mode directly in terminal
                    stopCycling();
                    state.capturingName = true;
                    state.isSelected = true; // Lock the thought

                    // Display the prompt in the thought element
                    thoughtElement.textContent = '> ENTER YOUR NAME:';
                    thoughtElement.classList.add('selected', 'visible');
                    thoughtElement.classList.remove('fade-out', 'fade-in');
                    cursorElement.classList.remove('visible');

                    // Clear and focus the input
                    inputElement.value = '';
                    inputElement.focus();
                    inputElement.classList.add('active');
                    break;
                case 'audio':
                    // Play the pre-loaded audio when user clicks the trigger text
                    if (state.currentAudio) {
                        // Reset to beginning if already played
                        state.currentAudio.currentTime = 0;
                        // Play the audio (user-initiated, not automatic)
                        state.currentAudio.play().catch(err => {
                            console.warn('Audio playback failed:', err);
                        });
                    } else if (action.url) {
                        // Fallback: create and play if not pre-loaded
                        const audio = new Audio(action.url);
                        audio.play().catch(err => {
                            console.warn('Audio playback failed:', err);
                        });
                    }
                    break;
                case 'trigger-fin':
                    // Show the Fin (The End) overlay
                    showFinOverlay();
                    // Stop all cycling
                    stopCycling();
                    break;
                case 'system-meltdown':
                    // Trigger the system meltdown sequence
                    executeMeltdown();
                    break;
            }
        }

        // ========================================
        // Multimedia Modal (Video/Image)
        // ========================================
        function openVideoModal(url) {
            if (!url) return;

            const modal = document.getElementById('multimediaModal');
            const content = document.getElementById('multimediaContent');

            // Extract video ID from YouTube URL
            let videoId = '';
            const urlPatterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\s?]+)/,
                /youtube\.com\/shorts\/([^&\s?]+)/
            ];

            for (const pattern of urlPatterns) {
                const match = url.match(pattern);
                if (match) {
                    videoId = match[1];
                    break;
                }
            }

            if (videoId) {
                content.innerHTML = `
                    <iframe
                        src="https://www.youtube.com/embed/${videoId}?autoplay=1"
                        frameborder="0"
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen>
                    </iframe>
                `;
            } else {
                // Fallback: try embedding as-is
                content.innerHTML = `
                    <iframe
                        src="${url}"
                        frameborder="0"
                        allowfullscreen>
                    </iframe>
                `;
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function openImageModal(url) {
            if (!url) return;

            const modal = document.getElementById('multimediaModal');
            const content = document.getElementById('multimediaContent');

            content.innerHTML = `<img src="${url}" alt="Image content" class="modal-image">`;

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeMultimediaModal() {
            const modal = document.getElementById('multimediaModal');
            const content = document.getElementById('multimediaContent');

            modal.classList.remove('active');
            document.body.style.overflow = '';

            // Clear content to stop video playback
            setTimeout(() => {
                content.innerHTML = '';
            }, 300);
        }

        function closeMultimediaModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeMultimediaModal();
            }
        }

        // ========================================
        // ASCII Logo Printing
        // ========================================
        function printAsciiLogo(logoText) {
            if (!logoText) return;

            const container = document.getElementById('asciiLogoContainer');

            // Clear any existing content
            container.innerHTML = '';

            // Create wrapper for positioning the close button
            const wrapper = document.createElement('div');
            wrapper.className = 'ascii-logo-wrapper';

            // Create home link that wraps the logo
            const homeLink = document.createElement('a');
            homeLink.className = 'ascii-logo-home-link';
            homeLink.href = 'index.html';
            homeLink.setAttribute('aria-label', 'Return to home and reset terminal');
            homeLink.onclick = function(e) {
                e.preventDefault();
                closeAsciiLogo();
                resetExplore();
            };

            // Create close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'ascii-logo-close';
            closeBtn.textContent = 'X';
            closeBtn.setAttribute('aria-label', 'Close logo');
            closeBtn.onclick = function(e) {
                e.stopPropagation();
                closeAsciiLogo();
            };

            // Create logo element
            const logoElement = document.createElement('pre');
            logoElement.className = 'ascii-logo';
            logoElement.textContent = '';

            // Structure: wrapper > homeLink > logoElement, wrapper > closeBtn
            homeLink.appendChild(logoElement);
            wrapper.appendChild(homeLink);
            wrapper.appendChild(closeBtn);
            container.appendChild(wrapper);

            // Show the container
            container.classList.add('visible');

            // Type out the logo character by character
            typeAsciiLogo(logoElement, logoText, 0);
        }

        function typeAsciiLogo(element, text, index) {
            if (index <= text.length) {
                element.textContent = text.substring(0, index);

                // Faster typing for ASCII art
                const delay = prefersReducedMotion ? 0 : randomDelay(5, 15);
                setTimeout(() => {
                    typeAsciiLogo(element, text, index + 1);
                }, delay);
            }
        }

        function closeAsciiLogo() {
            const container = document.getElementById('asciiLogoContainer');
            container.classList.remove('visible');
            // Clear content after hiding
            setTimeout(() => {
                container.innerHTML = '';
            }, 300);
        }

        // ========================================
        // The Matrix Animation
        // ========================================
        function triggerMatrixAnimation() {
            if (state.matrixActive) return;

            state.matrixActive = true;
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas to full screen
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.classList.remove('fade-out');
            canvas.classList.add('active');

            const fontSize = 14;
            const columns = Math.floor(canvas.width / fontSize);
            const drops = Array(columns).fill(1);

            function draw() {
                // Semi-transparent black background for trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Green text - updated to #34ff35
                ctx.fillStyle = '#34ff35';
                ctx.font = fontSize + 'px VT323, monospace';
                ctx.shadowColor = 'rgba(52, 255, 53, 0.5)';
                ctx.shadowBlur = 4;

                for (let i = 0; i < drops.length; i++) {
                    // Random 0 or 1
                    const char = Math.random() > 0.5 ? '1' : '0';
                    ctx.fillText(char, i * fontSize, drops[i] * fontSize);

                    // Reset drop when it reaches bottom or randomly
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }

            // Run animation for 5 seconds
            const interval = setInterval(draw, 50);

            setTimeout(() => {
                clearInterval(interval);

                // Apply dynamic fade duration from admin settings
                const fadeDurationMs = matrixFadeDuration * 1000;
                canvas.style.transition = `opacity ${matrixFadeDuration}s ease`;

                // Start fade-out transition
                canvas.classList.add('fade-out');

                // After fade-out completes, clean up
                setTimeout(() => {
                    canvas.classList.remove('active', 'fade-out');
                    canvas.style.transition = ''; // Reset to CSS default
                    state.matrixActive = false;
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }, fadeDurationMs);
            }, 5000);
        }

        // Handle window resize for Matrix canvas
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('matrixCanvas');
            if (canvas.classList.contains('active')) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        });

        // ========================================
        // Space-Themed End Actions
        // ========================================

        // Supernova Flash: Blinding white flash transitioning to deep celestial purple
        function triggerSupernovaFlash() {
            console.log('SUPERNOVA FLASH TRIGGERED');
            stopCycling();

            // Create overlay element
            const overlay = document.createElement('div');
            overlay.id = 'supernovaOverlay';
            overlay.className = 'supernova-overlay';
            document.body.appendChild(overlay);

            // Phase 1: Blinding white flash
            overlay.classList.add('active', 'white-flash');

            // Phase 2: Transition to celestial purple (after 1.5s)
            setTimeout(() => {
                overlay.classList.remove('white-flash');
                overlay.classList.add('celestial-purple');
            }, 1500);

            // Phase 3: Show FIN overlay (after purple settles - 3.5s total)
            setTimeout(() => {
                showFinOverlay();
            }, 3500);

            // Phase 4: Fade out supernova overlay (after 5s total)
            setTimeout(() => {
                overlay.classList.add('fade-out');
                setTimeout(() => {
                    overlay.remove();
                }, 1000);
            }, 5000);
        }

        // Spaghettify: Black hole effect that warps and pulls text into center
        function triggerSpaghettify() {
            console.log('SPAGHETTIFY (BLACK HOLE) TRIGGERED');
            stopCycling();

            // Add spaghettify class to terminal elements
            const explorePage = document.querySelector('.explore-page');
            const terminalBody = document.getElementById('terminal-body');
            const thoughtElement = document.getElementById('currentThought');

            // Create black hole overlay
            const overlay = document.createElement('div');
            overlay.id = 'blackHoleOverlay';
            overlay.className = 'black-hole-overlay';

            // Create the event horizon (center point)
            const eventHorizon = document.createElement('div');
            eventHorizon.className = 'event-horizon';
            overlay.appendChild(eventHorizon);

            document.body.appendChild(overlay);
            overlay.classList.add('active');

            // Apply spaghettify effect to text elements
            if (explorePage) explorePage.classList.add('spaghettify');
            if (terminalBody) terminalBody.classList.add('spaghettify');
            if (thoughtElement) thoughtElement.classList.add('spaghettify');

            // After spaghettification completes (3s), show FIN
            setTimeout(() => {
                showFinOverlay();
            }, 3000);

            // Fade out black hole effect
            setTimeout(() => {
                overlay.classList.add('fade-out');
                if (explorePage) explorePage.classList.remove('spaghettify');
                if (terminalBody) terminalBody.classList.remove('spaghettify');
                if (thoughtElement) thoughtElement.classList.remove('spaghettify');
                setTimeout(() => {
                    overlay.remove();
                }, 1500);
            }, 4500);
        }

        // Hull Breach: Rapid text wipe with depressurization sound
        function triggerHullBreach() {
            console.log('HULL BREACH TRIGGERED');
            stopCycling();

            // Play depressurization sound if not muted
            if (!globalAudioMuted) {
                const depressSound = new Audio('assets/audio/hull-breach.mp3');
                depressSound.volume = 0.7;
                depressSound.play().catch(e => console.log('Hull breach audio failed:', e));
            }

            // Create hull breach overlay
            const overlay = document.createElement('div');
            overlay.id = 'hullBreachOverlay';
            overlay.className = 'hull-breach-overlay';
            document.body.appendChild(overlay);
            overlay.classList.add('active');

            // Apply hull breach wipe effect to terminal
            const explorePage = document.querySelector('.explore-page');
            const thoughtElement = document.getElementById('currentThought');

            if (explorePage) explorePage.classList.add('hull-breach-wipe');
            if (thoughtElement) thoughtElement.classList.add('hull-breach-wipe');

            // Rapid text wipe animation
            if (thoughtElement) {
                const currentText = thoughtElement.textContent;
                let charIndex = currentText.length;
                const wipeInterval = setInterval(() => {
                    if (charIndex > 0) {
                        charIndex -= 3; // Remove 3 chars at a time for rapid wipe
                        thoughtElement.textContent = currentText.substring(0, Math.max(0, charIndex));
                    } else {
                        clearInterval(wipeInterval);
                    }
                }, 30);
            }

            // After wipe completes, show FIN
            setTimeout(() => {
                showFinOverlay();
            }, 2000);

            // Fade out hull breach overlay
            setTimeout(() => {
                overlay.classList.add('fade-out');
                if (explorePage) explorePage.classList.remove('hull-breach-wipe');
                if (thoughtElement) thoughtElement.classList.remove('hull-breach-wipe');
                setTimeout(() => {
                    overlay.remove();
                }, 1000);
            }, 3500);
        }

        // Oxygen Depletion: Slow fade to pulsing red, typing speed drops to zero
        function triggerOxygenDepletion() {
            console.log('OXYGEN DEPLETION TRIGGERED');
            // Don't stop cycling immediately - we'll slow it down gradually

            // Create oxygen depletion overlay
            const overlay = document.createElement('div');
            overlay.id = 'oxygenOverlay';
            overlay.className = 'oxygen-depletion-overlay';
            document.body.appendChild(overlay);
            overlay.classList.add('active');

            // Apply oxygen depletion effect to terminal
            const explorePage = document.querySelector('.explore-page');
            const thoughtElement = document.getElementById('currentThought');

            if (explorePage) explorePage.classList.add('oxygen-depletion');
            if (thoughtElement) thoughtElement.classList.add('oxygen-depletion');

            // Gradually slow down typing to simulate oxygen loss
            // Store original typing speed
            const originalTypeSpeedMin = timing.typeSpeedMin;
            const originalTypeSpeedMax = timing.typeSpeedMax;

            // Phase 1: Slight slowdown (0-2s)
            setTimeout(() => {
                timing.typeSpeedMin = originalTypeSpeedMin * 2;
                timing.typeSpeedMax = originalTypeSpeedMax * 2;
            }, 2000);

            // Phase 2: Major slowdown (2-4s)
            setTimeout(() => {
                timing.typeSpeedMin = originalTypeSpeedMin * 5;
                timing.typeSpeedMax = originalTypeSpeedMax * 5;
            }, 4000);

            // Phase 3: Near stop (4-6s)
            setTimeout(() => {
                timing.typeSpeedMin = originalTypeSpeedMin * 20;
                timing.typeSpeedMax = originalTypeSpeedMax * 20;
                stopCycling();
            }, 6000);

            // Show FIN after oxygen runs out
            setTimeout(() => {
                // Restore timing for future use
                timing.typeSpeedMin = originalTypeSpeedMin;
                timing.typeSpeedMax = originalTypeSpeedMax;
                showFinOverlay();
            }, 7000);

            // Fade out oxygen overlay
            setTimeout(() => {
                overlay.classList.add('fade-out');
                if (explorePage) explorePage.classList.remove('oxygen-depletion');
                if (thoughtElement) thoughtElement.classList.remove('oxygen-depletion');
                setTimeout(() => {
                    overlay.remove();
                }, 2000);
            }, 9000);
        }

        // Recursive Reality: Infinity mirror effect where terminal nests inside itself
        function triggerRecursiveReality() {
            console.log('RECURSIVE REALITY TRIGGERED');
            stopCycling();

            // Create recursive reality overlay
            const overlay = document.createElement('div');
            overlay.id = 'recursiveRealityOverlay';
            overlay.className = 'recursive-reality-overlay';
            document.body.appendChild(overlay);
            overlay.classList.add('active');

            // Get terminal elements
            const explorePage = document.querySelector('.explore-page');
            const terminalBody = document.getElementById('terminal-body');

            // Create nested mirror frames
            if (terminalBody) {
                // Create multiple nested layers
                for (let i = 1; i <= 5; i++) {
                    const mirrorFrame = document.createElement('div');
                    mirrorFrame.className = 'recursive-mirror-frame';
                    mirrorFrame.style.animationDelay = `${i * 0.2}s`;
                    mirrorFrame.style.setProperty('--depth', i);
                    overlay.appendChild(mirrorFrame);
                }
            }

            // Apply recursive effect to terminal
            if (explorePage) explorePage.classList.add('recursive-reality');
            if (terminalBody) terminalBody.classList.add('recursive-reality');

            // Add the Return to Main button for psychedelic end action (stays until refresh)
            setTimeout(() => {
                showPsychedelicReturnButton(overlay);
            }, 3500);
        }

        // Recursive Reality transition (without permanent state)
        function triggerRecursiveRealityTransition(callback, delay) {
            console.log('RECURSIVE REALITY TRANSITION TRIGGERED');

            // Create recursive reality overlay
            const overlay = document.createElement('div');
            overlay.id = 'recursiveRealityTransitionOverlay';
            overlay.className = 'recursive-reality-overlay';
            document.body.appendChild(overlay);
            overlay.classList.add('active');

            // Get terminal elements
            const explorePage = document.querySelector('.explore-page');
            const terminalBody = document.getElementById('terminal-body');

            // Create nested mirror frames
            for (let i = 1; i <= 5; i++) {
                const mirrorFrame = document.createElement('div');
                mirrorFrame.className = 'recursive-mirror-frame';
                mirrorFrame.style.animationDelay = `${i * 0.2}s`;
                mirrorFrame.style.setProperty('--depth', i);
                overlay.appendChild(mirrorFrame);
            }

            // Apply recursive effect
            if (explorePage) explorePage.classList.add('recursive-reality');
            if (terminalBody) terminalBody.classList.add('recursive-reality');

            // Execute callback after delay
            setTimeout(() => {
                // Clean up the transition
                overlay.classList.add('fade-out');
                if (explorePage) explorePage.classList.remove('recursive-reality');
                if (terminalBody) terminalBody.classList.remove('recursive-reality');

                setTimeout(() => {
                    overlay.remove();
                    unlockTerminal();
                    if (callback) callback();
                }, 500);
            }, delay);
        }

        // Quantum Leak: Rainbow liquid drip effect with kaleidoscopic filter
        function triggerQuantumLeak() {
            console.log('QUANTUM LEAK TRIGGERED');
            stopCycling();

            // Create quantum leak overlay with kaleidoscopic background
            const overlay = document.createElement('div');
            overlay.id = 'quantumLeakOverlay';
            overlay.className = 'quantum-leak-overlay';
            document.body.appendChild(overlay);
            overlay.classList.add('active');

            // Create rainbow drip elements
            for (let i = 0; i < 20; i++) {
                const drip = document.createElement('div');
                drip.className = 'quantum-drip';
                drip.style.left = `${Math.random() * 100}%`;
                drip.style.animationDelay = `${Math.random() * 2}s`;
                drip.style.animationDuration = `${2 + Math.random() * 2}s`;
                overlay.appendChild(drip);
            }

            // Get terminal elements
            const explorePage = document.querySelector('.explore-page');
            const terminalBody = document.getElementById('terminal-body');
            const thoughtElement = document.getElementById('currentThought');

            // Apply rainbow liquid drip effect to text
            if (explorePage) explorePage.classList.add('quantum-leak');
            if (terminalBody) terminalBody.classList.add('quantum-leak');
            if (thoughtElement) thoughtElement.classList.add('quantum-leak-text');

            // Apply kaleidoscopic filter to body
            document.body.classList.add('kaleidoscope-filter');

            // Add the Return to Main button for psychedelic end action (stays until refresh)
            setTimeout(() => {
                showPsychedelicReturnButton(overlay);
            }, 3000);
        }

        // Hypnotic Spiral (Twilight Zone): Disorienting spiral with text distortion and audio
        function triggerHypnoticSpiral() {
            console.log('HYPNOTIC SPIRAL TRIGGERED');
            stopCycling();

            // Create hypnotic spiral overlay
            const overlay = document.createElement('div');
            overlay.id = 'hypnoticSpiralOverlay';
            overlay.className = 'hypnotic-spiral-overlay';
            document.body.appendChild(overlay);
            overlay.classList.add('active');

            // Get terminal elements
            const explorePage = document.querySelector('.explore-page');
            const terminalBody = document.getElementById('terminal-body');
            const thoughtElement = document.getElementById('currentThought');

            // Apply hypnotic spiral text distortion effect
            if (explorePage) explorePage.classList.add('hypnotic-spiral-warp');
            if (terminalBody) terminalBody.classList.add('hypnotic-spiral-warp');
            if (thoughtElement) thoughtElement.classList.add('hypnotic-spiral-text');

            // Create and play spiral hum audio with increasing volume
            let spiralHum = null;
            if (!globalAudioMuted) {
                spiralHum = new Audio('assets/audio/spiral-hum.mp3');
                spiralHum.loop = true;
                spiralHum.volume = 0.1;
                spiralHum.play().catch(e => console.log('Spiral hum audio failed:', e));

                // Gradually increase volume over 5 seconds
                let volumeStep = 0;
                const volumeInterval = setInterval(() => {
                    volumeStep++;
                    if (spiralHum && volumeStep <= 10) {
                        spiralHum.volume = Math.min(0.1 + (volumeStep * 0.07), 0.8);
                    } else {
                        clearInterval(volumeInterval);
                    }
                }, 500);
            }

            // After 5 seconds, fade to black to signify crossing over into the next dimension
            setTimeout(() => {
                overlay.classList.add('fade-to-black');
                // Add the Return to Main button after fade to black
                setTimeout(() => {
                    showPsychedelicReturnButton(overlay);
                }, 1000);
            }, 5000);
        }

        // Quantum Leak transition (without permanent state)
        function triggerQuantumLeakTransition(callback, delay) {
            console.log('QUANTUM LEAK TRANSITION TRIGGERED');

            // Create quantum leak overlay
            const overlay = document.createElement('div');
            overlay.id = 'quantumLeakTransitionOverlay';
            overlay.className = 'quantum-leak-overlay';
            document.body.appendChild(overlay);
            overlay.classList.add('active');

            // Create rainbow drip elements
            for (let i = 0; i < 20; i++) {
                const drip = document.createElement('div');
                drip.className = 'quantum-drip';
                drip.style.left = `${Math.random() * 100}%`;
                drip.style.animationDelay = `${Math.random() * 2}s`;
                drip.style.animationDuration = `${2 + Math.random() * 2}s`;
                overlay.appendChild(drip);
            }

            // Get terminal elements
            const explorePage = document.querySelector('.explore-page');
            const terminalBody = document.getElementById('terminal-body');
            const thoughtElement = document.getElementById('currentThought');

            // Apply effects
            if (explorePage) explorePage.classList.add('quantum-leak');
            if (terminalBody) terminalBody.classList.add('quantum-leak');
            if (thoughtElement) thoughtElement.classList.add('quantum-leak-text');
            document.body.classList.add('kaleidoscope-filter');

            // Execute callback after delay
            setTimeout(() => {
                // Clean up the transition
                overlay.classList.add('fade-out');
                if (explorePage) explorePage.classList.remove('quantum-leak');
                if (terminalBody) terminalBody.classList.remove('quantum-leak');
                if (thoughtElement) thoughtElement.classList.remove('quantum-leak-text');
                document.body.classList.remove('kaleidoscope-filter');

                setTimeout(() => {
                    overlay.remove();
                    unlockTerminal();
                    if (callback) callback();
                }, 500);
            }, delay);
        }

        // Hypnotic Spiral (Twilight Zone) transition animation (without permanent state)
        function triggerHypnoticSpiralTransition(callback, delay) {
            console.log('HYPNOTIC SPIRAL TRANSITION TRIGGERED');

            // Create hypnotic spiral overlay
            const overlay = document.createElement('div');
            overlay.id = 'hypnoticSpiralTransitionOverlay';
            overlay.className = 'hypnotic-spiral-overlay';
            document.body.appendChild(overlay);
            overlay.classList.add('active');

            // Get terminal elements
            const explorePage = document.querySelector('.explore-page');
            const terminalBody = document.getElementById('terminal-body');
            const thoughtElement = document.getElementById('currentThought');

            // Apply hypnotic spiral text distortion effect
            if (explorePage) explorePage.classList.add('hypnotic-spiral-warp');
            if (terminalBody) terminalBody.classList.add('hypnotic-spiral-warp');
            if (thoughtElement) thoughtElement.classList.add('hypnotic-spiral-text');

            // Create and play spiral hum audio with increasing volume
            let spiralHum = null;
            if (!globalAudioMuted) {
                spiralHum = new Audio('assets/audio/spiral-hum.mp3');
                spiralHum.loop = true;
                spiralHum.volume = 0.1;
                spiralHum.play().catch(e => console.log('Spiral hum audio failed:', e));

                // Gradually increase volume over 5 seconds
                let volumeStep = 0;
                const volumeInterval = setInterval(() => {
                    volumeStep++;
                    if (spiralHum && volumeStep <= 10) {
                        spiralHum.volume = Math.min(0.1 + (volumeStep * 0.07), 0.8);
                    } else {
                        clearInterval(volumeInterval);
                    }
                }, 500);
            }

            // After 5 seconds, fade to black to signify crossing over
            setTimeout(() => {
                overlay.classList.add('fade-to-black');
            }, delay - 1000);

            // Execute callback after delay
            setTimeout(() => {
                // Clean up the transition
                overlay.classList.add('fade-out');
                if (explorePage) explorePage.classList.remove('hypnotic-spiral-warp');
                if (terminalBody) terminalBody.classList.remove('hypnotic-spiral-warp');
                if (thoughtElement) thoughtElement.classList.remove('hypnotic-spiral-text');

                // Fade out and stop audio
                if (spiralHum) {
                    const fadeOutAudio = setInterval(() => {
                        if (spiralHum.volume > 0.05) {
                            spiralHum.volume -= 0.05;
                        } else {
                            spiralHum.pause();
                            spiralHum = null;
                            clearInterval(fadeOutAudio);
                        }
                    }, 50);
                }

                setTimeout(() => {
                    overlay.remove();
                    unlockTerminal();
                    if (callback) callback();
                }, 500);
            }, delay);
        }

        // Show Return to Main button for psychedelic end actions
        function showPsychedelicReturnButton(parentOverlay) {
            // Create the return button container
            const returnContainer = document.createElement('div');
            returnContainer.className = 'psychedelic-return-container';

            const returnButton = document.createElement('button');
            returnButton.className = 'psychedelic-return-btn';
            returnButton.textContent = 'Return to Main';
            returnButton.onclick = function() {
                // Remove all psychedelic effects and reload
                window.location.reload();
            };

            returnContainer.appendChild(returnButton);
            parentOverlay.appendChild(returnContainer);

            // Fade in the button
            setTimeout(() => {
                returnContainer.classList.add('visible');
            }, 100);
        }

        function resetExplore() {
            state.isSelected = false;
            state.isUserTyping = false;
            state.isAnimating = false;
            state.waitingForChoice = false;
            // Clear any pending timeouts
            clearTimeout(state.idleTimeout);
            state.idleTimeout = null;
            // Stop and cleanup any playing audio
            if (state.currentAudio) {
                state.currentAudio.pause();
                state.currentAudio.currentTime = 0;
                state.currentAudio = null;
            }
            // Advance to the next thought in sequence (don't reset to 0)
            state.currentIndex = (state.currentIndex + 1) % thoughts.length;
            state.selectedIndex = null;
            state.currentText = '';
            state.targetText = '';

            // Reset thought element
            thoughtElement.classList.remove('selected', 'visible', 'fade-in', 'fade-out');
            thoughtElement.textContent = '';
            thoughtElement.removeAttribute('aria-pressed');

            // Hide cursor initially (will be shown after delay when cycling restarts)
            cursorElement.classList.remove('visible', 'cursor-stopped');

            // Reset choice buttons to initial state
            resetChoiceButtons();

            // Hide all New Question buttons
            hideAllNewQuestionButtons();

            // Hide all panels and reset their elements
            const panels = panelsContainer.querySelectorAll('.explore-panel');
            panels.forEach(panel => {
                panel.hidden = true;
                panel.classList.remove('visible');
                // Reset panel elements
                const textEl = panel.querySelector('.response-text');
                const actionsEl = panel.querySelector('.explore-panel-actions');
                const actionBtn = panel.querySelector('.explore-action-btn');

                if (textEl) textEl.textContent = '';
                if (actionsEl) actionsEl.classList.remove('visible');
                if (actionBtn) {
                    actionBtn.classList.remove('ready');
                    actionBtn.classList.add('hidden');
                    actionBtn.onclick = null;
                    const actionTextSpan = actionBtn.querySelector('.action-text');
                    if (actionTextSpan) actionTextSpan.textContent = '';
                }
            });
            panelsContainer.classList.remove('visible');

            // Clear input
            inputElement.value = '';
            inputElement.classList.remove('active');

            // Restart cycling
            startCycling();
        }

        // ========================================
        // Input Handling
        // ========================================
        function handleInputChange() {
            // Don't handle normal input changes when capturing name
            if (state.capturingName) {
                return;
            }

            const hasValue = inputElement.value.trim().length > 0;

            if (hasValue && !state.isUserTyping) {
                state.isUserTyping = true;
                stopCycling();
                thoughtElement.classList.remove('visible', 'fade-in', 'fade-out');
                thoughtElement.textContent = '';
                state.currentText = '';
                inputElement.classList.add('active');
            } else if (!hasValue && state.isUserTyping) {
                state.isUserTyping = false;
                inputElement.classList.remove('active');
                if (!state.isSelected) {
                    startCycling();
                }
            }
        }

        function handleInputKeydown(event) {
            if (event.key === 'Enter' && inputElement.value.trim()) {
                event.preventDefault();

                // Check if we're in name capture mode
                if (state.capturingName) {
                    const capturedName = inputElement.value.trim();

                    // Save to global state variable
                    state.userName = capturedName;

                    // Save to sessionStorage for replaceName function
                    sessionStorage.setItem('imaginecraft_user_name', capturedName);

                    // Display confirmation message
                    thoughtElement.textContent = `> Name captured: ${capturedName}`;

                    // Clear the input
                    inputElement.value = '';
                    inputElement.classList.remove('active');

                    // Reset capture mode after a brief delay
                    setTimeout(() => {
                        state.capturingName = false;
                        state.isSelected = false;
                        thoughtElement.classList.remove('selected');

                        // Resume cycling
                        startCycling();
                    }, 2000); // Show confirmation for 2 seconds
                } else {
                    // Normal custom thought selection
                    selectThought('custom');
                }
            }
        }

        // ========================================
        // Event Listeners
        // ========================================
        // Event delegation on parent container for thought clicks
        // This ensures clicks work even while text is being typed/re-rendered
        document.querySelector('.explore-thought-container').addEventListener('click', (event) => {
            const thought = event.target.closest('.explore-thought');
            if (thought && thought.classList.contains('visible') && !state.isSelected) {
                const index = parseInt(thought.dataset.index, 10);
                selectThought(index);
            }
        });

        // Event delegation for keyboard accessibility
        document.querySelector('.explore-thought-container').addEventListener('keydown', (event) => {
            const thought = event.target.closest('.explore-thought');
            if ((event.key === 'Enter' || event.key === ' ') &&
                thought && thought.classList.contains('visible') &&
                !state.isSelected) {
                event.preventDefault();
                const index = parseInt(thought.dataset.index, 10);
                selectThought(index);
            }
        });

        inputElement.addEventListener('input', handleInputChange);
        inputElement.addEventListener('keydown', handleInputKeydown);

        // Focus input when clicking anywhere in question area
        document.querySelector('.explore-question-area').addEventListener('click', (event) => {
            if (!event.target.closest('.explore-thought') && !state.isSelected) {
                inputElement.focus();
            }
        });

        // ========================================
        // Contact Modal (reused)
        // ========================================
        function openContactModal() {
            document.getElementById('contactModal').classList.add('active');
            document.body.style.overflow = 'hidden';
            document.getElementById('modalName').focus();
        }

        function closeContactModal() {
            document.getElementById('contactModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        function openNameModal() {
            document.getElementById('nameModal').classList.add('active');
            document.body.style.overflow = 'hidden';
            document.getElementById('userName').focus();
        }

        function closeNameModal() {
            document.getElementById('nameModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        function saveUserName(event) {
            event.preventDefault();
            const nameInput = document.getElementById('userName');
            const userName = nameInput.value.trim();

            if (userName) {
                sessionStorage.setItem('imaginecraft_user_name', userName);
                closeNameModal();
                nameInput.value = '';
            }
        }

        function closeModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeContactModal();
                closeNameModal();
            }
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                closeContactModal();
                closeNameModal();
                closeMultimediaModal();
            }
        });

        // ========================================
        // Earthquake Transition
        // ========================================
        function loadEarthquakeSetting() {
            const settings = getConfigSettings();
            return settings && settings.earthquakeEnabled !== undefined ? settings.earthquakeEnabled : true;
        }

        const earthquakeEnabled = loadEarthquakeSetting();

        // Apply --quake-time CSS variable
        // Urgent mood increases earthquake duration by 50% for more dramatic effect
        function applyQuakeTimeVariable() {
            let quakeTime = earthquakeDuration;

            // Urgent mood gets 50% longer and more intense earthquake
            if (systemMood === 'urgent') {
                quakeTime = quakeTime * 1.5;
            }

            document.documentElement.style.setProperty('--quake-time', `${quakeTime}s`);
            return quakeTime;
        }

        // Preload main.html content as background layer when earthquake is enabled
        // Superman Logic: Main site is ALWAYS rendered behind terminal
        function preloadMainSite() {
            const iframe = document.getElementById('mainSiteFrame');
            const background = document.getElementById('mainSiteBackground');

            if (earthquakeEnabled) {
                // Load main site immediately so it's ready behind the terminal
                if (iframe && !iframe.src) {
                    iframe.src = 'main.html';
                }
                // Mark as preloaded (main site is now rendering behind terminal)
                if (background) {
                    background.classList.add('preloaded');
                }
            }
        }

        // Execute earthquake transition - True Superman reveal style
        function triggerEarthquakeTransition(event) {
            if (!earthquakeEnabled) {
                // Normal navigation
                return true;
            }

            // Prevent default navigation
            event.preventDefault();

            const explorePage = document.querySelector('.explore-page');
            const terminalOverlay = document.getElementById('terminalOverlay');
            const background = document.getElementById('mainSiteBackground');
            const iframe = document.getElementById('mainSiteFrame');

            // Ensure iframe is loaded (should already be preloaded)
            if (!iframe.src) {
                iframe.src = 'main.html';
            }

            // The main site background is ALREADY visible (z-index: 1)
            // The terminal (explore-page) covers it (z-index: 2)
            // Mark background as active to ensure visibility
            if (background) {
                background.classList.add('active');
            }

            // Apply --quake-time variable before animation starts
            // Returns the actual quake time (may be modified for urgent mood)
            const actualQuakeTime = applyQuakeTimeVariable();
            const durationMs = actualQuakeTime * 1000;

            // Phase 1: Earthquake shake on the explore page (terminal layer only)
            // The main site stays static behind it
            explorePage.classList.add('earthquake-shake');

            // After shake completes, trigger the terminal split
            setTimeout(() => {
                // Phase 2: Activate terminal overlay (the shell that splits)
                // This overlay sits at z-index: 3, above the terminal content
                terminalOverlay.classList.add('active');

                // Hide the explore page content so only the overlay shows
                explorePage.style.visibility = 'hidden';

                // Small delay then crack/split the terminal shell
                setTimeout(() => {
                    terminalOverlay.classList.add('splitting');

                    // Phase 3: After split animation (0.8s), navigate to main.html
                    // The main site is already visible through the cracks
                    setTimeout(() => {
                        window.location.href = 'main.html';
                    }, 800);
                }, 50);
            }, durationMs);

            return false;
        }

        // Attach earthquake transition to all Main Site links
        function attachEarthquakeHandlers() {
            // Get all "Enter Main Site" links
            const mainSiteLinks = document.querySelectorAll('.explore-link');
            mainSiteLinks.forEach(link => {
                link.addEventListener('click', triggerEarthquakeTransition);
            });
        }

        // ========================================
        // Boot Sequence Animation
        // ========================================
        function runBootSequence(callback) {
            console.log('runBootSequence started');

            try {
                const overlay = document.getElementById('bootSequenceOverlay');
                const diagnostics = document.getElementById('bootDiagnostics');
                const explorePage = document.querySelector('.explore-page');

                if (!overlay) {
                    console.warn('Boot overlay not found, calling callback');
                    if (callback) callback();
                    return;
                }

                console.log('Boot overlay found, proceeding with sequence');

                // CRITICAL: Ensure overlay is visible with proper styling
                overlay.style.display = 'flex';
                overlay.style.opacity = '1';
                overlay.style.visibility = 'visible';
                overlay.style.backgroundColor = '#000';
                overlay.classList.remove('hidden', 'removed');

                // Apply mood-based styling to boot overlay
                if (systemMood === 'urgent') {
                    overlay.style.setProperty('--boot-text-color', '#ff3434');
                    overlay.style.setProperty('--boot-text-shadow', '0 0 8px rgba(255, 52, 52, 0.6)');
                } else {
                    overlay.style.setProperty('--boot-text-color', '#00ff00');
                    overlay.style.setProperty('--boot-text-shadow', '0 0 8px rgba(0, 255, 0, 0.6)');
                }

                // Hide main content during boot
                if (explorePage) {
                    explorePage.classList.add('boot-hidden');
                }

                // 8-second fallback timeout - ensure overlay fades even if script fails
                let hasCompleted = false;
                const fallbackTimeout = setTimeout(() => {
                    if (!hasCompleted) {
                        console.warn('Boot sequence fallback timeout triggered');
                        finishBootSequence();
                    }
                }, 8000);

                // Load boot script from Firebase
                const bootScript = loadBootScript();
                const bootScriptLines = bootScript.split('\n').filter(line => line.trim() !== '');
                console.log('Boot script lines:', bootScriptLines.length);

                // Get fast typing speed from admin settings
                const settings = getConfigSettings();
                const baseSpeed = settings && settings.typingSpeed ? settings.typingSpeed : 150;
                // Fast typing: use 20-50ms range (similar to "urgent" mode)
                const fastTypeMin = 20;
                const fastTypeMax = 50;

                // Clear existing content and create container for typed output
                diagnostics.innerHTML = '';

                let currentLineIndex = 0;
                let currentCharIndex = 0;
                let currentLineElement = null;

                // Type out boot script character by character
                function typeNextCharacter() {
                    // Check if we're done with all lines
                    if (currentLineIndex >= bootScriptLines.length) {
                        clearTimeout(fallbackTimeout);
                        // Small delay after final character before fading overlay
                        setTimeout(finishBootSequence, 200);
                        return;
                    }

                    // Get current line text
                    const currentLineText = bootScriptLines[currentLineIndex];

                    // Create new line element if needed
                    if (!currentLineElement) {
                        currentLineElement = document.createElement('div');
                        currentLineElement.className = 'boot-line';
                        currentLineElement.textContent = '';
                        diagnostics.appendChild(currentLineElement);
                    }

                    // Type next character
                    if (currentCharIndex < currentLineText.length) {
                        currentLineElement.textContent += currentLineText[currentCharIndex];
                        currentCharIndex++;

                        // Random delay for typing speed variation
                        const delay = Math.floor(Math.random() * (fastTypeMax - fastTypeMin + 1)) + fastTypeMin;
                        setTimeout(typeNextCharacter, delay);
                    } else {
                        // Current line complete, move to next line
                        currentLineIndex++;
                        currentCharIndex = 0;
                        currentLineElement = null;

                        // Small delay between lines (100-150ms)
                        const lineDelay = Math.floor(Math.random() * 50) + 100;
                        setTimeout(typeNextCharacter, lineDelay);
                    }
                }

                // Finish boot sequence and reveal main terminal
                function finishBootSequence() {
                    // Prevent double initialization
                    if (hasCompleted) {
                        console.log('finishBootSequence already called, skipping');
                        return;
                    }
                    hasCompleted = true;
                    console.log('Finishing boot sequence - fading out overlay');
                    // Fade out the overlay using style.opacity for reliable animation
                    overlay.style.opacity = '0';

                    // Reveal the background image behind the curtains
                    const openingBackground = document.getElementById('openingBackground');
                    if (openingBackground) {
                        openingBackground.classList.add('visible');
                    }

                    // Show main content
                    if (explorePage) {
                        explorePage.classList.remove('boot-hidden');
                    }

                    // After fade transition completes (300ms), remove overlay and start terminal
                    setTimeout(() => {
                        console.log('Removing boot overlay from DOM');
                        // Remove the overlay element completely
                        if (overlay && overlay.parentNode) {
                            overlay.parentNode.removeChild(overlay);
                        }

                        // Mark as played for this session
                        markBootSequencePlayed();

                        console.log('Boot sequence complete, calling terminal initialization');
                        // NOW trigger the callback (start hero text and terminal)
                        // This ensures hero text only appears AFTER overlay has cleared
                        try {
                            if (callback) callback();
                        } catch (error) {
                            // Handle any errors from callback execution (e.g., message channel issues)
                            console.warn('Error during terminal initialization (continuing locally):', error);
                        }
                    }, 300);
                }

                // Start typing the boot sequence
                typeNextCharacter();
            } catch (error) {
                // Handle any synchronous errors in boot sequence
                console.error('Boot sequence error:', error);
                // Ensure callback is still called to prevent hang
                if (callback) {
                    try {
                        callback();
                    } catch (callbackError) {
                        console.warn('Error during callback execution:', callbackError);
                    }
                }
            }
        }

        function skipBootSequence(callback) {
            const overlay = document.getElementById('bootSequenceOverlay');
            const explorePage = document.querySelector('.explore-page');

            if (overlay) {
                overlay.style.opacity = '0';

                // Reveal the background image behind the curtains
                const openingBackground = document.getElementById('openingBackground');
                if (openingBackground) {
                    openingBackground.classList.add('visible');
                }

                setTimeout(() => {
                    if (overlay && overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }

                    // Mark as skipped/played for this session
                    markBootSequencePlayed();

                    // Call the callback after overlay is fully removed
                    if (callback) {
                        try {
                            callback();
                        } catch (error) {
                            console.warn('Error during callback execution:', error);
                        }
                    }
                }, 300);
            } else {
                // If no overlay, call callback immediately
                if (callback) {
                    try {
                        callback();
                    } catch (error) {
                        console.warn('Error during callback execution:', error);
                    }
                }
            }
            if (explorePage) {
                explorePage.classList.remove('boot-hidden');
            }
        }

        // ========================================
        // Initialize
        // ========================================
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOMContentLoaded - Starting initialization');

            // Wait for remote config to load before initializing (with timeout)
            try {
                await configPromise;
                console.log('Config loaded successfully');
            } catch (error) {
                console.error('Config loading error:', error);
                // Continue anyway with defaults
            }

            // Initialize all config-dependent values now that config is loaded
            initializeConfigDependentValues();

            // Hide boot overlay immediately if boot sequence is disabled
            if (!bootSequenceEnabled) {
                const bootOverlay = document.getElementById('bootSequenceOverlay');
                if (bootOverlay) {
                    bootOverlay.style.display = 'none';
                    console.log('Boot sequence disabled - hiding overlay immediately');
                }

                // Reveal the background image immediately
                const openingBackground = document.getElementById('openingBackground');
                if (openingBackground) {
                    openingBackground.classList.add('visible');
                    console.log('Boot sequence disabled - revealing mystery image immediately');
                }
            }

            // Wrap content initialization in try-catch to prevent errors from blocking the UI
            try {
                initializeContentData();
            } catch (error) {
                console.error('Error initializing content data:', error);
                // Set emergency fallback data
                allThoughts = ['System Error'];
                allResponses = ['An error occurred during initialization. Please refresh the page.'];
                heroText = 'SYSTEM ERROR';
                actions = [{ type: 'none', url: '', logo: '', linkText: 'Click here' }];
                activeStates = [true];
                allYesRedirectIndices = [''];
                allNoRedirectIndices = [''];
                randomizeEnabled = false;
                thoughts = allThoughts;
                responses = allResponses;
            }

            initializeSettings();

            // Initialize layered audio system
            initializeGlobalAmbientAudio();
            // Add first-click listeners to start ambient audio
            document.addEventListener('click', startAmbientAudioOnFirstClick);
            document.addEventListener('keydown', startAmbientAudioOnFirstClick);

            // Load and prepare background image
            loadOpeningBackgroundImage();

            // Initialize cinematic overlay images
            initializeCinematicOverlays();

            // Apply system mood CSS class to explore page
            const explorePage = document.querySelector('.explore-page');
            if (explorePage && systemMood !== 'stable') {
                explorePage.classList.add(`mood-${systemMood}`);
            }

            // Clear hero text initially (will be typed out)
            if (heroElement && heroText) {
                heroElement.textContent = '';
                heroElement.dataset.fullText = heroText;
            }

            // Apply reduced motion adjustments
            if (prefersReducedMotion) {
                timing.fadeIn = 0;
                timing.fadeOut = 0;
                timing.linger = 5000;
            }

            // Apply --quake-time CSS variable from localStorage on page load
            applyQuakeTimeVariable();

            // Initialize earthquake transition
            attachEarthquakeHandlers();
            preloadMainSite();

            // Attach choice button event listeners
            if (choiceBtnYes) {
                choiceBtnYes.addEventListener('click', handleChoiceYes);
            }
            if (choiceBtnNo) {
                choiceBtnNo.addEventListener('click', handleChoiceNo);
            }

            // Attach New Question button event listeners
            const newQuestionBtnChoice = document.getElementById('newQuestionBtnChoice');
            if (newQuestionBtnChoice) {
                newQuestionBtnChoice.addEventListener('click', resetExplore);
            }

            // Attach event listeners to all panel New Question buttons
            for (let i = 0; i < 5; i++) {
                const btn = document.getElementById('newQuestionBtn' + i);
                if (btn) {
                    btn.addEventListener('click', resetExplore);
                }
            }

            // Type out hero text character by character
            function typeHeroText(callback) {
                const originalText = heroElement.dataset.fullText || heroText;
                const fullText = replaceName(originalText);
                let index = 0;

                function typeNextChar() {
                    if (index <= fullText.length) {
                        heroElement.textContent = fullText.substring(0, index);
                        index++;

                        // Calculate delay for each character
                        let delay = prefersReducedMotion ? 0 : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                        const lastChar = fullText.charAt(index - 1);
                        if (isPunctuation(lastChar)) {
                            delay = timing.punctuationPause;
                        }

                        state.animationTimeout = setTimeout(typeNextChar, delay);
                    } else {
                        // Hero text finished typing
                        state.heroTyped = true;
                        if (callback) callback();
                    }
                }

                typeNextChar();
            }

            // Function to start the main terminal experience
            function initializeTerminal() {
                // Type hero text first, then pause, then start cycling thoughts
                typeHeroText(() => {
                    // 1.5 second pause with blinking cursor after hero finishes
                    cursorElement.classList.add('visible');

                    setTimeout(() => {
                        // Now start cycling thoughts
                        startCycling();
                        // Start inactivity tracking for intermission overlay
                        trackUserActivity();
                    }, 1500);
                });
            }

            // Function to handle curtain rise animation
            function raiseCurtain() {
                const curtainElement = document.getElementById('theaterCurtain');
                if (!curtainElement) {
                    return;
                }

                // Apply curtain duration as CSS variable
                document.documentElement.style.setProperty('--curtain-duration', curtainDuration + 's');

                // Start curtain rise animation
                curtainElement.classList.add('curtain-rising');

                // After curtain has fully risen, hide it
                setTimeout(() => {
                    curtainElement.classList.add('curtain-hidden');
                }, curtainDuration * 1000);
            }

            // ========================================
            // Opening Credits Sequence
            // ========================================

            // Play theatrical opening credits after user clicks Proceed
            function playOpeningCredits(userName, isAudioEnabled, callback) {
                const openingCredits = document.getElementById('openingCredits');
                const creditsBackground = document.getElementById('openingCreditsBackground');
                const creditsLine1 = document.getElementById('creditsLine1');
                const creditsLine2 = document.getElementById('creditsLine2');
                const creditsName = document.getElementById('creditsName');

                if (!openingCredits) {
                    console.warn('Opening credits element not found');
                    if (callback) callback();
                    return;
                }

                // Set the user's name in the credits
                const displayName = userName || 'YOU';
                creditsName.textContent = displayName;

                // Set MST3K poster as low-opacity background if available
                const mst3kUrl = loadMst3kOverlayURL();
                if (mst3kUrl && creditsBackground) {
                    creditsBackground.style.backgroundImage = `url('${mst3kUrl}')`;
                }

                // Show the credits overlay
                openingCredits.style.display = 'flex';

                // Timeline:
                // 0s: Fade to black (1s)
                // 1s: Show "A PRODUCTION BY THE GHOST" with fade in
                // 3s: Fade out first line, fade in "STARRING: <<name>>" + play audio
                // 6s: Fade out everything, trigger callback

                // Step 1: Fade in the black overlay (0-1s)
                setTimeout(() => {
                    openingCredits.classList.add('visible');
                }, 50);

                // Step 2: Show first credit line at 1s
                setTimeout(() => {
                    creditsLine1.classList.add('visible');
                }, 1000);

                // Step 3: At 3s - fade out first line, prepare for second
                setTimeout(() => {
                    creditsLine1.classList.remove('visible');
                    creditsLine1.classList.add('fading-out');
                }, 3000);

                // Step 4: At 3.8s - show second line with name + play audio
                setTimeout(() => {
                    creditsLine1.style.display = 'none';
                    creditsLine2.style.display = 'block';
                    creditsLine2.classList.add('visible');

                    // Play cinematic whoosh audio if enabled
                    if (isAudioEnabled) {
                        playCinematicWhoosh();
                    }
                }, 3800);

                // Step 5: At 5.5s - start fading out
                setTimeout(() => {
                    creditsLine2.classList.remove('visible');
                    creditsLine2.classList.add('fading-out');
                }, 5500);

                // Step 6: At 6s - fade out entire overlay and proceed
                setTimeout(() => {
                    openingCredits.classList.remove('visible');
                    openingCredits.classList.add('fading-out');

                    // After fade out completes, hide and proceed
                    setTimeout(() => {
                        openingCredits.style.display = 'none';
                        // Reset classes for potential replay
                        openingCredits.classList.remove('fading-out');
                        creditsLine1.classList.remove('visible', 'fading-out');
                        creditsLine2.classList.remove('visible', 'fading-out');
                        creditsLine1.style.display = 'block';
                        creditsLine2.style.display = 'none';

                        if (callback) callback();
                    }, 1000);
                }, 6000);
            }

            // Play cinematic whoosh/title theme audio
            function playCinematicWhoosh() {
                try {
                    // Create a short cinematic whoosh sound using Web Audio API
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Create oscillator for the whoosh base
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    // Create filter for sweep effect
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(100, audioContext.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(2000, audioContext.currentTime + 0.3);
                    filter.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.8);

                    // Configure oscillator
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(80, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.2);
                    oscillator.frequency.exponentialRampToValueAtTime(60, audioContext.currentTime + 0.8);

                    // Configure gain envelope
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.1);
                    gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.4);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.2);

                    // Connect nodes
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    // Play the sound
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 1.2);

                    // Add a second layer - higher pitched shimmer
                    const shimmer = audioContext.createOscillator();
                    const shimmerGain = audioContext.createGain();

                    shimmer.type = 'sine';
                    shimmer.frequency.setValueAtTime(800, audioContext.currentTime);
                    shimmer.frequency.exponentialRampToValueAtTime(1200, audioContext.currentTime + 0.2);
                    shimmer.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 1.0);

                    shimmerGain.gain.setValueAtTime(0, audioContext.currentTime);
                    shimmerGain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.15);
                    shimmerGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.0);

                    shimmer.connect(shimmerGain);
                    shimmerGain.connect(audioContext.destination);

                    shimmer.start(audioContext.currentTime);
                    shimmer.stop(audioContext.currentTime + 1.0);

                    console.log('Cinematic whoosh audio played');
                } catch (error) {
                    console.warn('Could not play cinematic whoosh audio:', error);
                }
            }

            // ========================================
            // Entry Page (Chapter 0) Logic
            // ========================================

            // Initialize and show Entry Page
            function showEntryPage(callback) {
                const entryPage = document.getElementById('entryPage');
                const entryNameInput = document.getElementById('entryNameInput');
                const audioYesBtn = document.getElementById('audioYesBtn');
                const audioNoBtn = document.getElementById('audioNoBtn');
                const scaryYesBtn = document.getElementById('scaryYesBtn');
                const scaryNoBtn = document.getElementById('scaryNoBtn');
                const proceedBtn = document.getElementById('entryProceedBtn');

                if (!entryPage) {
                    // If entry page doesn't exist, proceed immediately
                    if (callback) callback();
                    return;
                }

                // Show entry page
                entryPage.style.display = 'flex';

                // Pre-fill name if returning user
                const savedName = localStorage.getItem('userName');
                if (savedName) {
                    entryNameInput.value = savedName;
                    entryNameInput.placeholder = 'Welcome back!';
                    // Also populate sessionStorage for {{name}} placeholder replacement
                    sessionStorage.setItem('imaginecraft_user_name', savedName);
                }

                // Audio preference toggle
                let audioEnabled = true; // Default to yes

                audioYesBtn.addEventListener('click', function() {
                    audioEnabled = true;
                    audioYesBtn.classList.add('active');
                    audioNoBtn.classList.remove('active');
                });

                audioNoBtn.addEventListener('click', function() {
                    audioEnabled = false;
                    audioNoBtn.classList.add('active');
                    audioYesBtn.classList.remove('active');
                });

                // Scary stories prank - No button PERMANENTLY transforms to Yes on hover
                // User must click a "Yes" to proceed - both buttons are now "Yes"
                let scaryNoPranked = false;

                scaryNoBtn.addEventListener('mouseenter', function() {
                    if (!scaryNoPranked) {
                        scaryNoPranked = true;
                        this.textContent = 'YES';
                        this.classList.add('pranked');
                        // Add a brief glitch animation for dramatic effect
                        this.classList.add('prank-glitch');
                        setTimeout(() => this.classList.remove('prank-glitch'), 300);
                    }
                });

                // Also handle touch devices - instant transform on touch
                scaryNoBtn.addEventListener('touchstart', function(e) {
                    if (!scaryNoPranked) {
                        e.preventDefault();
                        scaryNoPranked = true;
                        this.textContent = 'YES';
                        this.classList.add('pranked');
                        this.classList.add('prank-glitch');
                        setTimeout(() => this.classList.remove('prank-glitch'), 300);
                    }
                });

                // Both scary buttons now function as "Yes" - clicking either proceeds
                scaryYesBtn.addEventListener('click', function() {
                    this.classList.add('active');
                    scaryNoBtn.classList.remove('active');
                });

                scaryNoBtn.addEventListener('click', function() {
                    // Only register click after transformation
                    if (scaryNoPranked) {
                        this.classList.add('active');
                        scaryYesBtn.classList.remove('active');
                    }
                });

                // Proceed button handler
                proceedBtn.addEventListener('click', function() {
                    // Save name to localStorage AND sessionStorage for replaceName function
                    const userName = entryNameInput.value.trim();
                    if (userName) {
                        localStorage.setItem('userName', userName);
                        // Also save to sessionStorage for {{name}} placeholder replacement
                        sessionStorage.setItem('imaginecraft_user_name', userName);
                    }

                    // Set global audio mute based on preference
                    globalAudioMuted = !audioEnabled;
                    console.log('Audio preference set:', audioEnabled ? 'enabled' : 'muted');

                    // Fade out entry page
                    entryPage.classList.add('fading-out');

                    // After fade out, play opening credits sequence
                    setTimeout(() => {
                        entryPage.style.display = 'none';

                        // Play theatrical opening credits before proceeding
                        playOpeningCredits(userName, audioEnabled, function() {
                            // After credits complete, proceed to the terminal
                            if (callback) callback();
                        });
                    }, 800); // Match CSS transition duration
                });
            }

            // Function to set up splash screen interaction (already visible behind curtain)
            function setupSplashScreen(callback) {
                const splashScreen = document.getElementById('splashScreen');

                if (!splashScreen) {
                    // If splash screen doesn't exist, proceed immediately
                    if (callback) callback();
                    return;
                }

                // Click handler to fade out splash and proceed
                function handleSplashClick() {

                    // Start fade out animation
                    splashScreen.classList.add('fading-out');

                    // Remove click listener to prevent multiple triggers
                    splashScreen.removeEventListener('click', handleSplashClick);

                    // After fade out completes, proceed to callback
                    setTimeout(() => {
                        // Hide splash screen completely
                        splashScreen.style.display = 'none';
                        if (callback) callback();
                    }, 800); // Match CSS transition duration
                }

                // Add click event listener
                splashScreen.addEventListener('click', handleSplashClick);
            }

            // Function to proceed with boot sequence or terminal
            function proceedAfterSplash() {
                console.log('proceedAfterSplash called');
                // Check if boot sequence should run
                const shouldRunBootSequence = bootSequenceEnabled &&
                                              !hasBootSequencePlayedThisSession() &&
                                              !prefersReducedMotion;

                console.log('Boot sequence check:', {
                    bootSequenceEnabled,
                    hasPlayed: hasBootSequencePlayedThisSession(),
                    prefersReducedMotion,
                    shouldRunBootSequence
                });

                if (shouldRunBootSequence) {
                    console.log('Starting boot sequence...');
                    // Run boot sequence with error handling for message channel issues
                    try {
                        runBootSequence(initializeTerminal);
                    } catch (error) {
                        // If message channel closes or any error occurs, continue locally
                        console.warn('Boot sequence error (continuing locally):', error);
                        skipBootSequence(initializeTerminal);
                    }
                } else {
                    // Skip boot sequence, initialize terminal after overlay fades
                    skipBootSequence(initializeTerminal);
                }
            }

            // Set up splash screen interaction (already visible behind curtain)
            // Set up splash screen -> Entry Page -> Boot Sequence/Terminal flow
            setupSplashScreen(function() {
                showEntryPage(proceedAfterSplash);
            });

            // Emergency fail-safe: Force curtain to rise after 5 seconds if initialization hangs
            let curtainRaised = false;
            const emergencyCurtainTimer = setTimeout(() => {
                if (!curtainRaised) {
                    console.warn('Emergency curtain trigger activated after 5 seconds');
                    raiseCurtain();
                    curtainRaised = true;
                }
            }, 5000);

            // Raise curtain to reveal the splash screen
            try {
                raiseCurtain();
                curtainRaised = true;
                clearTimeout(emergencyCurtainTimer);
            } catch (error) {
                console.error('Error raising curtain:', error);
                // Emergency timer will handle it
            }

        });
    </script>

    <!-- Film Grain Overlay -->
    <div id="filmGrain" class="film-grain-overlay"></div>

    <!-- Opening Sequence Background Image (behind curtains, revealed after boot) -->
    <div id="openingBackground" class="opening-background">
        <img id="openingBackgroundImage" class="opening-background-image" alt="Background">
    </div>

    <!-- Splash Screen (revealed after curtain rises) -->
    <div id="splashScreen" class="splash-screen">
        <div class="splash-image-container">
            <img src="assets/mysteryimage.png" alt="Welcome" class="splash-image">
        </div>
    </div>

    <!-- Entry Page (Chapter 0) - Appears after splash, before terminal -->
    <div id="entryPage" class="entry-page" style="display: none;">
        <div class="entry-container">
            <h1 class="entry-title">CHAPTER 0</h1>
            <p class="entry-subtitle">SYSTEM INITIALIZATION</p>

            <!-- Name Capture -->
            <div class="entry-section">
                <label class="entry-label" for="entryNameInput">ENTER YOUR NAME</label>
                <input type="text" id="entryNameInput" class="entry-input" placeholder="_" autocomplete="off" spellcheck="false">
            </div>

            <!-- Audio Preference -->
            <div class="entry-section">
                <label class="entry-label">ENABLE SYSTEM AUDIO?</label>
                <div class="entry-toggle-container">
                    <button type="button" class="entry-toggle-btn active" id="audioYesBtn" data-audio="yes">YES</button>
                    <button type="button" class="entry-toggle-btn" id="audioNoBtn" data-audio="no">NO</button>
                </div>
            </div>

            <!-- Scary Stories Prank -->
            <div class="entry-section">
                <label class="entry-label">DO YOU LIKE SCARY STORIES?</label>
                <div class="entry-toggle-container">
                    <button type="button" class="entry-scary-btn" id="scaryYesBtn">YES</button>
                    <button type="button" class="entry-scary-btn entry-scary-no" id="scaryNoBtn">NO</button>
                </div>
            </div>

            <!-- Proceed Button -->
            <button type="button" class="entry-proceed-btn" id="entryProceedBtn">PROCEED</button>
        </div>
    </div>

    <!-- Opening Credits Sequence - Theatrical intro after Proceed -->
    <div id="openingCredits" class="opening-credits" style="display: none;">
        <div id="openingCreditsBackground" class="opening-credits-background"></div>
        <div class="opening-credits-content">
            <p id="creditsLine1" class="credits-line credits-production">A PRODUCTION BY THE GHOST</p>
            <p id="creditsLine2" class="credits-line credits-starring" style="display: none;">STARRING: <span id="creditsName"></span></p>
        </div>
    </div>

    <!-- Theater Curtain Overlay -->
    <div id="theaterCurtain" class="theater-curtain">
        <div class="curtain-left"></div>
        <div class="curtain-right"></div>
    </div>

    <!-- Cinematic State Overlays -->
    <div id="intermissionOverlay" class="cinematic-overlay" style="display: none;">
        <img id="intermissionImage" src="" alt="Intermission" class="cinematic-image">
    </div>
    <div id="techDifficultyOverlay" class="cinematic-overlay" style="display: none;">
        <img id="techDifficultyImage" src="" alt="Technical Difficulties" class="cinematic-image">
    </div>
    <div id="finOverlay" class="cinematic-overlay" style="display: none;">
        <img id="finImage" src="" alt="Fin" class="cinematic-image">
    </div>

    <!-- Theater Frame Overlay (permanent curtain frame) -->
    <img id="theater-frame-overlay" src="" alt="Theater Frame Overlay" style="display: none;">

    <!-- MST3K Overlay (permanent theater silhouettes) -->
    <img id="global-mst3k-overlay" src="" alt="MST3K Theater Overlay" style="display: none;">

</body>
</html>
