<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ImagineCraft Studios</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=VT323&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css?v=1.0.1">
</head>
<body>
    <!-- Boot Sequence Overlay -->
    <div id="bootSequenceOverlay" class="boot-sequence-overlay">
        <div class="boot-diagnostics" id="bootDiagnostics">
            <div class="boot-line" data-line="0">CORE_INIT: <span class="status">OK</span></div>
            <div class="boot-line" data-line="1">MEM_LOAD: <span class="status">1024KB</span></div>
            <div class="boot-line" data-line="2">DRV_MOUNT: <span class="status">/assets</span></div>
            <div class="boot-line" data-line="3">NET_STACK: <span class="status">READY</span></div>
            <div class="boot-line" data-line="4">SYS_CHECK: <span class="status">COMPLETE</span></div>
        </div>
        <div class="boot-progress-container" id="bootProgressContainer">
            <div class="boot-progress-bar" id="bootProgressBar">[--------------------] 0%</div>
        </div>
    </div>

    <main class="explore-page" role="main">
        <div class="explore-container">
            <!-- Question and cursor area -->
            <div class="explore-question-area">
                <h1 class="explore-question" id="exploreQuestion">Why are you here?</h1>
                <!-- Cursor and thoughts inline together -->
                <div class="explore-cursor-line">
                    <div class="explore-thought-container" aria-live="polite" aria-atomic="true">
                        <button
                            class="explore-thought"
                            id="currentThought"
                            tabindex="0"
                            aria-label="Click to select this thought"
                        ></button>
                    </div><span class="explore-cursor" id="exploreCursor" aria-hidden="true">â–ˆ</span>
                    <!-- Optional: text input appears here when user starts typing -->
                    <input
                        type="text"
                        class="explore-input"
                        id="exploreInput"
                        placeholder=""
                        aria-label="Type your own response"
                        autocomplete="off"
                    >
                </div>
            </div>

            <!-- Response panels (hidden by default) -->
            <div class="explore-panels" id="explorePanels" aria-live="polite">
                <!-- Panel 1: I have ideas -->
                <article class="explore-panel" data-thought="0" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtn0"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtn0"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtn0"><span class="action-text"></span></a>
                    </div>
                </article>

                <!-- Panel 2: I don't know where to start -->
                <article class="explore-panel" data-thought="1" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtn1"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtn1"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtn1"><span class="action-text"></span></a>
                    </div>
                </article>

                <!-- Panel 3: Our tools don't fit us -->
                <article class="explore-panel" data-thought="2" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtn2"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtn2"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtn2"><span class="action-text"></span></a>
                    </div>
                </article>

                <!-- Panel 4: I want software that matches how we work -->
                <article class="explore-panel" data-thought="3" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtn3"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtn3"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtn3"><span class="action-text"></span></a>
                    </div>
                </article>

                <!-- Panel 5: Help us think this through -->
                <article class="explore-panel" data-thought="4" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtn4"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtn4"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtn4"><span class="action-text"></span></a>
                    </div>
                </article>

                <!-- Panel 6: Who are you? -->
                <article class="explore-panel" data-thought="5" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtn5"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtn5"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtn5"><span class="action-text"></span></a>
                    </div>
                </article>

                <!-- Panel 7: I need something custom -->
                <article class="explore-panel" data-thought="6" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtn6"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtn6"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtn6"><span class="action-text"></span></a>
                    </div>
                </article>

                <!-- Panel 8: Our budget is limited -->
                <article class="explore-panel" data-thought="7" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtn7"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtn7"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtn7"><span class="action-text"></span></a>
                    </div>
                </article>

                <!-- Panel 9: We've tried this before -->
                <article class="explore-panel" data-thought="8" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtn8"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtn8"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtn8"><span class="action-text"></span></a>
                    </div>
                </article>

                <!-- Panel 10: How long will it take? -->
                <article class="explore-panel" data-thought="9" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtn9"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtn9"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtn9"><span class="action-text"></span></a>
                    </div>
                </article>

                <!-- Panel 11: Can you work with our team? -->
                <article class="explore-panel" data-thought="10" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtn10"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtn10"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtn10"><span class="action-text"></span></a>
                    </div>
                </article>

                <!-- Panel 12: What makes you different? -->
                <article class="explore-panel" data-thought="11" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtn11"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtn11"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtn11"><span class="action-text"></span></a>
                    </div>
                </article>

                <!-- Generic panel for typed input -->
                <article class="explore-panel" data-thought="custom" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-reset" id="resetBtnCustom"><span class="action-text"></span></button>
                        <button class="explore-action-link hidden" id="actionBtnCustom"><span class="action-text"></span></button>
                        <a href="main.html" class="explore-link" id="enterBtnCustom"><span class="action-text"></span></a>
                    </div>
                </article>
            </div>

        </div>
    </main>

    <!-- Multimedia Modal (for video/image actions) -->
    <div class="modal-overlay" id="multimediaModal" onclick="closeMultimediaModalOnOverlay(event)">
        <div class="modal-content multimedia-modal-content" role="dialog" aria-modal="true" aria-labelledby="multimediaTitle">
            <button class="modal-close" onclick="closeMultimediaModal()" aria-label="Close modal">&times;</button>
            <div id="multimediaContent" class="multimedia-container">
                <!-- Video iframe or image will be inserted here -->
            </div>
        </div>
    </div>

    <!-- The Matrix Canvas (for falling 0s and 1s animation) -->
    <canvas id="matrixCanvas" class="matrix-canvas"></canvas>

    <!-- ASCII Logo Container (for permanent terminal logos) -->
    <div id="asciiLogoContainer" class="ascii-logo-container"></div>

    <!-- Main Site Background Layer (z-index: 1) - Always loaded behind terminal -->
    <div id="mainSiteBackground" class="main-site-background">
        <iframe id="mainSiteFrame" src="" title="Main Site"></iframe>
    </div>

    <!-- Terminal Overlay Shell (z-index: 2) - Splits during earthquake transition -->
    <div id="terminalOverlay" class="terminal-overlay">
        <div class="terminal-half terminal-half-left"></div>
        <div class="terminal-half terminal-half-right"></div>
    </div>

    <!-- Contact Modal (reused from main site) -->
    <div class="modal-overlay" id="contactModal" onclick="closeModalOnOverlay(event)">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
            <button class="modal-close" onclick="closeContactModal()" aria-label="Close modal">&times;</button>
            <h2 id="modalTitle">Get in Touch</h2>
            <form class="modal-form" action="mailto:hello@imaginecraft.studio" method="GET" enctype="text/plain">
                <div class="form-group">
                    <label for="modalName">Name</label>
                    <input type="text" id="modalName" name="name" placeholder="Your name" required>
                </div>
                <div class="form-group">
                    <label for="modalEmail">Email</label>
                    <input type="email" id="modalEmail" name="email" placeholder="you@example.com" required>
                </div>
                <div class="form-group">
                    <label for="modalMessage">Message</label>
                    <textarea id="modalMessage" name="body" placeholder="Tell us about your project..." required></textarea>
                </div>
                <button type="submit" class="cta-button">Send Message</button>
            </form>
        </div>
    </div>

    <style>
        /* Boot Sequence Styles */
        .boot-sequence-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            padding: 40px;
            font-family: 'VT323', monospace;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .boot-sequence-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .boot-sequence-overlay.removed {
            display: none;
        }

        .boot-diagnostics {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .boot-line {
            font-size: 1.2rem;
            color: #34ff35;
            text-shadow: 0 0 8px rgba(52, 255, 53, 0.6);
            opacity: 0;
            transform: translateX(-10px);
            transition: opacity 0.1s ease, transform 0.1s ease;
        }

        .boot-line.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .boot-line.flicker {
            animation: crtFlicker 0.15s ease-in-out;
        }

        .boot-line .status {
            color: #34ff35;
        }

        @keyframes crtFlicker {
            0% { opacity: 0.3; transform: translateX(-2px); }
            25% { opacity: 1; transform: translateX(1px); }
            50% { opacity: 0.7; transform: translateX(-1px); }
            75% { opacity: 1; transform: translateX(0); }
            100% { opacity: 1; transform: translateX(0); }
        }

        .boot-progress-container {
            margin-top: 30px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .boot-progress-container.visible {
            opacity: 1;
        }

        .boot-progress-bar {
            font-size: 1.2rem;
            color: #34ff35;
            text-shadow: 0 0 8px rgba(52, 255, 53, 0.6);
            letter-spacing: 2px;
        }

        /* CRT scanline effect for boot sequence */
        .boot-sequence-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1;
        }

        .boot-diagnostics,
        .boot-progress-container {
            position: relative;
            z-index: 2;
        }

        /* Hide main content during boot */
        .explore-page.boot-hidden {
            visibility: hidden;
        }
    </style>

    <script>
        // ========================================
        // State Management
        // ========================================

        // Default thoughts and responses (12 total)
        const defaultThoughts = [
            "I have ideas.",
            "I don't know where to start.",
            "Our tools don't fit us.",
            "I want software that matches how we work.",
            "Help us think this through.",
            "Who are you?",
            "I need something custom.",
            "Our budget is limited.",
            "We've tried this before.",
            "How long will it take?",
            "Can you work with our team?",
            "What makes you different?"
        ];

        const defaultResponses = [
            "Starting is the hardest part. We will figure out the first step together.",
            "Who we are is less important than what we can build together.",
            "The right tools don't exist yet; we have to invent them.",
            "Complexity is the enemy. We specialize in radical simplicity.",
            "Your vision is the blueprint. Our code is the foundation.",
            "We're builders who believe software should feel inevitable.",
            "Custom is our specialty. Every solution we build is tailored.",
            "Great work doesn't require a fortune. Let's find what's possible.",
            "Past failures are lessons. We learn what didn't work and build better.",
            "Quality takes time, but we move with purpose. Let's set expectations.",
            "Collaboration is core to how we work. Your team becomes ours.",
            "We listen first. Then we build what actually matters to you."
        ];

        // Default settings
        const defaultHeroText = 'Why are you here?';
        const defaultNavLinks = {
            changeDirections: 'Change direction',
            mainSite: 'Enter Main Site'
        };

        // Load from localStorage or use defaults
        function loadThoughtsFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_thoughts');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load thoughts from localStorage:', e);
            }
            return defaultThoughts;
        }

        function loadResponsesFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_responses');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load responses from localStorage:', e);
            }
            return defaultResponses;
        }

        function loadHeroTextFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_hero_text');
                if (stored) {
                    return stored;
                }
            } catch (e) {
                console.warn('Failed to load hero text from localStorage:', e);
            }
            return defaultHeroText;
        }

        function loadNavLinksFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_nav_links');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load nav links from localStorage:', e);
            }
            return defaultNavLinks;
        }

        function loadActionsFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_actions');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load actions from localStorage:', e);
            }
            return [];
        }

        function loadActiveStatesFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_active_states');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load active states from localStorage:', e);
            }
            // Default: all questions are active
            return Array(12).fill(true);
        }

        function loadRandomizeEnabledFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_randomize_enabled');
                if (stored !== null) {
                    return stored === 'true';
                }
            } catch (e) {
                console.warn('Failed to load randomize setting from localStorage:', e);
            }
            return false; // Default: randomize disabled
        }

        // Load boot sequence enabled state from localStorage (admin configurable)
        function loadBootSequenceEnabledFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_boot_sequence_enabled');
                if (stored !== null) {
                    return stored === 'true';
                }
            } catch (e) {
                console.warn('Failed to load boot sequence setting from localStorage:', e);
            }
            return true; // Default: boot sequence enabled
        }

        // Check if boot sequence has already played this session
        function hasBootSequencePlayedThisSession() {
            try {
                return sessionStorage.getItem('imaginecraft_boot_sequence_played') === 'true';
            } catch (e) {
                return false;
            }
        }

        // Mark boot sequence as played for this session
        function markBootSequencePlayed() {
            try {
                sessionStorage.setItem('imaginecraft_boot_sequence_played', 'true');
            } catch (e) {
                console.warn('Failed to mark boot sequence as played:', e);
            }
        }

        const bootSequenceEnabled = loadBootSequenceEnabledFromStorage();

        // Load system mood from localStorage (admin configurable)
        function loadSystemMoodFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_system_mood');
                if (stored && ['stable', 'glitchy', 'urgent'].includes(stored)) {
                    return stored;
                }
            } catch (e) {
                console.warn('Failed to load system mood from localStorage:', e);
            }
            return 'stable'; // Default: stable mood
        }

        const systemMood = loadSystemMoodFromStorage();

        // ========================================
        // Secret Commands System
        // ========================================

        // Default secret commands
        const defaultSecretCommands = [
            { keyword: 'FOREST', action: 'earthquake', enabled: true, description: 'Triggers Earthquake & Split to reveal background' },
            { keyword: 'MATRIX', action: 'matrix', enabled: true, description: 'Toggles digital rain animation on/off' },
            { keyword: 'ADMIN', action: 'redirect', url: 'admin.html', enabled: true, description: 'Navigates to Admin Dashboard' }
        ];

        // Load secret commands from localStorage
        function loadSecretCommandsFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_secret_commands');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load secret commands from localStorage:', e);
            }
            return [...defaultSecretCommands];
        }

        const secretCommands = loadSecretCommandsFromStorage();

        // Keystroke buffer for command detection
        let keystrokeBuffer = '';
        const maxBufferSize = 20; // Maximum characters to track
        let matrixToggleState = false; // Track matrix toggle state

        // Secret command visual feedback
        function showCommandFeedback() {
            const explorePage = document.querySelector('.explore-page');
            if (explorePage) {
                explorePage.classList.add('secret-command-activated');
                // Remove the class after animation completes
                setTimeout(() => {
                    explorePage.classList.remove('secret-command-activated');
                }, 600);
            }
        }

        // Execute secret command action
        function executeSecretCommand(command) {
            showCommandFeedback();

            switch (command.action) {
                case 'earthquake':
                    triggerSecretEarthquake();
                    break;
                case 'matrix':
                    toggleMatrixAnimation();
                    break;
                case 'redirect':
                    if (command.url) {
                        setTimeout(() => {
                            window.location.href = command.url;
                        }, 400);
                    }
                    break;
                case 'custom':
                    // For future custom actions
                    if (command.customFunction) {
                        try {
                            eval(command.customFunction);
                        } catch (e) {
                            console.warn('Failed to execute custom command:', e);
                        }
                    }
                    break;
            }
        }

        // Trigger earthquake without navigation (for secret command)
        function triggerSecretEarthquake() {
            const explorePage = document.querySelector('.explore-page');
            const terminalOverlay = document.getElementById('terminalOverlay');
            const background = document.getElementById('mainSiteBackground');
            const iframe = document.getElementById('mainSiteFrame');

            // Load main site if not already loaded
            if (iframe && !iframe.src) {
                iframe.src = 'main.html';
            }

            // Show background
            if (background) {
                background.classList.add('active');
            }

            // Apply quake time
            const actualQuakeTime = applyQuakeTimeVariable();
            const durationMs = actualQuakeTime * 1000;

            // Phase 1: Earthquake shake
            explorePage.classList.add('earthquake-shake');

            // After shake, split the terminal
            setTimeout(() => {
                terminalOverlay.classList.add('active');
                explorePage.style.visibility = 'hidden';

                setTimeout(() => {
                    terminalOverlay.classList.add('splitting');

                    // Navigate after split
                    setTimeout(() => {
                        window.location.href = 'main.html';
                    }, 800);
                }, 50);
            }, durationMs);
        }

        // Toggle matrix animation on/off
        function toggleMatrixAnimation() {
            if (state.matrixActive) {
                // Matrix is running - stop it
                const canvas = document.getElementById('matrixCanvas');
                if (canvas) {
                    canvas.classList.add('fade-out');
                    setTimeout(() => {
                        canvas.classList.remove('active', 'fade-out');
                        state.matrixActive = false;
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }, 500);
                }
            } else {
                // Start infinite matrix (not timed)
                triggerInfiniteMatrix();
            }
        }

        // Trigger matrix animation that runs until toggled off
        function triggerInfiniteMatrix() {
            if (state.matrixActive) return;

            state.matrixActive = true;
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.classList.remove('fade-out');
            canvas.classList.add('active');

            const fontSize = 14;
            const columns = Math.floor(canvas.width / fontSize);
            const drops = Array(columns).fill(1);

            function draw() {
                if (!state.matrixActive) return;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#34ff35';
                ctx.font = fontSize + 'px VT323, monospace';
                ctx.shadowColor = 'rgba(52, 255, 53, 0.5)';
                ctx.shadowBlur = 4;

                for (let i = 0; i < drops.length; i++) {
                    const char = Math.random() > 0.5 ? '1' : '0';
                    ctx.fillText(char, i * fontSize, drops[i] * fontSize);

                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }

                state.matrixAnimationId = requestAnimationFrame(draw);
            }

            draw();
        }

        // Check keystroke buffer for matching commands
        function checkSecretCommands() {
            const buffer = keystrokeBuffer.toUpperCase();

            for (const command of secretCommands) {
                if (!command.enabled) continue;

                const keyword = command.keyword.toUpperCase();
                if (buffer.endsWith(keyword)) {
                    // Command matched! Clear buffer and execute
                    keystrokeBuffer = '';
                    executeSecretCommand(command);
                    return true;
                }
            }
            return false;
        }

        // Global keydown listener for secret commands
        document.addEventListener('keydown', (event) => {
            // Only track printable characters
            if (event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {
                keystrokeBuffer += event.key;

                // Trim buffer if too long
                if (keystrokeBuffer.length > maxBufferSize) {
                    keystrokeBuffer = keystrokeBuffer.slice(-maxBufferSize);
                }

                // Check for command matches
                checkSecretCommands();
            }
        });

        // Fisher-Yates shuffle algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        const allThoughts = loadThoughtsFromStorage();
        const allResponses = loadResponsesFromStorage();
        const heroText = loadHeroTextFromStorage();
        const navLinks = loadNavLinksFromStorage();
        const actions = loadActionsFromStorage();
        const activeStates = loadActiveStatesFromStorage();
        const randomizeEnabled = loadRandomizeEnabledFromStorage();

        // Filter to only include active thoughts and track their original indices
        let activeIndices = [];
        let thoughts = [];
        let responses = [];
        for (let i = 0; i < allThoughts.length; i++) {
            // Default to active if no state is set
            if (activeStates[i] !== false) {
                activeIndices.push(i);
                thoughts.push(allThoughts[i]);
                responses.push(allResponses[i]);
            }
        }

        // Apply randomization if enabled
        if (randomizeEnabled && activeIndices.length > 0) {
            // Create array of indices into the active arrays
            const indices = activeIndices.map((_, idx) => idx);

            // Shuffle the indices
            const shuffledIndices = shuffleArray(indices);

            // Take up to 3 (or fewer if not enough active questions)
            const selectedCount = Math.min(3, shuffledIndices.length);
            const selectedIndices = shuffledIndices.slice(0, selectedCount);

            // Rebuild arrays with only the selected items
            const newActiveIndices = [];
            const newThoughts = [];
            const newResponses = [];

            for (const idx of selectedIndices) {
                newActiveIndices.push(activeIndices[idx]);
                newThoughts.push(thoughts[idx]);
                newResponses.push(responses[idx]);
            }

            activeIndices = newActiveIndices;
            thoughts = newThoughts;
            responses = newResponses;
        }

        // Load Matrix fade duration from localStorage (admin configurable)
        function loadMatrixFadeDurationFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_matrix_fade_duration');
                if (stored) {
                    return parseFloat(stored);
                }
            } catch (e) {
                console.warn('Failed to load matrix fade duration from localStorage:', e);
            }
            return 1.5; // Default fade duration in seconds
        }

        const matrixFadeDuration = loadMatrixFadeDurationFromStorage();

        // Load Earthquake duration from localStorage (admin configurable)
        function loadEarthquakeDurationFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_earthquake_duration');
                if (stored) {
                    return parseFloat(stored);
                }
            } catch (e) {
                console.warn('Failed to load earthquake duration from localStorage:', e);
            }
            return 1.5; // Default earthquake duration in seconds
        }

        const earthquakeDuration = loadEarthquakeDurationFromStorage();

        let state = {
            currentIndex: 0,
            isUserTyping: false,
            isSelected: false,
            selectedIndex: null,
            cycleTimeout: null,
            animationTimeout: null,
            isAnimating: false,
            currentText: '',
            targetText: '',
            matrixActive: false,
            matrixAnimationId: null
        };

        // Load typing speed from localStorage (admin configurable)
        function loadTypingSpeedFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_typing_speed');
                if (stored) {
                    return parseInt(stored, 10);
                }
            } catch (e) {
                console.warn('Failed to load typing speed from localStorage:', e);
            }
            return 150; // Default base speed
        }

        const baseTypingSpeed = loadTypingSpeedFromStorage();

        // Timing configuration (in ms) - uses admin-configurable base speed
        // Adjusted based on system mood
        function getTimingConfig() {
            const base = {
                initialDelay: 3000,
                typeSpeedMin: Math.max(50, baseTypingSpeed - 50),
                typeSpeedMax: baseTypingSpeed + 100,
                punctuationPause: 500,
                backspaceSpeedMin: 50,
                backspaceSpeedMax: 100,
                linger: 4000
            };

            switch (systemMood) {
                case 'glitchy':
                    // Glitchy: More irregular, stuttered rhythm with wider variance
                    return {
                        ...base,
                        typeSpeedMin: Math.max(30, baseTypingSpeed - 100),
                        typeSpeedMax: baseTypingSpeed + 200, // Wider range for irregular feel
                        punctuationPause: Math.random() > 0.5 ? 800 : 200, // Random pauses
                        backspaceSpeedMin: 30,
                        backspaceSpeedMax: 150,
                        linger: 3000
                    };
                case 'urgent':
                    // Urgent: Much faster typing
                    return {
                        ...base,
                        initialDelay: 1500, // Faster start
                        typeSpeedMin: Math.max(20, Math.floor(baseTypingSpeed * 0.3)),
                        typeSpeedMax: Math.floor(baseTypingSpeed * 0.5),
                        punctuationPause: 150, // Minimal pause
                        backspaceSpeedMin: 20,
                        backspaceSpeedMax: 50,
                        linger: 2000 // Shorter linger
                    };
                default: // 'stable'
                    return base;
            }
        }

        const timing = getTimingConfig();

        // Helper function for random delay between min and max
        function randomDelay(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Check if character is punctuation
        function isPunctuation(char) {
            return ['.', ',', '!', '?', ';', ':'].includes(char);
        }

        // Check for reduced motion preference
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        // ========================================
        // DOM Elements
        // ========================================
        const thoughtElement = document.getElementById('currentThought');
        const inputElement = document.getElementById('exploreInput');
        const panelsContainer = document.getElementById('explorePanels');
        const cursorElement = document.getElementById('exploreCursor');

        // ========================================
        // Typing Animation
        // ========================================

        // Glitchy mode typing helper - occasionally repeats or stutters
        function getGlitchyDelay(baseMin, baseMax) {
            // 15% chance of a glitch effect
            if (Math.random() < 0.15) {
                const glitchType = Math.random();
                if (glitchType < 0.3) {
                    // Very fast burst
                    return randomDelay(10, 30);
                } else if (glitchType < 0.6) {
                    // Long stutter pause
                    return randomDelay(300, 600);
                } else {
                    // Normal with jitter
                    return randomDelay(baseMin, baseMax) + (Math.random() > 0.5 ? 100 : -30);
                }
            }
            return randomDelay(baseMin, baseMax);
        }

        function typeCharacter(text, index, callback) {
            if (state.isUserTyping || state.isSelected) return;

            if (index <= text.length) {
                state.currentText = text.substring(0, index);
                thoughtElement.textContent = state.currentText;

                // Calculate delay - longer after punctuation, variable otherwise
                let delay = 0;
                if (!prefersReducedMotion) {
                    const lastChar = text.charAt(index - 1);
                    if (isPunctuation(lastChar)) {
                        // Glitchy mood has random punctuation pauses
                        delay = systemMood === 'glitchy'
                            ? (Math.random() > 0.5 ? timing.punctuationPause * 1.5 : timing.punctuationPause * 0.3)
                            : timing.punctuationPause;
                    } else {
                        // Use glitchy delay for glitchy mood
                        delay = systemMood === 'glitchy'
                            ? getGlitchyDelay(timing.typeSpeedMin, timing.typeSpeedMax)
                            : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                    }
                }

                state.animationTimeout = setTimeout(() => {
                    typeCharacter(text, index + 1, callback);
                }, delay);
            } else {
                if (callback) callback();
            }
        }

        function backspaceCharacter(callback) {
            if (state.isUserTyping || state.isSelected) return;

            if (state.currentText.length > 0) {
                state.currentText = state.currentText.substring(0, state.currentText.length - 1);
                thoughtElement.textContent = state.currentText;

                // Random jitter for backspace speed
                const delay = prefersReducedMotion ? 0 : randomDelay(timing.backspaceSpeedMin, timing.backspaceSpeedMax);

                state.animationTimeout = setTimeout(() => {
                    backspaceCharacter(callback);
                }, delay);
            } else {
                if (callback) callback();
            }
        }

        function showThought(index) {
            if (state.isUserTyping || state.isSelected || state.isAnimating) return;

            state.isAnimating = true;
            const thought = thoughts[index];
            state.targetText = thought;
            thoughtElement.dataset.index = index;

            // Make thought visible and start typing
            thoughtElement.classList.remove('fade-out');
            thoughtElement.classList.add('visible', 'fade-in');

            // Type out the thought character by character
            typeCharacter(thought, 0, () => {
                // Linger for 3 seconds after fully typed
                state.cycleTimeout = setTimeout(() => {
                    if (!state.isUserTyping && !state.isSelected) {
                        // Backspace the thought
                        backspaceCharacter(() => {
                            state.isAnimating = false;
                            // Move to next thought
                            state.currentIndex = (state.currentIndex + 1) % thoughts.length;
                            showThought(state.currentIndex);
                        });
                    }
                }, timing.linger);
            });
        }

        function startCycling() {
            // Check if there are any active thoughts to cycle
            if (thoughts.length === 0) {
                // No active thoughts - show cursor but display fallback message
                cursorElement.classList.add('visible');
                thoughtElement.textContent = 'No questions available';
                thoughtElement.classList.add('visible', 'fade-in');
                return;
            }

            // Show cursor after initial delay, then start cycling thoughts
            state.cycleTimeout = setTimeout(() => {
                cursorElement.classList.add('visible');
                showThought(state.currentIndex);
            }, timing.initialDelay);
        }

        function stopCycling() {
            clearTimeout(state.cycleTimeout);
            clearTimeout(state.animationTimeout);
            state.isAnimating = false;
        }

        // ========================================
        // Thought Selection
        // ========================================
        // Helper to get original index from filtered index
        function getOriginalIndex(filteredIndex) {
            if (typeof filteredIndex === 'number' && activeIndices[filteredIndex] !== undefined) {
                return activeIndices[filteredIndex];
            }
            return filteredIndex; // Return as-is for 'custom' or invalid
        }

        function selectThought(index) {
            state.isSelected = true;
            state.selectedIndex = index;
            // Sync currentIndex for sequential cycling continuity
            if (typeof index === 'number') {
                state.currentIndex = index;
            }
            stopCycling();

            // If we're selecting a cycling thought, show the full text
            if (typeof index === 'number' && thoughts[index]) {
                thoughtElement.textContent = thoughts[index];
                state.currentText = thoughts[index];
            }

            // Lock the thought in place
            thoughtElement.classList.add('selected');
            thoughtElement.classList.remove('fade-out', 'fade-in');
            thoughtElement.setAttribute('aria-pressed', 'true');

            // Hide cursor from thought line (it will appear in response)
            cursorElement.classList.remove('visible');

            // Get the original index for panel lookup
            const originalIndex = getOriginalIndex(index);

            // Show the corresponding panel using original index
            showPanel(index, originalIndex);
        }

        function showPanel(filteredIndex, originalIndex) {
            const panels = panelsContainer.querySelectorAll('.explore-panel');
            // Use original index for panel data-thought lookup, filtered index for responses array
            const panelId = typeof originalIndex === 'number' ? originalIndex : filteredIndex;

            panels.forEach(panel => {
                if (panel.dataset.thought === String(panelId)) {
                    panel.hidden = false;
                    panel.classList.add('visible');

                    // Get panel elements
                    const responseEl = panel.querySelector('.panel-response');
                    const textEl = panel.querySelector('.response-text');
                    const actionsEl = panel.querySelector('.explore-panel-actions');
                    const resetBtn = panel.querySelector('.explore-reset');
                    const actionBtn = panel.querySelector('.explore-action-link');
                    const enterBtn = panel.querySelector('.explore-link');

                    if (responseEl && textEl) {
                        // Get response from filtered responses array
                        const fullResponse = (typeof filteredIndex === 'number' && responses[filteredIndex])
                            ? responses[filteredIndex]
                            : "Every project starts with a conversation. Let's start ours.";
                        textEl.textContent = '';

                        // Clear action texts
                        if (resetBtn) {
                            const resetText = resetBtn.querySelector('.action-text');
                            if (resetText) resetText.textContent = '';
                        }
                        if (actionBtn) {
                            const actionText = actionBtn.querySelector('.action-text');
                            if (actionText) actionText.textContent = '';
                            actionBtn.classList.add('hidden');
                        }
                        if (enterBtn) {
                            const enterText = enterBtn.querySelector('.action-text');
                            if (enterText) enterText.textContent = '';
                        }

                        // Hide actions initially
                        if (actionsEl) actionsEl.classList.remove('visible');

                        // Start sequential typing: response -> actions
                        // Pass original index for action lookup
                        typePanelResponse(textEl, actionsEl, resetBtn, actionBtn, enterBtn, fullResponse, 0, originalIndex);
                    }

                    // Focus the panel for accessibility
                    setTimeout(() => {
                        const focusTarget = panel.querySelector('.panel-response') || panel.querySelector('h2');
                        if (focusTarget) focusTarget.focus();
                    }, 100);
                } else {
                    panel.hidden = true;
                    panel.classList.remove('visible');
                    // Clear any response text when hiding
                    const textEl = panel.querySelector('.response-text');
                    const actionsEl = panel.querySelector('.explore-panel-actions');
                    if (textEl) textEl.textContent = '';
                    if (actionsEl) actionsEl.classList.remove('visible');
                }
            });

            panelsContainer.classList.add('visible');
        }

        function typePanelResponse(textEl, actionsEl, resetBtn, actionBtn, enterBtn, text, charIndex, panelIndex) {
            if (charIndex <= text.length) {
                // Show cursor after text
                textEl.innerHTML = text.substring(0, charIndex) + '<span class="typing-cursor">â–ˆ</span>';

                let delay = 0;
                if (!prefersReducedMotion) {
                    const lastChar = text.charAt(charIndex - 1);
                    if (isPunctuation(lastChar)) {
                        // Glitchy mood has random punctuation pauses
                        delay = systemMood === 'glitchy'
                            ? (Math.random() > 0.5 ? timing.punctuationPause * 1.5 : timing.punctuationPause * 0.3)
                            : timing.punctuationPause;
                    } else {
                        // Use glitchy delay for glitchy mood
                        delay = systemMood === 'glitchy'
                            ? getGlitchyDelay(timing.typeSpeedMin, timing.typeSpeedMax)
                            : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                    }
                }

                setTimeout(() => {
                    typePanelResponse(textEl, actionsEl, resetBtn, actionBtn, enterBtn, text, charIndex + 1, panelIndex);
                }, delay);
            } else {
                // Response typing complete - remove cursor from response
                textEl.textContent = text;

                // Show actions container and start typing navigation
                if (actionsEl) {
                    actionsEl.classList.add('visible');
                    // Type out the navigation links
                    typeNavigationLinks(resetBtn, actionBtn, enterBtn, panelIndex);
                }
            }
        }

        function typeNavigationLinks(resetBtn, actionBtn, enterBtn, panelIndex) {
            const resetText = navLinks.changeDirections || defaultNavLinks.changeDirections;
            const enterText = navLinks.mainSite || defaultNavLinks.mainSite;

            // Check if this panel has an action
            const action = (typeof panelIndex === 'number' && actions[panelIndex]) ? actions[panelIndex] : null;
            const hasAction = action && action.type && action.type !== 'none';

            // Type "Change direction" first
            typeActionText(resetBtn, resetText, 0, () => {
                // Small pause then type action link (if any)
                setTimeout(() => {
                    if (hasAction && actionBtn) {
                        const actionLinkText = action.linkText || 'Click here';
                        actionBtn.classList.remove('hidden');
                        typeActionText(actionBtn, actionLinkText, 0, () => {
                            // Set up action button handler
                            actionBtn.classList.add('ready');
                            actionBtn.onclick = () => executeAction(action);

                            // Small pause then type "Enter Main Site"
                            setTimeout(() => {
                                typeActionText(enterBtn, enterText, 0, () => {
                                    finishNavigationSetup(resetBtn, enterBtn);
                                });
                            }, 300);
                        });
                    } else {
                        // No action, go straight to "Enter Main Site"
                        typeActionText(enterBtn, enterText, 0, () => {
                            finishNavigationSetup(resetBtn, enterBtn);
                        });
                    }
                }, 300);
            });
        }

        function finishNavigationSetup(resetBtn, enterBtn) {
            // All done - make buttons functional
            if (resetBtn) {
                resetBtn.classList.add('ready');
                resetBtn.onclick = resetExplore;
            }
            if (enterBtn) {
                enterBtn.classList.add('ready');
            }

            // Stop cursor blinking - typing is complete
            cursorElement.classList.add('cursor-stopped');
        }

        function typeActionText(btn, text, index, callback) {
            if (!btn) {
                if (callback) callback();
                return;
            }

            const textSpan = btn.querySelector('.action-text');
            if (!textSpan) {
                if (callback) callback();
                return;
            }

            if (index <= text.length) {
                // Show cursor after text
                textSpan.innerHTML = text.substring(0, index) + '<span class="typing-cursor">â–ˆ</span>';

                const delay = prefersReducedMotion ? 0 : randomDelay(60, 120);
                setTimeout(() => {
                    typeActionText(btn, text, index + 1, callback);
                }, delay);
            } else {
                // Typing complete - show final text without cursor
                textSpan.textContent = text;
                if (callback) callback();
            }
        }

        // ========================================
        // Action Execution
        // ========================================
        function executeAction(action) {
            if (!action || !action.type) return;

            switch (action.type) {
                case 'video':
                    openVideoModal(action.url);
                    break;
                case 'image':
                    openImageModal(action.url);
                    break;
                case 'logo':
                    printAsciiLogo(action.logo);
                    break;
                case 'matrix':
                    triggerMatrixAnimation();
                    break;
                case 'contact':
                    openContactModal();
                    break;
            }
        }

        // ========================================
        // Multimedia Modal (Video/Image)
        // ========================================
        function openVideoModal(url) {
            if (!url) return;

            const modal = document.getElementById('multimediaModal');
            const content = document.getElementById('multimediaContent');

            // Extract video ID from YouTube URL
            let videoId = '';
            const urlPatterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\s?]+)/,
                /youtube\.com\/shorts\/([^&\s?]+)/
            ];

            for (const pattern of urlPatterns) {
                const match = url.match(pattern);
                if (match) {
                    videoId = match[1];
                    break;
                }
            }

            if (videoId) {
                content.innerHTML = `
                    <iframe
                        src="https://www.youtube.com/embed/${videoId}?autoplay=1"
                        frameborder="0"
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen>
                    </iframe>
                `;
            } else {
                // Fallback: try embedding as-is
                content.innerHTML = `
                    <iframe
                        src="${url}"
                        frameborder="0"
                        allowfullscreen>
                    </iframe>
                `;
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function openImageModal(url) {
            if (!url) return;

            const modal = document.getElementById('multimediaModal');
            const content = document.getElementById('multimediaContent');

            content.innerHTML = `<img src="${url}" alt="Image content" class="modal-image">`;

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeMultimediaModal() {
            const modal = document.getElementById('multimediaModal');
            const content = document.getElementById('multimediaContent');

            modal.classList.remove('active');
            document.body.style.overflow = '';

            // Clear content to stop video playback
            setTimeout(() => {
                content.innerHTML = '';
            }, 300);
        }

        function closeMultimediaModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeMultimediaModal();
            }
        }

        // ========================================
        // ASCII Logo Printing
        // ========================================
        function printAsciiLogo(logoText) {
            if (!logoText) return;

            const container = document.getElementById('asciiLogoContainer');

            // Clear any existing content
            container.innerHTML = '';

            // Create wrapper for positioning the close button
            const wrapper = document.createElement('div');
            wrapper.className = 'ascii-logo-wrapper';

            // Create home link that wraps the logo
            const homeLink = document.createElement('a');
            homeLink.className = 'ascii-logo-home-link';
            homeLink.href = 'index.html';
            homeLink.setAttribute('aria-label', 'Return to home and reset terminal');
            homeLink.onclick = function(e) {
                e.preventDefault();
                closeAsciiLogo();
                resetExplore();
            };

            // Create close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'ascii-logo-close';
            closeBtn.textContent = 'X';
            closeBtn.setAttribute('aria-label', 'Close logo');
            closeBtn.onclick = function(e) {
                e.stopPropagation();
                closeAsciiLogo();
            };

            // Create logo element
            const logoElement = document.createElement('pre');
            logoElement.className = 'ascii-logo';
            logoElement.textContent = '';

            // Structure: wrapper > homeLink > logoElement, wrapper > closeBtn
            homeLink.appendChild(logoElement);
            wrapper.appendChild(homeLink);
            wrapper.appendChild(closeBtn);
            container.appendChild(wrapper);

            // Show the container
            container.classList.add('visible');

            // Type out the logo character by character
            typeAsciiLogo(logoElement, logoText, 0);
        }

        function typeAsciiLogo(element, text, index) {
            if (index <= text.length) {
                element.textContent = text.substring(0, index);

                // Faster typing for ASCII art
                const delay = prefersReducedMotion ? 0 : randomDelay(5, 15);
                setTimeout(() => {
                    typeAsciiLogo(element, text, index + 1);
                }, delay);
            }
        }

        function closeAsciiLogo() {
            const container = document.getElementById('asciiLogoContainer');
            container.classList.remove('visible');
            // Clear content after hiding
            setTimeout(() => {
                container.innerHTML = '';
            }, 300);
        }

        // ========================================
        // The Matrix Animation
        // ========================================
        function triggerMatrixAnimation() {
            if (state.matrixActive) return;

            state.matrixActive = true;
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas to full screen
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.classList.remove('fade-out');
            canvas.classList.add('active');

            const fontSize = 14;
            const columns = Math.floor(canvas.width / fontSize);
            const drops = Array(columns).fill(1);

            function draw() {
                // Semi-transparent black background for trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Green text - updated to #34ff35
                ctx.fillStyle = '#34ff35';
                ctx.font = fontSize + 'px VT323, monospace';
                ctx.shadowColor = 'rgba(52, 255, 53, 0.5)';
                ctx.shadowBlur = 4;

                for (let i = 0; i < drops.length; i++) {
                    // Random 0 or 1
                    const char = Math.random() > 0.5 ? '1' : '0';
                    ctx.fillText(char, i * fontSize, drops[i] * fontSize);

                    // Reset drop when it reaches bottom or randomly
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }

            // Run animation for 5 seconds
            const interval = setInterval(draw, 50);

            setTimeout(() => {
                clearInterval(interval);

                // Apply dynamic fade duration from admin settings
                const fadeDurationMs = matrixFadeDuration * 1000;
                canvas.style.transition = `opacity ${matrixFadeDuration}s ease`;

                // Start fade-out transition
                canvas.classList.add('fade-out');

                // After fade-out completes, clean up
                setTimeout(() => {
                    canvas.classList.remove('active', 'fade-out');
                    canvas.style.transition = ''; // Reset to CSS default
                    state.matrixActive = false;
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }, fadeDurationMs);
            }, 5000);
        }

        // Handle window resize for Matrix canvas
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('matrixCanvas');
            if (canvas.classList.contains('active')) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        });

        function resetExplore() {
            state.isSelected = false;
            state.isUserTyping = false;
            state.isAnimating = false;
            // Advance to the next thought in sequence (don't reset to 0)
            state.currentIndex = (state.currentIndex + 1) % thoughts.length;
            state.selectedIndex = null;
            state.currentText = '';
            state.targetText = '';

            // Reset thought element
            thoughtElement.classList.remove('selected', 'visible', 'fade-in', 'fade-out');
            thoughtElement.textContent = '';
            thoughtElement.removeAttribute('aria-pressed');

            // Hide cursor initially (will be shown after delay when cycling restarts)
            cursorElement.classList.remove('visible', 'cursor-stopped');

            // Hide all panels and reset their elements
            const panels = panelsContainer.querySelectorAll('.explore-panel');
            panels.forEach(panel => {
                panel.hidden = true;
                panel.classList.remove('visible');
                // Reset panel elements
                const textEl = panel.querySelector('.response-text');
                const actionsEl = panel.querySelector('.explore-panel-actions');
                const resetBtn = panel.querySelector('.explore-reset');
                const actionBtn = panel.querySelector('.explore-action-link');
                const enterBtn = panel.querySelector('.explore-link');

                if (textEl) textEl.textContent = '';
                if (actionsEl) actionsEl.classList.remove('visible');
                if (resetBtn) {
                    resetBtn.classList.remove('ready');
                    resetBtn.onclick = null;
                    const resetTextSpan = resetBtn.querySelector('.action-text');
                    if (resetTextSpan) resetTextSpan.textContent = '';
                }
                if (actionBtn) {
                    actionBtn.classList.remove('ready');
                    actionBtn.classList.add('hidden');
                    actionBtn.onclick = null;
                    const actionTextSpan = actionBtn.querySelector('.action-text');
                    if (actionTextSpan) actionTextSpan.textContent = '';
                }
                if (enterBtn) {
                    enterBtn.classList.remove('ready');
                    const enterTextSpan = enterBtn.querySelector('.action-text');
                    if (enterTextSpan) enterTextSpan.textContent = '';
                }
            });
            panelsContainer.classList.remove('visible');

            // Clear input
            inputElement.value = '';
            inputElement.classList.remove('active');

            // Restart cycling
            startCycling();
        }

        // ========================================
        // Input Handling
        // ========================================
        function handleInputChange() {
            const hasValue = inputElement.value.trim().length > 0;

            if (hasValue && !state.isUserTyping) {
                state.isUserTyping = true;
                stopCycling();
                thoughtElement.classList.remove('visible', 'fade-in', 'fade-out');
                thoughtElement.textContent = '';
                state.currentText = '';
                inputElement.classList.add('active');
            } else if (!hasValue && state.isUserTyping) {
                state.isUserTyping = false;
                inputElement.classList.remove('active');
                if (!state.isSelected) {
                    startCycling();
                }
            }
        }

        function handleInputKeydown(event) {
            if (event.key === 'Enter' && inputElement.value.trim()) {
                event.preventDefault();
                selectThought('custom');
            }
        }

        // ========================================
        // Event Listeners
        // ========================================
        // Event delegation on parent container for thought clicks
        // This ensures clicks work even while text is being typed/re-rendered
        document.querySelector('.explore-thought-container').addEventListener('click', (event) => {
            const thought = event.target.closest('.explore-thought');
            if (thought && thought.classList.contains('visible') && !state.isSelected) {
                const index = parseInt(thought.dataset.index, 10);
                selectThought(index);
            }
        });

        // Event delegation for keyboard accessibility
        document.querySelector('.explore-thought-container').addEventListener('keydown', (event) => {
            const thought = event.target.closest('.explore-thought');
            if ((event.key === 'Enter' || event.key === ' ') &&
                thought && thought.classList.contains('visible') &&
                !state.isSelected) {
                event.preventDefault();
                const index = parseInt(thought.dataset.index, 10);
                selectThought(index);
            }
        });

        inputElement.addEventListener('input', handleInputChange);
        inputElement.addEventListener('keydown', handleInputKeydown);

        // Focus input when clicking anywhere in question area
        document.querySelector('.explore-question-area').addEventListener('click', (event) => {
            if (!event.target.closest('.explore-thought') && !state.isSelected) {
                inputElement.focus();
            }
        });

        // ========================================
        // Contact Modal (reused)
        // ========================================
        function openContactModal() {
            document.getElementById('contactModal').classList.add('active');
            document.body.style.overflow = 'hidden';
            document.getElementById('modalName').focus();
        }

        function closeContactModal() {
            document.getElementById('contactModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        function closeModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeContactModal();
            }
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                closeContactModal();
                closeMultimediaModal();
            }
        });

        // ========================================
        // Earthquake Transition
        // ========================================
        function loadEarthquakeSettingFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_earthquake_enabled');
                if (stored !== null) {
                    return stored === 'true';
                }
            } catch (e) {
                console.warn('Failed to load earthquake setting from localStorage:', e);
            }
            return true; // Default to enabled
        }

        const earthquakeEnabled = loadEarthquakeSettingFromStorage();

        // Apply --quake-time CSS variable from localStorage immediately
        // Urgent mood increases earthquake duration by 50% for more dramatic effect
        function applyQuakeTimeVariable() {
            let quakeTime = earthquakeDuration; // Already loaded from localStorage

            // Urgent mood gets 50% longer and more intense earthquake
            if (systemMood === 'urgent') {
                quakeTime = quakeTime * 1.5;
            }

            document.documentElement.style.setProperty('--quake-time', `${quakeTime}s`);
            return quakeTime;
        }

        // Preload main.html content as background layer when earthquake is enabled
        // Superman Logic: Main site is ALWAYS rendered behind terminal
        function preloadMainSite() {
            const iframe = document.getElementById('mainSiteFrame');
            const background = document.getElementById('mainSiteBackground');

            if (earthquakeEnabled) {
                // Load main site immediately so it's ready behind the terminal
                if (iframe && !iframe.src) {
                    iframe.src = 'main.html';
                }
                // Mark as preloaded (main site is now rendering behind terminal)
                if (background) {
                    background.classList.add('preloaded');
                }
            }
        }

        // Execute earthquake transition - True Superman reveal style
        function triggerEarthquakeTransition(event) {
            if (!earthquakeEnabled) {
                // Normal navigation
                return true;
            }

            // Prevent default navigation
            event.preventDefault();

            const explorePage = document.querySelector('.explore-page');
            const terminalOverlay = document.getElementById('terminalOverlay');
            const background = document.getElementById('mainSiteBackground');
            const iframe = document.getElementById('mainSiteFrame');

            // Ensure iframe is loaded (should already be preloaded)
            if (!iframe.src) {
                iframe.src = 'main.html';
            }

            // The main site background is ALREADY visible (z-index: 1)
            // The terminal (explore-page) covers it (z-index: 2)
            // Mark background as active to ensure visibility
            if (background) {
                background.classList.add('active');
            }

            // Apply --quake-time variable before animation starts
            // Returns the actual quake time (may be modified for urgent mood)
            const actualQuakeTime = applyQuakeTimeVariable();
            const durationMs = actualQuakeTime * 1000;

            // Phase 1: Earthquake shake on the explore page (terminal layer only)
            // The main site stays static behind it
            explorePage.classList.add('earthquake-shake');

            // After shake completes, trigger the terminal split
            setTimeout(() => {
                // Phase 2: Activate terminal overlay (the shell that splits)
                // This overlay sits at z-index: 3, above the terminal content
                terminalOverlay.classList.add('active');

                // Hide the explore page content so only the overlay shows
                explorePage.style.visibility = 'hidden';

                // Small delay then crack/split the terminal shell
                setTimeout(() => {
                    terminalOverlay.classList.add('splitting');

                    // Phase 3: After split animation (0.8s), navigate to main.html
                    // The main site is already visible through the cracks
                    setTimeout(() => {
                        window.location.href = 'main.html';
                    }, 800);
                }, 50);
            }, durationMs);

            return false;
        }

        // Attach earthquake transition to all Main Site links
        function attachEarthquakeHandlers() {
            // Get all "Enter Main Site" links
            const mainSiteLinks = document.querySelectorAll('.explore-link');
            mainSiteLinks.forEach(link => {
                link.addEventListener('click', triggerEarthquakeTransition);
            });
        }

        // ========================================
        // Boot Sequence Animation
        // ========================================
        function runBootSequence(callback) {
            const overlay = document.getElementById('bootSequenceOverlay');
            const diagnostics = document.getElementById('bootDiagnostics');
            const progressContainer = document.getElementById('bootProgressContainer');
            const progressBar = document.getElementById('bootProgressBar');
            const explorePage = document.querySelector('.explore-page');

            if (!overlay) {
                if (callback) callback();
                return;
            }

            // Hide main content during boot
            if (explorePage) {
                explorePage.classList.add('boot-hidden');
            }

            const bootLines = diagnostics.querySelectorAll('.boot-line');
            let currentLine = 0;

            // Phase 1: Show diagnostic lines with flicker effect
            function showNextDiagnosticLine() {
                if (currentLine < bootLines.length) {
                    const line = bootLines[currentLine];
                    line.classList.add('flicker');

                    // After flicker animation, make it visible
                    setTimeout(() => {
                        line.classList.add('visible');
                        line.classList.remove('flicker');
                        currentLine++;

                        // Random delay between lines (80-200ms) for that mechanical feel
                        const delay = Math.floor(Math.random() * 120) + 80;
                        setTimeout(showNextDiagnosticLine, delay);
                    }, 150);
                } else {
                    // All diagnostic lines shown, start progress bar
                    setTimeout(startProgressBar, 300);
                }
            }

            // Phase 2: Animate the progress bar
            function startProgressBar() {
                progressContainer.classList.add('visible');

                let progress = 0;
                const totalDuration = 1800; // 1.8 seconds total
                const updateInterval = 50; // Update every 50ms
                const steps = totalDuration / updateInterval;
                const progressPerStep = 100 / steps;

                const progressInterval = setInterval(() => {
                    progress += progressPerStep;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(progressInterval);

                        // Update final progress bar
                        updateProgressBar(100);

                        // Phase 3: Fade out and transition to main terminal
                        setTimeout(finishBootSequence, 200);
                    } else {
                        updateProgressBar(Math.floor(progress));
                    }
                }, updateInterval);
            }

            function updateProgressBar(percent) {
                const filled = Math.floor(percent / 5); // 20 characters total
                const empty = 20 - filled;
                const bar = '[' + '#'.repeat(filled) + '-'.repeat(empty) + '] ' + percent + '%';
                progressBar.textContent = bar;
            }

            // Phase 3: Finish boot sequence and reveal main terminal
            function finishBootSequence() {
                // Fade out the overlay
                overlay.classList.add('hidden');

                // Show main content
                if (explorePage) {
                    explorePage.classList.remove('boot-hidden');
                }

                // After fade transition, remove overlay completely
                setTimeout(() => {
                    overlay.classList.add('removed');

                    // Mark as played for this session
                    markBootSequencePlayed();

                    // Trigger the callback (start main terminal)
                    if (callback) callback();
                }, 300);
            }

            // Start the boot sequence
            showNextDiagnosticLine();
        }

        function skipBootSequence() {
            const overlay = document.getElementById('bootSequenceOverlay');
            const explorePage = document.querySelector('.explore-page');

            if (overlay) {
                overlay.classList.add('removed');
            }
            if (explorePage) {
                explorePage.classList.remove('boot-hidden');
            }
        }

        // ========================================
        // Initialize
        // ========================================
        document.addEventListener('DOMContentLoaded', () => {
            // Apply system mood CSS class to explore page
            const explorePage = document.querySelector('.explore-page');
            if (explorePage && systemMood !== 'stable') {
                explorePage.classList.add(`mood-${systemMood}`);
            }

            // Set hero text from localStorage
            const heroElement = document.getElementById('exploreQuestion');
            if (heroElement && heroText) {
                heroElement.textContent = heroText;
            }

            // Apply reduced motion adjustments
            if (prefersReducedMotion) {
                timing.fadeIn = 0;
                timing.fadeOut = 0;
                timing.linger = 5000;
            }

            // Apply --quake-time CSS variable from localStorage on page load
            applyQuakeTimeVariable();

            // Initialize earthquake transition
            attachEarthquakeHandlers();
            preloadMainSite();

            // Function to start the main terminal experience
            function initializeTerminal() {
                startCycling();
            }

            // Check if boot sequence should run
            const shouldRunBootSequence = bootSequenceEnabled &&
                                          !hasBootSequencePlayedThisSession() &&
                                          !prefersReducedMotion;

            if (shouldRunBootSequence) {
                // Run boot sequence, then initialize terminal
                runBootSequence(initializeTerminal);
            } else {
                // Skip boot sequence, initialize terminal immediately
                skipBootSequence();
                initializeTerminal();
            }
        });
    </script>
</body>
</html>
