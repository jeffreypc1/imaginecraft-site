<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>ImagineCraft Studios</title>
    <!-- Dynamic Cache Buster: Appends timestamp to CSS/JS resources to bypass CDN caching -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=VT323&display=swap" rel="stylesheet">
    <script>
        // Generate timestamp once for consistent cache busting across all resources
        var CACHE_TIMESTAMP = Date.now();
        // Write CSS link with dynamic timestamp to bypass GitHub CDN caching
        document.write('<link rel="stylesheet" href="style.css?v=' + CACHE_TIMESTAMP + '">');
    </script>
    <noscript><link rel="stylesheet" href="style.css"></noscript>
</head>
<body>
    <!-- Boot Sequence Overlay -->
    <div id="bootSequenceOverlay" class="boot-sequence-overlay">
        <div class="boot-diagnostics" id="bootDiagnostics">
            <!-- Boot lines will be dynamically typed character-by-character from Firebase bootScript -->
        </div>
    </div>

    <main class="explore-page" role="main">
        <div class="explore-container">
            <!-- Question and cursor area -->
            <div class="explore-question-area">
                <h1 class="explore-question" id="exploreQuestion"></h1>
                <!-- Cursor and thoughts inline together -->
                <div class="explore-cursor-line">
                    <div class="explore-thought-container" aria-live="polite" aria-atomic="true">
                        <button
                            class="explore-thought"
                            id="currentThought"
                            tabindex="0"
                            aria-label="Click to select this thought"
                        ></button>
                    </div><span class="explore-cursor" id="exploreCursor" aria-hidden="true">â–ˆ</span>
                    <!-- Optional: text input appears here when user starts typing -->
                    <input
                        type="text"
                        class="explore-input"
                        id="exploreInput"
                        placeholder=""
                        aria-label="Type your own response"
                        autocomplete="off"
                    >
                </div>
                <!-- Choice buttons for Yes/No interaction -->
                <div class="choice-buttons-container" id="choiceButtonsContainer" hidden>
                    <button class="choice-btn choice-btn-yes" id="choiceBtnYes">Yes</button>
                    <button class="choice-btn choice-btn-no" id="choiceBtnNo">No</button>
                </div>
                <!-- New Question button (appears after No selection) -->
                <button class="new-question-btn" id="newQuestionBtnChoice">New Question</button>
            </div>

            <!-- Response panels (hidden by default) -->
            <div class="explore-panels" id="explorePanels" aria-live="polite">
                <!-- Panel 1: I have ideas -->
                <article class="explore-panel" data-thought="0" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn0"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn0">New Question</button>
                    </div>
                </article>

                <!-- Panel 2: I don't know where to start -->
                <article class="explore-panel" data-thought="1" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn1"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn1">New Question</button>
                    </div>
                </article>

                <!-- Panel 3: Our tools don't fit us -->
                <article class="explore-panel" data-thought="2" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn2"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn2">New Question</button>
                    </div>
                </article>

                <!-- Panel 4: I want software that matches how we work -->
                <article class="explore-panel" data-thought="3" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn3"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn3">New Question</button>
                    </div>
                </article>

                <!-- Panel 5: Help us think this through -->
                <article class="explore-panel" data-thought="4" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn4"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn4">New Question</button>
                    </div>
                </article>

                <!-- Panel 6: Who are you? -->
                <article class="explore-panel" data-thought="5" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn5"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 7: I need something custom -->
                <article class="explore-panel" data-thought="6" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn6"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 8: Our budget is limited -->
                <article class="explore-panel" data-thought="7" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn7"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 9: We've tried this before -->
                <article class="explore-panel" data-thought="8" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn8"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 10: How long will it take? -->
                <article class="explore-panel" data-thought="9" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn9"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 11: Can you work with our team? -->
                <article class="explore-panel" data-thought="10" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn10"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 12: What makes you different? -->
                <article class="explore-panel" data-thought="11" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn11"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Generic panel for typed input -->
                <article class="explore-panel" data-thought="custom" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtnCustom"><span class="action-text"></span></button>
                    </div>
                </article>
            </div>

        </div>
    </main>

    <!-- Multimedia Modal (for video/image actions) -->
    <div class="modal-overlay" id="multimediaModal" onclick="closeMultimediaModalOnOverlay(event)">
        <div class="modal-content multimedia-modal-content" role="dialog" aria-modal="true" aria-labelledby="multimediaTitle">
            <button class="modal-close" onclick="closeMultimediaModal()" aria-label="Close modal">&times;</button>
            <div id="multimediaContent" class="multimedia-container">
                <!-- Video iframe or image will be inserted here -->
            </div>
        </div>
    </div>

    <!-- The Matrix Canvas (for falling 0s and 1s animation) -->
    <canvas id="matrixCanvas" class="matrix-canvas"></canvas>

    <!-- ASCII Logo Container (for permanent terminal logos) -->
    <div id="asciiLogoContainer" class="ascii-logo-container"></div>

    <!-- Main Site Background Layer (z-index: 1) - Always loaded behind terminal -->
    <div id="mainSiteBackground" class="main-site-background">
        <iframe id="mainSiteFrame" src="" title="Main Site"></iframe>
    </div>

    <!-- Terminal Overlay Shell (z-index: 2) - Splits during earthquake transition -->
    <div id="terminalOverlay" class="terminal-overlay">
        <div class="terminal-half terminal-half-left"></div>
        <div class="terminal-half terminal-half-right"></div>
    </div>

    <!-- Contact Modal (reused from main site) -->
    <div class="modal-overlay" id="contactModal" onclick="closeModalOnOverlay(event)">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
            <button class="modal-close" onclick="closeContactModal()" aria-label="Close modal">&times;</button>
            <h2 id="modalTitle">Get in Touch</h2>
            <form class="modal-form">
                <div class="form-group">
                    <label for="modalName">Name</label>
                    <input type="text" id="modalName" name="name" placeholder="Your name" required>
                </div>
                <div class="form-group">
                    <label for="modalEmail">Email</label>
                    <input type="email" id="modalEmail" name="email" placeholder="you@example.com" required>
                </div>
                <div class="form-group">
                    <label for="modalMessage">Message</label>
                    <textarea id="modalMessage" name="body" placeholder="Tell us about your project..." required></textarea>
                </div>
                <button type="submit" class="cta-button">Send Message</button>
            </form>
        </div>
    </div>

    <!-- Name Capture Modal -->
    <div class="modal-overlay" id="nameModal" onclick="closeModalOnOverlay(event)">
        <div class="modal-content name-modal-content" role="dialog" aria-modal="true" aria-labelledby="nameModalTitle">
            <button class="modal-close" onclick="closeNameModal()" aria-label="Close modal">&times;</button>
            <h2 id="nameModalTitle">Identity Recognition</h2>
            <p class="name-modal-subtitle">Please enter your designation for system records.</p>
            <form class="modal-form" onsubmit="saveUserName(event)">
                <div class="form-group">
                    <label for="userName">Name</label>
                    <input type="text" id="userName" name="userName" placeholder="Enter your name" required autofocus>
                </div>
                <button type="submit" class="cta-button">Confirm</button>
            </form>
        </div>
    </div>

    <style>
        /* Boot Sequence Styles */
        .boot-sequence-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000 !important;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
            font-family: 'VT323', monospace;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .boot-sequence-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .boot-sequence-overlay.removed {
            display: none;
        }

        .boot-diagnostics {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            text-align: center;
        }

        .boot-line {
            font-size: 1.2rem;
            color: #34ff35;
            text-shadow: 0 0 8px rgba(52, 255, 53, 0.6);
            opacity: 1;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-width: 90%;
        }

        .boot-line.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .boot-line.flicker {
            animation: crtFlicker 0.15s ease-in-out;
        }

        .boot-line .status {
            color: #34ff35;
        }

        @keyframes crtFlicker {
            0% { opacity: 0.3; transform: translateX(-2px); }
            25% { opacity: 1; transform: translateX(1px); }
            50% { opacity: 0.7; transform: translateX(-1px); }
            75% { opacity: 1; transform: translateX(0); }
            100% { opacity: 1; transform: translateX(0); }
        }

        /* CRT scanline effect for boot sequence */
        .boot-sequence-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1;
        }

        .boot-diagnostics,
        .boot-progress-container {
            position: relative;
            z-index: 2;
        }

        /* Hide main content during boot */
        .explore-page.boot-hidden {
            visibility: hidden;
        }

        /* Transparent Effect Styles */
        .builders-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: #2a2a2a;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .builders-container.active {
            opacity: 1;
        }

        .builders-media {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Placeholder construction scene when no media is set */
        .builders-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #87CEEB 0%, #87CEEB 60%, #8B4513 60%, #8B4513 100%);
            position: relative;
            overflow: hidden;
        }

        .scaffold {
            position: absolute;
            bottom: 40%;
            left: 20%;
            width: 200px;
            height: 300px;
            border: 8px solid #654321;
            border-bottom: none;
            background: transparent;
        }

        .scaffold::before,
        .scaffold::after {
            content: '';
            position: absolute;
            background: #654321;
        }

        .scaffold::before {
            width: 100%;
            height: 8px;
            top: 50%;
        }

        .scaffold::after {
            width: 8px;
            height: 100%;
            left: 50%;
        }

        .scaffold-2 {
            left: auto;
            right: 25%;
            height: 250px;
        }

        .builder {
            position: absolute;
            bottom: 40%;
            z-index: 2;
        }

        .builder-1 {
            left: 25%;
        }

        .builder-2 {
            right: 30%;
        }

        .builder-body {
            width: 40px;
            height: 80px;
            background: linear-gradient(180deg, #FFD700 0%, #FFD700 30%, #1E90FF 30%, #1E90FF 100%);
            border-radius: 20px 20px 5px 5px;
            position: relative;
        }

        .builder-body::before {
            content: '';
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 30px;
            background: #FFE4C4;
            border-radius: 50%;
        }

        .builder-body::after {
            content: '';
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            width: 35px;
            height: 15px;
            background: #FFD700;
            border-radius: 50% 50% 0 0;
        }

        .hammer {
            position: absolute;
            top: 10px;
            right: -30px;
            width: 8px;
            height: 40px;
            background: #8B4513;
            transform-origin: bottom center;
            animation: hammerSwing 0.8s ease-in-out infinite;
        }

        .hammer::before {
            content: '';
            position: absolute;
            top: -12px;
            left: -8px;
            width: 24px;
            height: 15px;
            background: #696969;
            border-radius: 3px;
        }

        .builder-2 .hammer {
            animation-delay: 0.4s;
        }

        @keyframes hammerSwing {
            0%, 100% { transform: rotate(-30deg); }
            50% { transform: rotate(30deg); }
        }

        .builders-text {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'VT323', monospace;
            font-size: 3rem;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            letter-spacing: 0.2em;
        }

        /* Terminal fade effect */
        .explore-page.transparent-fade {
            animation: terminalFade 3s ease-in-out forwards;
        }

        @keyframes terminalFade {
            0% {
                background-color: rgba(0, 0, 0, 1);
            }
            100% {
                background-color: rgba(0, 0, 0, 0.15);
            }
        }

        .explore-page.transparent-fade .explore-container {
            animation: textFade 3s ease-in-out forwards;
        }

        @keyframes textFade {
            0% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
            100% {
                opacity: 0.3;
            }
        }

        /* Close button for transparent effect */
        .transparent-close-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10001;
            width: 50px;
            height: 50px;
            border: 2px solid #34ff35;
            background: rgba(0, 0, 0, 0.7);
            color: #34ff35;
            font-size: 2rem;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.5s ease, transform 0.2s ease, background-color 0.2s ease;
            font-family: 'VT323', monospace;
            text-shadow: 0 0 8px rgba(52, 255, 53, 0.6);
        }

        .transparent-close-btn.visible {
            opacity: 1;
        }

        .transparent-close-btn:hover {
            background: rgba(52, 255, 53, 0.2);
            transform: scale(1.1);
        }
    </style>

    <script type="module">
        // ========================================
        // Firebase Configuration
        // ========================================
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, onValue } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

        // Initialize Firebase with your project credentials
        const firebaseConfig = {
            apiKey: "AIzaSyC9Ga6OROaym45ezFh_vJ2WFMVUACkMGXY",
            authDomain: "imaginecraft-live.firebaseapp.com",
            databaseURL: "https://imaginecraft-live-default-rtdb.firebaseio.com",
            projectId: "imaginecraft-live",
            storageBucket: "imaginecraft-live.firebasestorage.app",
            messagingSenderId: "962150460666",
            appId: "1:962150460666:web:382bff8cdb23c191c16d43"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // ========================================
        // State Management
        // ========================================

        // Remote configuration (loaded from Firebase)
        let remoteConfig = null;

        // Fallback hardcoded defaults (used if config.json fetch fails)
        // Helper functions to get data from remote config only
        function getConfigThoughts() {
            return remoteConfig && remoteConfig.thoughts ? [...remoteConfig.thoughts] : null;
        }
        function getConfigResponses() {
            return remoteConfig && remoteConfig.responses ? [...remoteConfig.responses] : null;
        }
        function getConfigHeroText() {
            return remoteConfig && remoteConfig.heroText ? remoteConfig.heroText : null;
        }
        function getConfigActions() {
            if (remoteConfig && remoteConfig.actions) {
                return remoteConfig.actions.map(a => ({...a}));
            }
            return null;
        }
        function getConfigActiveStates() {
            return remoteConfig && remoteConfig.activeStates ? [...remoteConfig.activeStates] : null;
        }
        function getConfigYesRedirectIndices() {
            return remoteConfig && remoteConfig.yesRedirectIndices ? [...remoteConfig.yesRedirectIndices] : null;
        }
        function getConfigNoRedirectIndices() {
            return remoteConfig && remoteConfig.noRedirectIndices ? [...remoteConfig.noRedirectIndices] : null;
        }
        function getConfigSettings() {
            if (remoteConfig && remoteConfig.settings) {
                return remoteConfig.settings;
            }
            return null;
        }
        function getConfigSecretCommands() {
            if (remoteConfig && remoteConfig.secretCommands) {
                return remoteConfig.secretCommands.map(cmd => ({...cmd}));
            }
            return null;
        }
        function getConfigBuildersMedia() {
            return remoteConfig && remoteConfig.buildersMedia ? {...remoteConfig.buildersMedia} : null;
        }
        function getConfigBootScript() {
            return remoteConfig && remoteConfig.bootScript ? remoteConfig.bootScript : null;
        }

        // Firebase real-time listener for configuration
        let configLoaded = false;
        let configPromise = null;

        // Initialize Firebase listener
        function initializeFirebaseListener() {
            return new Promise((resolve) => {
                const configRef = ref(db, 'siteConfig');
                let timeoutId;

                // Set a 3-second timeout - if Firebase doesn't respond, proceed anyway
                timeoutId = setTimeout(() => {
                    if (!configLoaded) {
                        console.warn('Firebase timeout after 3 seconds - proceeding with defaults');
                        remoteConfig = null;
                        configLoaded = true;
                        resolve();
                    }
                }, 3000);

                onValue(configRef, (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        remoteConfig = data;
                        console.log('Firebase config loaded/updated successfully');

                        // If this is the first load, resolve the promise
                        if (!configLoaded) {
                            clearTimeout(timeoutId);
                            configLoaded = true;
                            resolve();
                        } else {
                            // If config was already loaded, this is an update
                            // Trigger a visual refresh
                            console.log('Config updated in real-time, refreshing site...');
                            location.reload();
                        }
                    } else {
                        console.warn('No config data found in Firebase');
                        remoteConfig = null;
                        if (!configLoaded) {
                            clearTimeout(timeoutId);
                            configLoaded = true;
                            resolve();
                        }
                    }
                }, (error) => {
                    console.error('Firebase listener error:', error);
                    remoteConfig = null;
                    if (!configLoaded) {
                        clearTimeout(timeoutId);
                        configLoaded = true;
                        resolve();
                    }
                });
            });
        }

        // Start Firebase listener immediately
        configPromise = initializeFirebaseListener();

        // Load data from config only (no localStorage)
        function loadThoughts() {
            return getConfigThoughts();
        }

        function loadResponses() {
            return getConfigResponses();
        }

        function loadHeroText() {
            return getConfigHeroText();
        }

        function loadActions() {
            return getConfigActions();
        }

        function loadActiveStates() {
            return getConfigActiveStates();
        }

        function loadYesRedirectIndices() {
            return getConfigYesRedirectIndices();
        }

        function loadNoRedirectIndices() {
            return getConfigNoRedirectIndices();
        }

        function loadRandomizeEnabled() {
            const settings = getConfigSettings();
            return settings ? (settings.randomizeEnabled || false) : false;
        }

        function loadBootSequenceEnabled() {
            const settings = getConfigSettings();
            return settings ? (settings.bootSequenceEnabled !== undefined ? settings.bootSequenceEnabled : true) : true;
        }

        function loadBootScript() {
            const bootScript = getConfigBootScript();
            // Default boot script if none in config
            const defaultBootScript = 'CORE_INIT: OK\nMEM_LOAD: 1024KB\nDRV_MOUNT: /assets\nNET_STACK: READY\nSYS_CHECK: COMPLETE';
            return bootScript || defaultBootScript;
        }

        function loadBackgroundImageUrl() {
            return remoteConfig && remoteConfig.backgroundImageUrl ? remoteConfig.backgroundImageUrl : '';
        }

        function loadIntermissionImageUrl() {
            return remoteConfig && remoteConfig.intermissionImageUrl ? remoteConfig.intermissionImageUrl : 'https://placehold.co/1920x1080/333/999?text=IMAGE+PENDING';
        }

        function loadTechDifficultyImageUrl() {
            return remoteConfig && remoteConfig.techDifficultyImageUrl ? remoteConfig.techDifficultyImageUrl : 'https://placehold.co/1920x1080/333/999?text=IMAGE+PENDING';
        }

        function loadFinImageUrl() {
            return remoteConfig && remoteConfig.finImageUrl ? remoteConfig.finImageUrl : 'https://placehold.co/1920x1080/333/999?text=IMAGE+PENDING';
        }

        function loadMeltdownMessage() {
            return remoteConfig && remoteConfig.meltdownMessage ? remoteConfig.meltdownMessage : 'CRITICAL SYSTEM FAILURE - INITIATING EMERGENCY SHUTDOWN';
        }

        function loadMeltdownAudioURL() {
            return remoteConfig && remoteConfig.meltdownAudioURL ? remoteConfig.meltdownAudioURL : '';
        }

        // Background image loading state
        let backgroundImageReady = false;
        let backgroundImageLoadPromise = null;

        // Load the opening background image with 3-second timeout
        function loadOpeningBackgroundImage() {
            const backgroundImageUrl = loadBackgroundImageUrl();
            const openingBackground = document.getElementById('openingBackground');
            const openingBackgroundImage = document.getElementById('openingBackgroundImage');

            if (!backgroundImageUrl || !openingBackground || !openingBackgroundImage) {
                console.log('No background image URL configured or elements not found');
                backgroundImageReady = true;
                return Promise.resolve();
            }

            console.log('Loading background image:', backgroundImageUrl);

            backgroundImageLoadPromise = new Promise((resolve) => {
                let imageLoaded = false;
                let timeoutId;

                // Set 3-second timeout
                timeoutId = setTimeout(() => {
                    if (!imageLoaded) {
                        console.warn('Background image load timeout after 3 seconds - proceeding anyway');
                        imageLoaded = true;
                        backgroundImageReady = true;

                        // Fallback: Ensure boot overlay is removed 1 second after timeout
                        setTimeout(() => {
                            const bootOverlay = document.getElementById('bootSequenceOverlay');
                            if (bootOverlay) {
                                bootOverlay.style.display = 'none';
                                console.log('Fallback: Boot overlay forcibly hidden after image timeout');
                            }
                        }, 1000);

                        resolve();
                    }
                }, 3000);

                // Load the image
                openingBackgroundImage.onload = () => {
                    if (!imageLoaded) {
                        console.log('Background image loaded successfully');
                        clearTimeout(timeoutId);
                        imageLoaded = true;
                        backgroundImageReady = true;
                        // Don't show yet - will be revealed when boot overlay fades

                        // Fallback: Ensure boot overlay is removed 1 second after image loads
                        // This guarantees the black screen vanishes even if message channel fails
                        setTimeout(() => {
                            const bootOverlay = document.getElementById('bootSequenceOverlay');
                            if (bootOverlay) {
                                bootOverlay.style.display = 'none';
                                console.log('Fallback: Boot overlay forcibly hidden after image load');
                            }
                        }, 1000);

                        resolve();
                    }
                };

                openingBackgroundImage.onerror = () => {
                    if (!imageLoaded) {
                        console.warn('Background image failed to load');
                        clearTimeout(timeoutId);
                        imageLoaded = true;
                        backgroundImageReady = true;

                        // Fallback: Ensure boot overlay is removed 1 second after error
                        setTimeout(() => {
                            const bootOverlay = document.getElementById('bootSequenceOverlay');
                            if (bootOverlay) {
                                bootOverlay.style.display = 'none';
                                console.log('Fallback: Boot overlay forcibly hidden after image error');
                            }
                        }, 1000);

                        resolve();
                    }
                };

                // Start loading
                openingBackgroundImage.src = backgroundImageUrl;
            });

            return backgroundImageLoadPromise;
        }

        // Check if boot sequence has already played this session
        function hasBootSequencePlayedThisSession() {
            try {
                return sessionStorage.getItem('imaginecraft_boot_sequence_played') === 'true';
            } catch (e) {
                return false;
            }
        }

        // Mark boot sequence as played for this session
        function markBootSequencePlayed() {
            try {
                sessionStorage.setItem('imaginecraft_boot_sequence_played', 'true');
            } catch (e) {
                console.warn('Failed to mark boot sequence as played:', e);
            }
        }

        // ========================================
        // Cinematic State Overlays
        // ========================================

        // Initialize cinematic overlay images from Firebase config
        function initializeCinematicOverlays() {
            const intermissionImageUrl = loadIntermissionImageUrl();
            const techDifficultyImageUrl = loadTechDifficultyImageUrl();
            const finImageUrl = loadFinImageUrl();

            const intermissionImage = document.getElementById('intermissionImage');
            const techDifficultyImage = document.getElementById('techDifficultyImage');
            const finImage = document.getElementById('finImage');

            if (intermissionImage) intermissionImage.src = intermissionImageUrl;
            if (techDifficultyImage) techDifficultyImage.src = techDifficultyImageUrl;
            if (finImage) finImage.src = finImageUrl;

            console.log('Cinematic overlays initialized:', {
                intermissionImageUrl,
                techDifficultyImageUrl,
                finImageUrl
            });
        }

        // Show intermission overlay
        function showIntermissionOverlay() {
            const overlay = document.getElementById('intermissionOverlay');
            if (overlay) {
                overlay.classList.add('active');
                overlay.style.display = 'flex';
                console.log('Intermission overlay shown');
            }
        }

        // Hide intermission overlay
        function hideIntermissionOverlay() {
            const overlay = document.getElementById('intermissionOverlay');
            if (overlay) {
                overlay.classList.remove('active');
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 1000); // Wait for fade out transition
                console.log('Intermission overlay hidden');
            }
        }

        // Show technical difficulty overlay
        function showTechDifficultyOverlay() {
            const overlay = document.getElementById('techDifficultyOverlay');
            if (overlay) {
                overlay.classList.add('active');
                overlay.style.display = 'flex';
                console.log('Technical Difficulty overlay shown');
            }
        }

        // Hide technical difficulty overlay
        function hideTechDifficultyOverlay() {
            const overlay = document.getElementById('techDifficultyOverlay');
            if (overlay) {
                overlay.classList.remove('active');
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 1000); // Wait for fade out transition
                console.log('Technical Difficulty overlay hidden');
            }
        }

        // Show fin overlay
        function showFinOverlay() {
            const overlay = document.getElementById('finOverlay');
            if (overlay) {
                overlay.classList.add('active');
                overlay.style.display = 'flex';
                console.log('Fin overlay shown');
            }
        }

        // Hide fin overlay
        function hideFinOverlay() {
            const overlay = document.getElementById('finOverlay');
            if (overlay) {
                overlay.classList.remove('active');
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 1000); // Wait for fade out transition
                console.log('Fin overlay hidden');
            }
        }

        // Track terminal error (for tech difficulty overlay)
        function trackTerminalError() {
            state.consecutiveErrors++;
            console.log('Terminal error tracked. Consecutive errors:', state.consecutiveErrors);

            if (state.consecutiveErrors >= 3) {
                console.log('3 consecutive errors detected! Triggering tech difficulty overlay.');
                showTechDifficultyOverlay();
                // Reset error counter
                state.consecutiveErrors = 0;
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    hideTechDifficultyOverlay();
                }, 5000);
            }
        }

        // Reset error counter (when user has successful interaction)
        function resetTerminalErrors() {
            state.consecutiveErrors = 0;
        }

        // Track user activity (for intermission overlay)
        function trackUserActivity() {
            state.lastActivityTime = Date.now();

            // Clear existing inactivity timeout
            if (state.inactivityTimeout) {
                clearTimeout(state.inactivityTimeout);
            }

            // Set new 120-second inactivity timeout
            state.inactivityTimeout = setTimeout(() => {
                console.log('120 seconds of inactivity detected! Triggering intermission overlay.');
                showIntermissionOverlay();
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    hideIntermissionOverlay();
                    // Restart inactivity tracking
                    trackUserActivity();
                }, 10000);
            }, 120000); // 120 seconds = 2 minutes
        }

        // These will be initialized after config loads
        let bootSequenceEnabled = true; // Placeholder
        let systemMood = 'stable'; // Placeholder
        let secretCommands = []; // Placeholder

        function loadSystemMood() {
            const settings = getConfigSettings();
            return settings && settings.systemMood ? settings.systemMood : 'stable';
        }

        // ========================================
        // Secret Commands System
        // ========================================

        function loadSecretCommands() {
            return getConfigSecretCommands() || [];
        }

        // Function to initialize config-dependent values
        function initializeConfigDependentValues() {
            bootSequenceEnabled = loadBootSequenceEnabled();
            systemMood = loadSystemMood();
            secretCommands = loadSecretCommands();
            meltdownMessage = loadMeltdownMessage();
            meltdownAudioURL = loadMeltdownAudioURL();
        }


        // Keystroke buffer for command detection
        let keystrokeBuffer = '';
        const maxBufferSize = 20; // Maximum characters to track
        let matrixToggleState = false; // Track matrix toggle state

        let meltdownMessage = '';
        let meltdownAudioURL = '';

        // Secret command visual feedback
        function showCommandFeedback() {
            const explorePage = document.querySelector('.explore-page');
            if (explorePage) {
                explorePage.classList.add('secret-command-activated');
                // Remove the class after animation completes
                setTimeout(() => {
                    explorePage.classList.remove('secret-command-activated');
                }, 600);
            }
        }

        // Execute secret command action
        function executeSecretCommand(command) {
            showCommandFeedback();

            switch (command.action) {
                case 'earthquake':
                    triggerSecretEarthquake();
                    break;
                case 'matrix':
                    toggleMatrixAnimation();
                    break;
                case 'warp':
                    triggerWarpAnimation();
                    break;
                case 'transparent':
                    triggerTransparentAnimation();
                    break;
                case 'redirect':
                    if (command.url) {
                        setTimeout(() => {
                            window.location.href = command.url;
                        }, 400);
                    }
                    break;
                case 'custom':
                    // For future custom actions
                    if (command.customFunction) {
                        try {
                            eval(command.customFunction);
                        } catch (e) {
                            console.warn('Failed to execute custom command:', e);
                        }
                    }
                    break;
            }
        }

        // Execute meltdown sequence
        function executeMeltdown() {
            console.log('MELTDOWN TRIGGERED!');

            // Stop all animations and input immediately
            state.isUserTyping = true;
            state.isSelected = true;
            state.isAnimating = false;
            stopCycling();

            // Clear any existing timeouts
            if (state.animationTimeout) clearTimeout(state.animationTimeout);
            if (state.cycleTimeout) clearTimeout(state.cycleTimeout);
            if (state.idleTimeout) clearTimeout(state.idleTimeout);

            // Hide cursor
            const cursorElement = document.getElementById('cursor');
            if (cursorElement) {
                cursorElement.classList.remove('visible');
            }

            // Hide choice buttons if visible
            const choiceContainer = document.querySelector('.choice-buttons-container');
            if (choiceContainer) {
                choiceContainer.style.display = 'none';
            }

            // Clear thought element and prepare for meltdown message
            const thoughtElement = document.getElementById('thought');
            thoughtElement.classList.remove('fade-out', 'fade-in');
            thoughtElement.classList.add('visible', 'meltdown-text');
            thoughtElement.textContent = '';

            // Rapidly type the meltdown message in red
            let charIndex = 0;
            const typingSpeed = 20; // Very fast typing (20ms per character)

            function typeMeltdownChar() {
                if (charIndex < meltdownMessage.length) {
                    thoughtElement.textContent += meltdownMessage[charIndex];
                    charIndex++;
                    setTimeout(typeMeltdownChar, typingSpeed);
                } else {
                    // After message is typed, trigger pixel melt
                    setTimeout(() => {
                        triggerPixelMelt();
                    }, 500);
                }
            }

            typeMeltdownChar();
        }

        // Trigger pixel melt animation and display overlay
        function triggerPixelMelt() {
            const explorePage = document.querySelector('.explore-page');
            const thoughtElement = document.getElementById('thought');

            // Add melt animation class
            if (explorePage) {
                explorePage.classList.add('pixel-melt');
            }
            if (thoughtElement) {
                thoughtElement.classList.add('pixel-melt');
            }

            // Wait for melt animation to complete (1 second)
            setTimeout(() => {
                // Show tech difficulty overlay
                const overlay = document.getElementById('techDifficultyOverlay');
                if (overlay) {
                    overlay.classList.add('active');
                    overlay.style.display = 'flex';
                }

                // Play meltdown audio if URL is provided
                if (meltdownAudioURL) {
                    const audio = new Audio(meltdownAudioURL);
                    audio.volume = 0.5;
                    audio.play().catch(e => console.warn('Failed to play meltdown audio:', e));
                }

                // Auto-refresh page after 10 seconds
                setTimeout(() => {
                    location.reload();
                }, 10000);
            }, 1000);
        }

        // Trigger earthquake without navigation (for secret command)
        function triggerSecretEarthquake() {
            const explorePage = document.querySelector('.explore-page');
            const terminalOverlay = document.getElementById('terminalOverlay');
            const background = document.getElementById('mainSiteBackground');
            const iframe = document.getElementById('mainSiteFrame');

            // Load main site if not already loaded
            if (iframe && !iframe.src) {
                iframe.src = 'main.html';
            }

            // Show background
            if (background) {
                background.classList.add('active');
            }

            // Apply quake time
            const actualQuakeTime = applyQuakeTimeVariable();
            const durationMs = actualQuakeTime * 1000;

            // Phase 1: Earthquake shake
            explorePage.classList.add('earthquake-shake');

            // After shake, split the terminal
            setTimeout(() => {
                terminalOverlay.classList.add('active');
                explorePage.style.visibility = 'hidden';

                setTimeout(() => {
                    terminalOverlay.classList.add('splitting');

                    // Navigate after split
                    setTimeout(() => {
                        window.location.href = 'main.html';
                    }, 800);
                }, 50);
            }, durationMs);
        }

        // Toggle matrix animation on/off
        function toggleMatrixAnimation() {
            if (state.matrixActive) {
                // Matrix is running - stop it
                const canvas = document.getElementById('matrixCanvas');
                if (canvas) {
                    canvas.classList.add('fade-out');
                    setTimeout(() => {
                        canvas.classList.remove('active', 'fade-out');
                        state.matrixActive = false;
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }, 500);
                }
            } else {
                // Start infinite matrix (not timed)
                triggerInfiniteMatrix();
            }
        }

        // Trigger matrix animation that runs until toggled off
        function triggerInfiniteMatrix() {
            if (state.matrixActive) return;

            state.matrixActive = true;
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.classList.remove('fade-out');
            canvas.classList.add('active');

            const fontSize = 14;
            const columns = Math.floor(canvas.width / fontSize);
            const drops = Array(columns).fill(1);

            function draw() {
                if (!state.matrixActive) return;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#34ff35';
                ctx.font = fontSize + 'px VT323, monospace';
                ctx.shadowColor = 'rgba(52, 255, 53, 0.5)';
                ctx.shadowBlur = 4;

                for (let i = 0; i < drops.length; i++) {
                    const char = Math.random() > 0.5 ? '1' : '0';
                    ctx.fillText(char, i * fontSize, drops[i] * fontSize);

                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }

                state.matrixAnimationId = requestAnimationFrame(draw);
            }

            draw();
        }

        // Trigger Star Wars style warp/hyperspace animation
        function triggerWarpAnimation() {
            // Create warp container
            const warpContainer = document.createElement('div');
            warpContainer.id = 'warpContainer';
            warpContainer.className = 'warp-container';
            document.body.appendChild(warpContainer);

            // Create canvas for starfield
            const canvas = document.createElement('canvas');
            canvas.id = 'warpCanvas';
            canvas.className = 'warp-canvas';
            warpContainer.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Star properties
            const stars = [];
            const numStars = 400;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Initialize stars at random positions
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width - centerX,
                    y: Math.random() * canvas.height - centerY,
                    z: Math.random() * 1500 + 500,
                    speed: Math.random() * 2 + 1
                });
            }

            let animationId;
            let startTime = Date.now();
            const warpDuration = 3000; // 3 seconds of warping

            function drawStars() {
                const elapsed = Date.now() - startTime;

                // Clear with fade trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Calculate warp intensity (accelerates over time)
                const progress = Math.min(elapsed / warpDuration, 1);
                const warpSpeed = 20 + (progress * 80); // Accelerate from 20 to 100

                for (let i = 0; i < stars.length; i++) {
                    const star = stars[i];

                    // Move star toward viewer
                    star.z -= warpSpeed * star.speed;

                    // Reset star if it passes the viewer
                    if (star.z <= 0) {
                        star.x = Math.random() * canvas.width - centerX;
                        star.y = Math.random() * canvas.height - centerY;
                        star.z = 1500;
                        star.speed = Math.random() * 2 + 1;
                    }

                    // Project 3D position to 2D
                    const scale = 500 / star.z;
                    const x2d = star.x * scale + centerX;
                    const y2d = star.y * scale + centerY;

                    // Calculate previous position for streak
                    const prevZ = star.z + warpSpeed * star.speed;
                    const prevScale = 500 / prevZ;
                    const prevX = star.x * prevScale + centerX;
                    const prevY = star.y * prevScale + centerY;

                    // Draw star streak (line from previous to current position)
                    const streakLength = Math.min(1, progress * 2); // Streaks grow with warp
                    const brightness = Math.min(255, 100 + (1500 - star.z) / 5);

                    ctx.beginPath();
                    ctx.moveTo(prevX, prevY);
                    ctx.lineTo(x2d, y2d);
                    ctx.strokeStyle = `rgba(${brightness}, ${brightness}, ${Math.min(255, brightness + 50)}, ${0.5 + streakLength * 0.5})`;
                    ctx.lineWidth = 1 + scale * 2 * streakLength;
                    ctx.stroke();

                    // Draw bright point at end of streak
                    ctx.beginPath();
                    ctx.arc(x2d, y2d, Math.max(0.5, scale * 1.5), 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 + streakLength * 0.2})`;
                    ctx.fill();
                }

                // Continue animation or transition to galaxy
                if (elapsed < warpDuration) {
                    animationId = requestAnimationFrame(drawStars);
                } else {
                    // Warp complete - show galaxy reveal
                    cancelAnimationFrame(animationId);
                    showGalaxyReveal(warpContainer);
                }
            }

            // Start warp animation
            warpContainer.classList.add('active');
            drawStars();
        }

        // Show galaxy image after warp
        function showGalaxyReveal(warpContainer) {
            // Create galaxy container
            const galaxyDiv = document.createElement('div');
            galaxyDiv.className = 'galaxy-reveal';

            // Placeholder galaxy image (colorful nebula/galaxy)
            galaxyDiv.innerHTML = `
                <div class="galaxy-content">
                    <div class="galaxy-placeholder">
                        <div class="galaxy-stars"></div>
                        <div class="galaxy-nebula"></div>
                        <div class="galaxy-center"></div>
                    </div>
                    <p class="galaxy-text">Destination: Unknown Galaxy</p>
                </div>
            `;

            warpContainer.appendChild(galaxyDiv);

            // Fade out canvas, fade in galaxy
            const canvas = warpContainer.querySelector('.warp-canvas');
            canvas.classList.add('fade-out');

            setTimeout(() => {
                galaxyDiv.classList.add('visible');
            }, 100);

            // Auto-close after viewing
            setTimeout(() => {
                warpContainer.classList.add('closing');
                setTimeout(() => {
                    warpContainer.remove();
                }, 1000);
            }, 4000);
        }

        function loadBuildersMedia() {
            return getConfigBuildersMedia() || { type: 'image', url: '' };
        }

        // Trigger Transparent animation - reveals builders behind the terminal
        function triggerTransparentAnimation() {
            const buildersMedia = loadBuildersMedia();

            // Create builders background container
            const buildersContainer = document.createElement('div');
            buildersContainer.id = 'buildersContainer';
            buildersContainer.className = 'builders-container';

            // Add media content (image or video)
            if (buildersMedia.url) {
                if (buildersMedia.type === 'video') {
                    buildersContainer.innerHTML = `
                        <video class="builders-media" autoplay loop muted playsinline>
                            <source src="${buildersMedia.url}" type="video/mp4">
                        </video>
                    `;
                } else {
                    buildersContainer.innerHTML = `
                        <img class="builders-media" src="${buildersMedia.url}" alt="Construction Crew">
                    `;
                }
            } else {
                // Placeholder if no URL set - CSS animated construction scene
                buildersContainer.innerHTML = `
                    <div class="builders-placeholder">
                        <div class="builder builder-1">
                            <div class="builder-body"></div>
                            <div class="hammer"></div>
                        </div>
                        <div class="builder builder-2">
                            <div class="builder-body"></div>
                            <div class="hammer"></div>
                        </div>
                        <div class="scaffold"></div>
                        <div class="scaffold scaffold-2"></div>
                        <p class="builders-text">UNDER CONSTRUCTION</p>
                    </div>
                `;
            }

            // Insert builders behind the terminal
            document.body.insertBefore(buildersContainer, document.body.firstChild);

            // Get terminal elements
            const explorePage = document.querySelector('.explore-page');
            const bootOverlay = document.getElementById('bootSequenceOverlay');

            // Add close button overlay
            const closeBtn = document.createElement('button');
            closeBtn.className = 'transparent-close-btn';
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = () => closeTransparentEffect(buildersContainer, explorePage, closeBtn);
            document.body.appendChild(closeBtn);

            // Trigger fade animation
            requestAnimationFrame(() => {
                buildersContainer.classList.add('active');
                explorePage.classList.add('transparent-fade');
                if (bootOverlay) {
                    bootOverlay.style.display = 'none';
                }
                closeBtn.classList.add('visible');
            });
        }

        // Close transparent effect
        function closeTransparentEffect(buildersContainer, explorePage, closeBtn) {
            explorePage.classList.remove('transparent-fade');
            closeBtn.classList.remove('visible');

            setTimeout(() => {
                buildersContainer.remove();
                closeBtn.remove();
            }, 1000);
        }

        // Check keystroke buffer for matching commands
        function checkSecretCommands() {
            const buffer = keystrokeBuffer.toUpperCase();

            for (const command of secretCommands) {
                if (!command.enabled) continue;

                const keyword = command.keyword.toUpperCase();
                if (buffer.endsWith(keyword)) {
                    // Command matched! Clear buffer and execute
                    keystrokeBuffer = '';
                    executeSecretCommand(command);
                    return true;
                }
            }
            return false;
        }


        // Global keydown listener for secret commands
        document.addEventListener('keydown', (event) => {
            // Track user activity for inactivity detection
            trackUserActivity();

            // Only track printable characters
            if (event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {
                keystrokeBuffer += event.key;

                // Trim buffer if too long
                if (keystrokeBuffer.length > maxBufferSize) {
                    keystrokeBuffer = keystrokeBuffer.slice(-maxBufferSize);
                }

                // Check for command matches
                const commandMatched = checkSecretCommands();
                if (commandMatched) {
                    // Reset error counter on successful command
                    resetTerminalErrors();
                    return;
                }

            }
        });

        // Fisher-Yates shuffle algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // These will be initialized after config loads
        let allThoughts = [];
        let allResponses = [];
        let heroText = '';
        let actions = [];
        let activeStates = [];
        let randomizeEnabled = false;
        let activeIndices = [];
        let thoughts = [];
        let responses = [];
        let allYesRedirectIndices = [];
        let allNoRedirectIndices = [];
        let yesRedirectIndices = [];
        let noRedirectIndices = [];

        // Function to load and process thoughts/responses data
        function initializeContentData() {
            allThoughts = loadThoughts();
            allResponses = loadResponses();
            heroText = loadHeroText();
            actions = loadActions();
            activeStates = loadActiveStates();
            allYesRedirectIndices = loadYesRedirectIndices();
            allNoRedirectIndices = loadNoRedirectIndices();
            randomizeEnabled = loadRandomizeEnabled();

            // Comprehensive null checks - ensure ALL data exists before processing
            if (!allThoughts || !allResponses || !heroText || !activeStates || !allYesRedirectIndices || !allNoRedirectIndices) {
                console.warn('Config not loaded from Firebase, showing initialization state');
                allThoughts = ['System Initializing...'];
                allResponses = ['No configuration data found. Please contact the administrator.'];
                heroText = 'SYSTEM INITIALIZING...';
                actions = [{ type: 'none', url: '', logo: '', linkText: 'Click here' }];
                activeStates = [true];
                allYesRedirectIndices = [''];
                allNoRedirectIndices = [''];
                randomizeEnabled = false;
            }

            // Additional safety check: ensure arrays have valid length
            if (!Array.isArray(allThoughts) || allThoughts.length === 0) {
                console.error('Invalid thoughts data, using fallback');
                allThoughts = ['System Offline'];
                allResponses = ['Unable to load content. Please try again later.'];
                heroText = 'SYSTEM OFFLINE';
                actions = [{ type: 'none', url: '', logo: '', linkText: 'Click here' }];
                activeStates = [true];
                allYesRedirectIndices = [''];
                allNoRedirectIndices = [''];
                randomizeEnabled = false;
            }

            // Reset arrays
            activeIndices = [];
            thoughts = [];
            responses = [];
            yesRedirectIndices = [];
            noRedirectIndices = [];

            // Filter to only include active thoughts and track their original indices
            for (let i = 0; i < allThoughts.length; i++) {
                // Default to active if no state is set
                if (activeStates[i] !== false) {
                    activeIndices.push(i);
                    thoughts.push(allThoughts[i]);
                    responses.push(allResponses[i]);
                    yesRedirectIndices.push(allYesRedirectIndices[i] || '');
                    noRedirectIndices.push(allNoRedirectIndices[i] || '');
                }
            }

            // Apply randomization if enabled
            if (randomizeEnabled && activeIndices.length > 0) {
                // Create array of indices into the active arrays
                const indices = activeIndices.map((_, idx) => idx);

                // Shuffle the indices
                const shuffledIndices = shuffleArray(indices);

                // Take up to 3 (or fewer if not enough active questions)
                const selectedCount = Math.min(3, shuffledIndices.length);
                const selectedIndices = shuffledIndices.slice(0, selectedCount);

                // Rebuild arrays with only the selected items
                const newActiveIndices = [];
                const newThoughts = [];
                const newResponses = [];
                const newYesRedirectIndices = [];
                const newNoRedirectIndices = [];

                for (const idx of selectedIndices) {
                    newActiveIndices.push(activeIndices[idx]);
                    newThoughts.push(thoughts[idx]);
                    newResponses.push(responses[idx]);
                    newYesRedirectIndices.push(yesRedirectIndices[idx]);
                    newNoRedirectIndices.push(noRedirectIndices[idx]);
                }

                activeIndices = newActiveIndices;
                thoughts = newThoughts;
                responses = newResponses;
                yesRedirectIndices = newYesRedirectIndices;
                noRedirectIndices = newNoRedirectIndices;
            }

        }

        function loadMatrixFadeDuration() {
            const settings = getConfigSettings();
            return settings && settings.matrixFadeDuration ? settings.matrixFadeDuration : 1.5;
        }

        let matrixFadeDuration = 1.5; // Placeholder

        function loadEarthquakeDuration() {
            const settings = getConfigSettings();
            return settings && settings.earthquakeDuration ? settings.earthquakeDuration : 1.5;
        }

        let earthquakeDuration = 1.5; // Placeholder

        function loadCurtainDuration() {
            const settings = getConfigSettings();
            return settings && settings.curtainDuration ? settings.curtainDuration : 4;
        }

        let curtainDuration = 4; // Placeholder

        function loadChoiceButtonsEnabled() {
            const settings = getConfigSettings();
            return settings && settings.choiceButtonsEnabled !== undefined ? settings.choiceButtonsEnabled : false;
        }

        let choiceButtonsEnabled = false; // Placeholder

        // Function to initialize settings after config loads
        function initializeSettings() {
            matrixFadeDuration = loadMatrixFadeDuration();
            earthquakeDuration = loadEarthquakeDuration();
            curtainDuration = loadCurtainDuration();
            choiceButtonsEnabled = loadChoiceButtonsEnabled();
        }

        let state = {
            currentIndex: 0,
            isUserTyping: false,
            isSelected: false,
            selectedIndex: null,
            cycleTimeout: null,
            animationTimeout: null,
            idleTimeout: null,        // Timeout for auto-cycling when no choice is made
            isAnimating: false,
            currentText: '',
            targetText: '',
            matrixActive: false,
            matrixAnimationId: null,
            waitingForChoice: false,  // Whether we're waiting for Yes/No button click
            heroTyped: false,         // Whether the hero text has been typed
            currentAudio: null,       // Pre-loaded audio object for manual playback
            capturingName: false,     // Whether we're capturing user's name
            userName: '',             // Global variable to store captured user name
            consecutiveErrors: 0,     // Track consecutive terminal errors for tech difficulty overlay
            inactivityTimeout: null,  // Timeout for 120s inactivity detection
            lastActivityTime: Date.now() // Track last user activity
        };

        function loadTypingSpeed() {
            const settings = getConfigSettings();
            return settings && settings.typingSpeed ? settings.typingSpeed : 150;
        }

        const baseTypingSpeed = loadTypingSpeed();

        // Timing configuration (in ms) - uses admin-configurable base speed
        // Adjusted based on system mood
        function getTimingConfig() {
            const base = {
                initialDelay: 3000,
                typeSpeedMin: Math.max(50, baseTypingSpeed - 50),
                typeSpeedMax: baseTypingSpeed + 100,
                punctuationPause: 500,
                backspaceSpeedMin: 50,
                backspaceSpeedMax: 100,
                linger: 4000
            };

            switch (systemMood) {
                case 'glitchy':
                    // Glitchy: More irregular, stuttered rhythm with wider variance
                    return {
                        ...base,
                        typeSpeedMin: Math.max(30, baseTypingSpeed - 100),
                        typeSpeedMax: baseTypingSpeed + 200, // Wider range for irregular feel
                        punctuationPause: Math.random() > 0.5 ? 800 : 200, // Random pauses
                        backspaceSpeedMin: 30,
                        backspaceSpeedMax: 150,
                        linger: 3000
                    };
                case 'urgent':
                    // Urgent: Much faster typing
                    return {
                        ...base,
                        initialDelay: 1500, // Faster start
                        typeSpeedMin: Math.max(20, Math.floor(baseTypingSpeed * 0.3)),
                        typeSpeedMax: Math.floor(baseTypingSpeed * 0.5),
                        punctuationPause: 150, // Minimal pause
                        backspaceSpeedMin: 20,
                        backspaceSpeedMax: 50,
                        linger: 2000 // Shorter linger
                    };
                default: // 'stable'
                    return base;
            }
        }

        const timing = getTimingConfig();

        // Helper function for random delay between min and max
        function randomDelay(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Check if character is punctuation
        function isPunctuation(char) {
            return ['.', ',', '!', '?', ';', ':'].includes(char);
        }

        // Check for reduced motion preference
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        // ========================================
        // DOM Elements
        // ========================================
        const thoughtElement = document.getElementById('currentThought');
        const inputElement = document.getElementById('exploreInput');
        const panelsContainer = document.getElementById('explorePanels');
        const cursorElement = document.getElementById('exploreCursor');
        const choiceButtonsContainer = document.getElementById('choiceButtonsContainer');
        const choiceBtnYes = document.getElementById('choiceBtnYes');
        const choiceBtnNo = document.getElementById('choiceBtnNo');
        const heroElement = document.getElementById('exploreQuestion');

        // ========================================
        // Typing Animation
        // ========================================

        // Glitchy mode typing helper - occasionally repeats or stutters
        function getGlitchyDelay(baseMin, baseMax) {
            // 15% chance of a glitch effect
            if (Math.random() < 0.15) {
                const glitchType = Math.random();
                if (glitchType < 0.3) {
                    // Very fast burst
                    return randomDelay(10, 30);
                } else if (glitchType < 0.6) {
                    // Long stutter pause
                    return randomDelay(300, 600);
                } else {
                    // Normal with jitter
                    return randomDelay(baseMin, baseMax) + (Math.random() > 0.5 ? 100 : -30);
                }
            }
            return randomDelay(baseMin, baseMax);
        }

        // Helper function to parse text with {backspace} syntax
        // Returns array of segments: { type: 'regular'|'backspace', text: string }
        function parseBackspaceSegments(text) {
            const segments = [];
            let currentPos = 0;
            const regex = /\{([^}]+)\}/g;
            let match;

            while ((match = regex.exec(text)) !== null) {
                // Add regular text before the match
                if (match.index > currentPos) {
                    segments.push({
                        type: 'regular',
                        text: text.substring(currentPos, match.index)
                    });
                }

                // Add backspace segment
                segments.push({
                    type: 'backspace',
                    text: match[1]
                });

                currentPos = regex.lastIndex;
            }

            // Add remaining text
            if (currentPos < text.length) {
                segments.push({
                    type: 'regular',
                    text: text.substring(currentPos)
                });
            }

            return segments;
        }

        // Helper function to replace {{name}} placeholder with user's name
        function replaceName(text) {
            if (!text.includes('{{name}}')) return text;

            const userName = sessionStorage.getItem('imaginecraft_user_name');
            const replacement = userName || 'friend';

            return text.replace(/\{\{name\}\}/g, replacement);
        }

        // Helper function to strip backspace syntax from text for direct display
        // Removes {text} portions to show the final intended text
        function stripBackspaceSyntax(text) {
            // Replace {text} with empty string to show only the final text
            return text.replace(/\{[^}]+\}/g, '');
        }

        // Helper function to process segments and type them with backspace effects
        function typeWithBackspaceEffect(segments, segmentIndex, charIndex, callback) {
            if (state.isUserTyping || state.isSelected) return;

            // If we've processed all segments, call the callback
            if (segmentIndex >= segments.length) {
                if (callback) callback();
                return;
            }

            const segment = segments[segmentIndex];

            if (segment.type === 'regular') {
                // Type regular text character by character
                if (charIndex < segment.text.length) {
                    state.currentText += segment.text[charIndex];
                    thoughtElement.textContent = state.currentText;

                    // Calculate delay - longer after punctuation, variable otherwise
                    let delay = 0;
                    if (!prefersReducedMotion) {
                        const currentChar = segment.text[charIndex];
                        if (isPunctuation(currentChar)) {
                            delay = systemMood === 'glitchy'
                                ? (Math.random() > 0.5 ? timing.punctuationPause * 1.5 : timing.punctuationPause * 0.3)
                                : timing.punctuationPause;
                        } else {
                            delay = systemMood === 'glitchy'
                                ? getGlitchyDelay(timing.typeSpeedMin, timing.typeSpeedMax)
                                : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                        }
                    }

                    state.animationTimeout = setTimeout(() => {
                        typeWithBackspaceEffect(segments, segmentIndex, charIndex + 1, callback);
                    }, delay);
                } else {
                    // Move to next segment
                    typeWithBackspaceEffect(segments, segmentIndex + 1, 0, callback);
                }
            } else if (segment.type === 'backspace') {
                // Type the mistake, pause, then backspace it
                if (charIndex < segment.text.length) {
                    // Typing the mistake
                    state.currentText += segment.text[charIndex];
                    thoughtElement.textContent = state.currentText;

                    let delay = 0;
                    if (!prefersReducedMotion) {
                        delay = systemMood === 'glitchy'
                            ? getGlitchyDelay(timing.typeSpeedMin, timing.typeSpeedMax)
                            : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                    }

                    state.animationTimeout = setTimeout(() => {
                        typeWithBackspaceEffect(segments, segmentIndex, charIndex + 1, callback);
                    }, delay);
                } else {
                    // Finished typing the mistake, now pause and backspace
                    const mistakeLength = segment.text.length;

                    state.animationTimeout = setTimeout(() => {
                        // Backspace the mistake character by character (faster than typing)
                        backspaceNCharacters(mistakeLength, () => {
                            // Move to next segment after backspacing
                            typeWithBackspaceEffect(segments, segmentIndex + 1, 0, callback);
                        });
                    }, 500); // 500ms pause before backspacing
                }
            }
        }

        // Helper function to backspace N characters quickly
        function backspaceNCharacters(count, callback) {
            if (state.isUserTyping || state.isSelected) return;

            if (count > 0 && state.currentText.length > 0) {
                state.currentText = state.currentText.substring(0, state.currentText.length - 1);
                thoughtElement.textContent = state.currentText;

                // Backspace is faster than typing
                const delay = prefersReducedMotion ? 0 : randomDelay(timing.backspaceSpeedMin, timing.backspaceSpeedMax);

                state.animationTimeout = setTimeout(() => {
                    backspaceNCharacters(count - 1, callback);
                }, delay);
            } else {
                if (callback) callback();
            }
        }

        function typeCharacter(text, index, callback) {
            if (state.isUserTyping || state.isSelected) return;

            // Check if text contains backspace syntax
            if (text.includes('{')) {
                // Parse and type with backspace effect
                const segments = parseBackspaceSegments(text);
                state.currentText = ''; // Reset current text
                typeWithBackspaceEffect(segments, 0, 0, callback);
            } else {
                // Original typing logic for text without backspace syntax
                if (index <= text.length) {
                    state.currentText = text.substring(0, index);
                    thoughtElement.textContent = state.currentText;

                    // Calculate delay - longer after punctuation, variable otherwise
                    let delay = 0;
                    if (!prefersReducedMotion) {
                        const lastChar = text.charAt(index - 1);
                        if (isPunctuation(lastChar)) {
                            // Glitchy mood has random punctuation pauses
                            delay = systemMood === 'glitchy'
                                ? (Math.random() > 0.5 ? timing.punctuationPause * 1.5 : timing.punctuationPause * 0.3)
                                : timing.punctuationPause;
                        } else {
                            // Use glitchy delay for glitchy mood
                            delay = systemMood === 'glitchy'
                                ? getGlitchyDelay(timing.typeSpeedMin, timing.typeSpeedMax)
                                : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                        }
                    }

                    state.animationTimeout = setTimeout(() => {
                        typeCharacter(text, index + 1, callback);
                    }, delay);
                } else {
                    if (callback) callback();
                }
            }
        }

        function backspaceCharacter(callback) {
            if (state.isUserTyping || state.isSelected) return;

            if (state.currentText.length > 0) {
                state.currentText = state.currentText.substring(0, state.currentText.length - 1);
                thoughtElement.textContent = state.currentText;

                // Random jitter for backspace speed
                const delay = prefersReducedMotion ? 0 : randomDelay(timing.backspaceSpeedMin, timing.backspaceSpeedMax);

                state.animationTimeout = setTimeout(() => {
                    backspaceCharacter(callback);
                }, delay);
            } else {
                if (callback) callback();
            }
        }

        function showThought(index) {
            if (state.isUserTyping || state.isSelected || state.isAnimating) return;

            state.isAnimating = true;
            const originalThought = thoughts[index];
            const thought = replaceName(originalThought);
            state.targetText = thought;
            thoughtElement.dataset.index = index;

            // Make thought visible and start typing
            thoughtElement.classList.remove('fade-out');
            thoughtElement.classList.add('visible', 'fade-in');

            // Type out the thought character by character
            typeCharacter(thought, 0, () => {
                if (choiceButtonsEnabled) {
                    // Show choice buttons and wait for user interaction
                    state.waitingForChoice = true;
                    showChoiceButtons();

                    // Start idle timeout - if user doesn't interact, trigger backspace like "No"
                    state.idleTimeout = setTimeout(() => {
                        if (state.waitingForChoice && !state.isUserTyping && !state.isSelected) {
                            triggerBackspaceAndNext(true);
                        }
                    }, timing.linger);
                } else {
                    // Original behavior: Linger for 3 seconds after fully typed
                    state.cycleTimeout = setTimeout(() => {
                        if (!state.isUserTyping && !state.isSelected) {
                            // Backspace the thought
                            backspaceCharacter(() => {
                                state.isAnimating = false;
                                // Move to next thought
                                state.currentIndex = (state.currentIndex + 1) % thoughts.length;
                                showThought(state.currentIndex);
                            });
                        }
                    }, timing.linger);
                }
            });
        }

        // Show choice buttons with animation
        function showChoiceButtons() {
            if (choiceButtonsContainer) {
                // Reset any previous selection state - remove ALL state classes
                choiceButtonsContainer.classList.remove('selection-made', 'fading-out');
                const yesBtn = document.getElementById('choiceBtnYes');
                const noBtn = document.getElementById('choiceBtnNo');

                // Thoroughly clean all button states to ensure responsiveness
                if (yesBtn) {
                    yesBtn.classList.remove('selected', 'btn-active', 'disabled');
                }
                if (noBtn) {
                    noBtn.classList.remove('selected', 'btn-active', 'disabled');
                }

                // Hide the New Question button in choice area
                hideNewQuestionButton('choice');

                choiceButtonsContainer.hidden = false;
                // Trigger animation after a brief delay
                setTimeout(() => {
                    choiceButtonsContainer.classList.add('visible');
                }, 50);
            }
        }

        // Hide choice buttons
        function hideChoiceButtons() {
            if (choiceButtonsContainer) {
                choiceButtonsContainer.classList.remove('visible');
                setTimeout(() => {
                    choiceButtonsContainer.hidden = true;
                }, 300); // Wait for fade out transition
            }
        }

        // Mark a choice button as selected (persistent visual state)
        function markChoiceSelection(choice) {
            if (!choiceButtonsContainer) return;

            // Add selection-made class to disable further interaction
            choiceButtonsContainer.classList.add('selection-made');

            // Add selected class to the chosen button
            const yesBtn = document.getElementById('choiceBtnYes');
            const noBtn = document.getElementById('choiceBtnNo');

            if (choice === 'yes' && yesBtn) {
                yesBtn.classList.add('selected');
            } else if (choice === 'no' && noBtn) {
                noBtn.classList.add('selected');
            }
        }

        // Reset choice buttons to initial state
        function resetChoiceButtons() {
            if (!choiceButtonsContainer) return;

            // Remove all state classes from container
            choiceButtonsContainer.classList.remove('selection-made', 'visible', 'fading-out');
            choiceButtonsContainer.hidden = true;

            // Remove all state classes from buttons
            const yesBtn = document.getElementById('choiceBtnYes');
            const noBtn = document.getElementById('choiceBtnNo');
            if (yesBtn) {
                yesBtn.classList.remove('selected', 'disabled', 'btn-active');
            }
            if (noBtn) {
                noBtn.classList.remove('selected', 'disabled', 'btn-active');
            }

            // Hide the New Question button in choice area
            hideNewQuestionButton('choice');
        }

        // Type out New Question button text character by character
        function typeNewQuestionText(btn, text, index, callback) {
            if (!btn) {
                if (callback) callback();
                return;
            }

            if (index <= text.length) {
                // Show cursor after text
                btn.innerHTML = text.substring(0, index) + '<span class="typing-cursor">â–ˆ</span>';

                const delay = prefersReducedMotion ? 0 : randomDelay(50, 100);
                setTimeout(() => {
                    typeNewQuestionText(btn, text, index + 1, callback);
                }, delay);
            } else {
                // Typing complete - show final text without cursor
                btn.textContent = text;
                if (callback) callback();
            }
        }

        // Show New Question button with typing animation
        function showNewQuestionButton(location) {
            let btn;
            if (location === 'choice') {
                btn = document.getElementById('newQuestionBtnChoice');
            } else if (typeof location === 'number') {
                btn = document.getElementById('newQuestionBtn' + location);
            }

            if (btn) {
                const buttonText = 'New Question';
                // Clear initial text for typing
                btn.textContent = '';
                // Make visible but not interactive during typing
                btn.classList.add('visible');
                btn.style.pointerEvents = 'none';

                // Type out the button text
                setTimeout(() => {
                    typeNewQuestionText(btn, buttonText, 0, () => {
                        // Enable interaction after typing completes
                        btn.style.pointerEvents = 'auto';
                    });
                }, 200);
            }
        }

        // Hide New Question button
        function hideNewQuestionButton(location) {
            let btn;
            if (location === 'choice') {
                btn = document.getElementById('newQuestionBtnChoice');
            } else if (typeof location === 'number') {
                btn = document.getElementById('newQuestionBtn' + location);
            }

            if (btn) {
                btn.classList.remove('visible');
                btn.style.pointerEvents = '';
                btn.textContent = 'New Question';
            }
        }

        // Hide all New Question buttons
        function hideAllNewQuestionButtons() {
            const choiceBtn = document.getElementById('newQuestionBtnChoice');
            if (choiceBtn) {
                choiceBtn.classList.remove('visible');
                choiceBtn.style.pointerEvents = '';
                choiceBtn.textContent = 'New Question';
            }

            // Loop through all possible panel buttons (up to 50 for dynamic thoughts)
            for (let i = 0; i < 50; i++) {
                const panelBtn = document.getElementById('newQuestionBtn' + i);
                if (panelBtn) {
                    panelBtn.classList.remove('visible');
                    panelBtn.style.pointerEvents = '';
                    panelBtn.textContent = 'New Question';
                }
            }
        }

        // Handle Yes button click - trigger the response or redirect
        function handleChoiceYes() {
            if (!state.waitingForChoice) return;

            // Immediately prevent multiple clicks
            state.waitingForChoice = false;

            // Clear idle timeout since user made a choice
            clearTimeout(state.idleTimeout);
            state.idleTimeout = null;

            // Add flash feedback effect
            const yesBtn = document.getElementById('choiceBtnYes');
            if (yesBtn) {
                yesBtn.classList.add('btn-active');
                setTimeout(() => {
                    yesBtn.classList.remove('btn-active');
                }, 150);
            }

            // Check if current thought has a 'system-meltdown' action type
            const originalIndex = getOriginalIndex(state.currentIndex);
            const action = (typeof originalIndex === 'number' && actions[originalIndex]) ? actions[originalIndex] : null;
            if (action && action.type === 'system-meltdown') {
                // Hide choice buttons
                hideChoiceButtons();
                // Trigger the meltdown sequence immediately
                executeMeltdown();
                return;
            }

            // Check if there's a redirect index configured
            const redirectIndex = yesRedirectIndices[state.currentIndex];
            if (redirectIndex && redirectIndex !== '') {
                // Convert to 0-based index (admin shows 1-based)
                const targetIndex = parseInt(redirectIndex) - 1;

                // Validate the target index
                if (targetIndex >= 0 && targetIndex < thoughts.length) {
                    // Mark selection made
                    markChoiceSelection('yes');

                    // Hide choice buttons
                    hideChoiceButtons();

                    // Immediately clear the screen
                    thoughtElement.textContent = '';
                    state.currentText = '';

                    // Reset choice buttons for next thought
                    setTimeout(() => {
                        resetChoiceButtons();

                        // Jump to the specified index
                        state.currentIndex = targetIndex;
                        state.isAnimating = false;
                        showThought(state.currentIndex);
                    }, 100);
                } else {
                    console.warn('Invalid yes redirect index:', redirectIndex);
                    // Fall back to default behavior
                    markChoiceSelection('yes');
                    selectThought(state.currentIndex);
                }
            } else {
                // No redirect configured - use default behavior (show response)
                markChoiceSelection('yes');
                selectThought(state.currentIndex);
            }
        }

        // Unified function to trigger backspace animation and move to next thought
        // Used by both "No" button click and idle timeout
        function triggerBackspaceAndNext(isTimeout = false) {
            if (!state.waitingForChoice) return;

            // Immediately prevent multiple clicks
            state.waitingForChoice = false;

            // Clear any pending idle timeout
            clearTimeout(state.idleTimeout);
            state.idleTimeout = null;

            // Check if current thought has a 'system-meltdown' action type
            const originalIndex = getOriginalIndex(state.currentIndex);
            const action = (typeof originalIndex === 'number' && actions[originalIndex]) ? actions[originalIndex] : null;
            if (action && action.type === 'system-meltdown') {
                // Hide choice buttons
                hideChoiceButtons();
                // Trigger the meltdown sequence immediately
                executeMeltdown();
                return;
            }

            const container = document.getElementById('choiceButtonsContainer');

            if (isTimeout) {
                // Timeout: fade out buttons smoothly, then backspace
                if (container) {
                    container.classList.add('fading-out');
                }

                // Wait for fade animation to complete before backspacing
                setTimeout(() => {
                    hideChoiceButtons();
                    if (container) {
                        container.classList.remove('fading-out');
                    }

                    // Backspace the current thought and move to next
                    backspaceCharacter(() => {
                        state.isAnimating = false;
                        // Reset buttons for next thought
                        resetChoiceButtons();
                        // Move to next thought
                        state.currentIndex = (state.currentIndex + 1) % thoughts.length;
                        showThought(state.currentIndex);
                    });
                }, 500); // Match the CSS fade-out transition duration
            } else {
                // User clicked "No": check for redirect or use default behavior
                const noBtn = document.getElementById('choiceBtnNo');
                const yesBtn = document.getElementById('choiceBtnYes');

                if (noBtn) {
                    // Flash effect
                    noBtn.classList.add('btn-active');
                    setTimeout(() => {
                        noBtn.classList.remove('btn-active');
                    }, 180);
                }

                // Mark selection and disable buttons (they stay visible)
                markChoiceSelection('no');

                // Disable both buttons visually
                if (noBtn) noBtn.classList.add('disabled');
                if (yesBtn) yesBtn.classList.add('disabled');

                // Check if there's a redirect index configured
                const redirectIndex = noRedirectIndices[state.currentIndex];
                if (redirectIndex && redirectIndex !== '') {
                    // Convert to 0-based index (admin shows 1-based)
                    const targetIndex = parseInt(redirectIndex) - 1;

                    // Validate the target index
                    if (targetIndex >= 0 && targetIndex < thoughts.length) {
                        // Hide choice buttons
                        hideChoiceButtons();

                        // Immediately clear the screen and jump to target
                        setTimeout(() => {
                            thoughtElement.textContent = '';
                            state.currentText = '';

                            // Reset choice buttons for next thought
                            resetChoiceButtons();

                            // Jump to the specified index
                            state.currentIndex = targetIndex;
                            state.isAnimating = false;
                            showThought(state.currentIndex);
                        }, 200);
                    } else {
                        console.warn('Invalid no redirect index:', redirectIndex);
                        // Fall back to default behavior (backspace and next)
                        setTimeout(() => {
                            backspaceCharacter(() => {
                                state.isAnimating = false;
                                state.currentIndex = (state.currentIndex + 1) % thoughts.length;
                                showThought(state.currentIndex);
                            });
                        }, 200);
                    }
                } else {
                    // No redirect configured - use default behavior (backspace and move to next)
                    setTimeout(() => {
                        backspaceCharacter(() => {
                            state.isAnimating = false;
                            state.currentIndex = (state.currentIndex + 1) % thoughts.length;
                            showThought(state.currentIndex);
                        });
                    }, 200);
                }
            }
        }

        // Handle No button click - backspace and move to next thought
        function handleChoiceNo() {
            triggerBackspaceAndNext(false);
        }

        function startCycling() {
            // Check if there are any active thoughts to cycle
            if (thoughts.length === 0) {
                // No active thoughts - show cursor but display fallback message
                cursorElement.classList.add('visible');
                thoughtElement.textContent = 'No questions available';
                thoughtElement.classList.add('visible', 'fade-in');
                return;
            }

            // If hero was typed, cursor is already visible and we skip the initial delay
            // (the 1.5s pause after hero typing serves as the delay)
            if (state.heroTyped) {
                showThought(state.currentIndex);
            } else {
                // Original behavior: Show cursor after initial delay, then start cycling thoughts
                state.cycleTimeout = setTimeout(() => {
                    cursorElement.classList.add('visible');
                    showThought(state.currentIndex);
                }, timing.initialDelay);
            }
        }

        function stopCycling() {
            clearTimeout(state.cycleTimeout);
            clearTimeout(state.animationTimeout);
            clearTimeout(state.idleTimeout);
            state.isAnimating = false;
        }

        // ========================================
        // Thought Selection
        // ========================================
        // Helper to get original index from filtered index
        function getOriginalIndex(filteredIndex) {
            if (typeof filteredIndex === 'number' && activeIndices[filteredIndex] !== undefined) {
                return activeIndices[filteredIndex];
            }
            return filteredIndex; // Return as-is for 'custom' or invalid
        }

        function selectThought(index) {
            // Track user activity
            trackUserActivity();
            // Reset error counter on successful interaction
            resetTerminalErrors();

            state.isSelected = true;
            state.selectedIndex = index;
            // Sync currentIndex for sequential cycling continuity
            if (typeof index === 'number') {
                state.currentIndex = index;
            }
            stopCycling();

            // If we're selecting a cycling thought, show the full text (without backspace syntax)
            if (typeof index === 'number' && thoughts[index]) {
                const cleanText = replaceName(stripBackspaceSyntax(thoughts[index]));
                thoughtElement.textContent = cleanText;
                state.currentText = cleanText;
            }

            // Lock the thought in place
            thoughtElement.classList.add('selected');
            thoughtElement.classList.remove('fade-out', 'fade-in');
            thoughtElement.setAttribute('aria-pressed', 'true');

            // Hide cursor from thought line (it will appear in response)
            cursorElement.classList.remove('visible');

            // Get the original index for panel lookup
            const originalIndex = getOriginalIndex(index);

            // Pre-load audio if this thought has an audio action
            const action = (typeof originalIndex === 'number' && actions[originalIndex]) ? actions[originalIndex] : null;
            if (action && action.type === 'audio' && action.url) {
                // Stop any previously loaded audio
                if (state.currentAudio) {
                    state.currentAudio.pause();
                    state.currentAudio = null;
                }
                // Pre-load the audio file (will not play automatically)
                state.currentAudio = new Audio(action.url);
                state.currentAudio.preload = 'auto';
            }

            // Show the corresponding panel using original index
            showPanel(index, originalIndex);
        }

        function showPanel(filteredIndex, originalIndex) {
            const panels = panelsContainer.querySelectorAll('.explore-panel');
            // Use original index for panel data-thought lookup, filtered index for responses array
            const panelId = typeof originalIndex === 'number' ? originalIndex : filteredIndex;

            panels.forEach(panel => {
                if (panel.dataset.thought === String(panelId)) {
                    panel.hidden = false;
                    panel.classList.add('visible');

                    // Get panel elements
                    const responseEl = panel.querySelector('.panel-response');
                    const textEl = panel.querySelector('.response-text');
                    const actionsEl = panel.querySelector('.explore-panel-actions');
                    const actionBtn = panel.querySelector('.explore-action-btn');

                    if (responseEl && textEl) {
                        // Get response from filtered responses array
                        const fullResponse = (typeof filteredIndex === 'number' && responses[filteredIndex])
                            ? responses[filteredIndex]
                            : "Every project starts with a conversation. Let's start ours.";
                        textEl.textContent = '';

                        // Clear action button text
                        if (actionBtn) {
                            const actionText = actionBtn.querySelector('.action-text');
                            if (actionText) actionText.textContent = '';
                            actionBtn.classList.add('hidden');
                        }

                        // Hide actions initially
                        if (actionsEl) actionsEl.classList.remove('visible');

                        // Start sequential typing: response -> action button
                        // Pass original index for action lookup
                        const processedResponse = replaceName(fullResponse);
                        typePanelResponse(textEl, actionsEl, actionBtn, processedResponse, 0, originalIndex);
                    }

                    // Focus the panel for accessibility
                    setTimeout(() => {
                        const focusTarget = panel.querySelector('.panel-response') || panel.querySelector('h2');
                        if (focusTarget) focusTarget.focus();
                    }, 100);
                } else {
                    panel.hidden = true;
                    panel.classList.remove('visible');
                    // Clear any response text when hiding
                    const textEl = panel.querySelector('.response-text');
                    const actionsEl = panel.querySelector('.explore-panel-actions');
                    if (textEl) textEl.textContent = '';
                    if (actionsEl) actionsEl.classList.remove('visible');
                }
            });

            panelsContainer.classList.add('visible');
        }

        function typePanelResponse(textEl, actionsEl, actionBtn, text, charIndex, panelIndex) {
            if (charIndex <= text.length) {
                // Show cursor after text
                textEl.innerHTML = text.substring(0, charIndex) + '<span class="typing-cursor">â–ˆ</span>';

                let delay = 0;
                if (!prefersReducedMotion) {
                    const lastChar = text.charAt(charIndex - 1);
                    if (isPunctuation(lastChar)) {
                        // Glitchy mood has random punctuation pauses
                        delay = systemMood === 'glitchy'
                            ? (Math.random() > 0.5 ? timing.punctuationPause * 1.5 : timing.punctuationPause * 0.3)
                            : timing.punctuationPause;
                    } else {
                        // Use glitchy delay for glitchy mood
                        delay = systemMood === 'glitchy'
                            ? getGlitchyDelay(timing.typeSpeedMin, timing.typeSpeedMax)
                            : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                    }
                }

                setTimeout(() => {
                    typePanelResponse(textEl, actionsEl, actionBtn, text, charIndex + 1, panelIndex);
                }, delay);
            } else {
                // Response typing complete - remove cursor from response
                textEl.textContent = text;

                // Show action button if this thought has an action configured
                showActionButton(actionsEl, actionBtn, panelIndex);
            }
        }

        function showActionButton(actionsEl, actionBtn, panelIndex) {
            // Check if this panel has an action
            const action = (typeof panelIndex === 'number' && actions[panelIndex]) ? actions[panelIndex] : null;
            const hasAction = action && action.type && action.type !== 'none';

            if (hasAction && actionBtn) {
                // Show actions container
                if (actionsEl) {
                    actionsEl.classList.add('visible');
                }

                const actionLinkText = replaceName(action.linkText || 'Click here');
                actionBtn.classList.remove('hidden');

                // Type out the action button text
                typeActionText(actionBtn, actionLinkText, 0, () => {
                    // Set up action button handler
                    actionBtn.classList.add('ready');
                    actionBtn.onclick = () => executeAction(action);

                    // Stop cursor blinking - typing is complete
                    cursorElement.classList.add('cursor-stopped');

                    // Show New Question button after action is ready
                    showNewQuestionButton(panelIndex);
                });
            } else {
                // No action configured - just stop cursor blinking
                cursorElement.classList.add('cursor-stopped');

                // Show New Question button even if no action
                if (typeof panelIndex === 'number') {
                    if (actionsEl) {
                        actionsEl.classList.add('visible');
                    }
                    showNewQuestionButton(panelIndex);
                }
            }
        }

        function typeActionText(btn, text, index, callback) {
            if (!btn) {
                if (callback) callback();
                return;
            }

            const textSpan = btn.querySelector('.action-text');
            if (!textSpan) {
                if (callback) callback();
                return;
            }

            if (index <= text.length) {
                // Show cursor after text
                textSpan.innerHTML = text.substring(0, index) + '<span class="typing-cursor">â–ˆ</span>';

                const delay = prefersReducedMotion ? 0 : randomDelay(60, 120);
                setTimeout(() => {
                    typeActionText(btn, text, index + 1, callback);
                }, delay);
            } else {
                // Typing complete - show final text without cursor
                textSpan.textContent = text;
                if (callback) callback();
            }
        }

        // ========================================
        // Action Execution
        // ========================================
        function executeAction(action) {
            if (!action || !action.type) return;

            switch (action.type) {
                case 'video':
                    openVideoModal(action.url);
                    break;
                case 'image':
                    openImageModal(action.url);
                    break;
                case 'logo':
                    printAsciiLogo(action.logo);
                    break;
                case 'matrix':
                    triggerMatrixAnimation();
                    break;
                case 'contact':
                    openContactModal();
                    break;
                case 'capture-name':
                    // Activate name capture mode directly in terminal
                    stopCycling();
                    state.capturingName = true;
                    state.isSelected = true; // Lock the thought

                    // Display the prompt in the thought element
                    thoughtElement.textContent = '> ENTER YOUR NAME:';
                    thoughtElement.classList.add('selected', 'visible');
                    thoughtElement.classList.remove('fade-out', 'fade-in');
                    cursorElement.classList.remove('visible');

                    // Clear and focus the input
                    inputElement.value = '';
                    inputElement.focus();
                    inputElement.classList.add('active');
                    break;
                case 'audio':
                    // Play the pre-loaded audio when user clicks the trigger text
                    if (state.currentAudio) {
                        // Reset to beginning if already played
                        state.currentAudio.currentTime = 0;
                        // Play the audio (user-initiated, not automatic)
                        state.currentAudio.play().catch(err => {
                            console.warn('Audio playback failed:', err);
                        });
                    } else if (action.url) {
                        // Fallback: create and play if not pre-loaded
                        const audio = new Audio(action.url);
                        audio.play().catch(err => {
                            console.warn('Audio playback failed:', err);
                        });
                    }
                    break;
                case 'trigger-fin':
                    // Show the Fin (The End) overlay
                    showFinOverlay();
                    // Stop all cycling
                    stopCycling();
                    break;
                case 'system-meltdown':
                    // Trigger the system meltdown sequence
                    executeMeltdown();
                    break;
            }
        }

        // ========================================
        // Multimedia Modal (Video/Image)
        // ========================================
        function openVideoModal(url) {
            if (!url) return;

            const modal = document.getElementById('multimediaModal');
            const content = document.getElementById('multimediaContent');

            // Extract video ID from YouTube URL
            let videoId = '';
            const urlPatterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\s?]+)/,
                /youtube\.com\/shorts\/([^&\s?]+)/
            ];

            for (const pattern of urlPatterns) {
                const match = url.match(pattern);
                if (match) {
                    videoId = match[1];
                    break;
                }
            }

            if (videoId) {
                content.innerHTML = `
                    <iframe
                        src="https://www.youtube.com/embed/${videoId}?autoplay=1"
                        frameborder="0"
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen>
                    </iframe>
                `;
            } else {
                // Fallback: try embedding as-is
                content.innerHTML = `
                    <iframe
                        src="${url}"
                        frameborder="0"
                        allowfullscreen>
                    </iframe>
                `;
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function openImageModal(url) {
            if (!url) return;

            const modal = document.getElementById('multimediaModal');
            const content = document.getElementById('multimediaContent');

            content.innerHTML = `<img src="${url}" alt="Image content" class="modal-image">`;

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeMultimediaModal() {
            const modal = document.getElementById('multimediaModal');
            const content = document.getElementById('multimediaContent');

            modal.classList.remove('active');
            document.body.style.overflow = '';

            // Clear content to stop video playback
            setTimeout(() => {
                content.innerHTML = '';
            }, 300);
        }

        function closeMultimediaModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeMultimediaModal();
            }
        }

        // ========================================
        // ASCII Logo Printing
        // ========================================
        function printAsciiLogo(logoText) {
            if (!logoText) return;

            const container = document.getElementById('asciiLogoContainer');

            // Clear any existing content
            container.innerHTML = '';

            // Create wrapper for positioning the close button
            const wrapper = document.createElement('div');
            wrapper.className = 'ascii-logo-wrapper';

            // Create home link that wraps the logo
            const homeLink = document.createElement('a');
            homeLink.className = 'ascii-logo-home-link';
            homeLink.href = 'index.html';
            homeLink.setAttribute('aria-label', 'Return to home and reset terminal');
            homeLink.onclick = function(e) {
                e.preventDefault();
                closeAsciiLogo();
                resetExplore();
            };

            // Create close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'ascii-logo-close';
            closeBtn.textContent = 'X';
            closeBtn.setAttribute('aria-label', 'Close logo');
            closeBtn.onclick = function(e) {
                e.stopPropagation();
                closeAsciiLogo();
            };

            // Create logo element
            const logoElement = document.createElement('pre');
            logoElement.className = 'ascii-logo';
            logoElement.textContent = '';

            // Structure: wrapper > homeLink > logoElement, wrapper > closeBtn
            homeLink.appendChild(logoElement);
            wrapper.appendChild(homeLink);
            wrapper.appendChild(closeBtn);
            container.appendChild(wrapper);

            // Show the container
            container.classList.add('visible');

            // Type out the logo character by character
            typeAsciiLogo(logoElement, logoText, 0);
        }

        function typeAsciiLogo(element, text, index) {
            if (index <= text.length) {
                element.textContent = text.substring(0, index);

                // Faster typing for ASCII art
                const delay = prefersReducedMotion ? 0 : randomDelay(5, 15);
                setTimeout(() => {
                    typeAsciiLogo(element, text, index + 1);
                }, delay);
            }
        }

        function closeAsciiLogo() {
            const container = document.getElementById('asciiLogoContainer');
            container.classList.remove('visible');
            // Clear content after hiding
            setTimeout(() => {
                container.innerHTML = '';
            }, 300);
        }

        // ========================================
        // The Matrix Animation
        // ========================================
        function triggerMatrixAnimation() {
            if (state.matrixActive) return;

            state.matrixActive = true;
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas to full screen
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.classList.remove('fade-out');
            canvas.classList.add('active');

            const fontSize = 14;
            const columns = Math.floor(canvas.width / fontSize);
            const drops = Array(columns).fill(1);

            function draw() {
                // Semi-transparent black background for trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Green text - updated to #34ff35
                ctx.fillStyle = '#34ff35';
                ctx.font = fontSize + 'px VT323, monospace';
                ctx.shadowColor = 'rgba(52, 255, 53, 0.5)';
                ctx.shadowBlur = 4;

                for (let i = 0; i < drops.length; i++) {
                    // Random 0 or 1
                    const char = Math.random() > 0.5 ? '1' : '0';
                    ctx.fillText(char, i * fontSize, drops[i] * fontSize);

                    // Reset drop when it reaches bottom or randomly
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }

            // Run animation for 5 seconds
            const interval = setInterval(draw, 50);

            setTimeout(() => {
                clearInterval(interval);

                // Apply dynamic fade duration from admin settings
                const fadeDurationMs = matrixFadeDuration * 1000;
                canvas.style.transition = `opacity ${matrixFadeDuration}s ease`;

                // Start fade-out transition
                canvas.classList.add('fade-out');

                // After fade-out completes, clean up
                setTimeout(() => {
                    canvas.classList.remove('active', 'fade-out');
                    canvas.style.transition = ''; // Reset to CSS default
                    state.matrixActive = false;
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }, fadeDurationMs);
            }, 5000);
        }

        // Handle window resize for Matrix canvas
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('matrixCanvas');
            if (canvas.classList.contains('active')) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        });

        function resetExplore() {
            state.isSelected = false;
            state.isUserTyping = false;
            state.isAnimating = false;
            state.waitingForChoice = false;
            // Clear any pending timeouts
            clearTimeout(state.idleTimeout);
            state.idleTimeout = null;
            // Stop and cleanup any playing audio
            if (state.currentAudio) {
                state.currentAudio.pause();
                state.currentAudio.currentTime = 0;
                state.currentAudio = null;
            }
            // Advance to the next thought in sequence (don't reset to 0)
            state.currentIndex = (state.currentIndex + 1) % thoughts.length;
            state.selectedIndex = null;
            state.currentText = '';
            state.targetText = '';

            // Reset thought element
            thoughtElement.classList.remove('selected', 'visible', 'fade-in', 'fade-out');
            thoughtElement.textContent = '';
            thoughtElement.removeAttribute('aria-pressed');

            // Hide cursor initially (will be shown after delay when cycling restarts)
            cursorElement.classList.remove('visible', 'cursor-stopped');

            // Reset choice buttons to initial state
            resetChoiceButtons();

            // Hide all New Question buttons
            hideAllNewQuestionButtons();

            // Hide all panels and reset their elements
            const panels = panelsContainer.querySelectorAll('.explore-panel');
            panels.forEach(panel => {
                panel.hidden = true;
                panel.classList.remove('visible');
                // Reset panel elements
                const textEl = panel.querySelector('.response-text');
                const actionsEl = panel.querySelector('.explore-panel-actions');
                const actionBtn = panel.querySelector('.explore-action-btn');

                if (textEl) textEl.textContent = '';
                if (actionsEl) actionsEl.classList.remove('visible');
                if (actionBtn) {
                    actionBtn.classList.remove('ready');
                    actionBtn.classList.add('hidden');
                    actionBtn.onclick = null;
                    const actionTextSpan = actionBtn.querySelector('.action-text');
                    if (actionTextSpan) actionTextSpan.textContent = '';
                }
            });
            panelsContainer.classList.remove('visible');

            // Clear input
            inputElement.value = '';
            inputElement.classList.remove('active');

            // Restart cycling
            startCycling();
        }

        // ========================================
        // Input Handling
        // ========================================
        function handleInputChange() {
            // Don't handle normal input changes when capturing name
            if (state.capturingName) {
                return;
            }

            const hasValue = inputElement.value.trim().length > 0;

            if (hasValue && !state.isUserTyping) {
                state.isUserTyping = true;
                stopCycling();
                thoughtElement.classList.remove('visible', 'fade-in', 'fade-out');
                thoughtElement.textContent = '';
                state.currentText = '';
                inputElement.classList.add('active');
            } else if (!hasValue && state.isUserTyping) {
                state.isUserTyping = false;
                inputElement.classList.remove('active');
                if (!state.isSelected) {
                    startCycling();
                }
            }
        }

        function handleInputKeydown(event) {
            if (event.key === 'Enter' && inputElement.value.trim()) {
                event.preventDefault();

                // Check if we're in name capture mode
                if (state.capturingName) {
                    const capturedName = inputElement.value.trim();

                    // Save to global state variable
                    state.userName = capturedName;

                    // Save to sessionStorage for replaceName function
                    sessionStorage.setItem('imaginecraft_user_name', capturedName);

                    // Display confirmation message
                    thoughtElement.textContent = `> Name captured: ${capturedName}`;

                    // Clear the input
                    inputElement.value = '';
                    inputElement.classList.remove('active');

                    // Reset capture mode after a brief delay
                    setTimeout(() => {
                        state.capturingName = false;
                        state.isSelected = false;
                        thoughtElement.classList.remove('selected');

                        // Resume cycling
                        startCycling();
                    }, 2000); // Show confirmation for 2 seconds
                } else {
                    // Normal custom thought selection
                    selectThought('custom');
                }
            }
        }

        // ========================================
        // Event Listeners
        // ========================================
        // Event delegation on parent container for thought clicks
        // This ensures clicks work even while text is being typed/re-rendered
        document.querySelector('.explore-thought-container').addEventListener('click', (event) => {
            const thought = event.target.closest('.explore-thought');
            if (thought && thought.classList.contains('visible') && !state.isSelected) {
                const index = parseInt(thought.dataset.index, 10);
                selectThought(index);
            }
        });

        // Event delegation for keyboard accessibility
        document.querySelector('.explore-thought-container').addEventListener('keydown', (event) => {
            const thought = event.target.closest('.explore-thought');
            if ((event.key === 'Enter' || event.key === ' ') &&
                thought && thought.classList.contains('visible') &&
                !state.isSelected) {
                event.preventDefault();
                const index = parseInt(thought.dataset.index, 10);
                selectThought(index);
            }
        });

        inputElement.addEventListener('input', handleInputChange);
        inputElement.addEventListener('keydown', handleInputKeydown);

        // Focus input when clicking anywhere in question area
        document.querySelector('.explore-question-area').addEventListener('click', (event) => {
            if (!event.target.closest('.explore-thought') && !state.isSelected) {
                inputElement.focus();
            }
        });

        // ========================================
        // Contact Modal (reused)
        // ========================================
        function openContactModal() {
            document.getElementById('contactModal').classList.add('active');
            document.body.style.overflow = 'hidden';
            document.getElementById('modalName').focus();
        }

        function closeContactModal() {
            document.getElementById('contactModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        function openNameModal() {
            document.getElementById('nameModal').classList.add('active');
            document.body.style.overflow = 'hidden';
            document.getElementById('userName').focus();
        }

        function closeNameModal() {
            document.getElementById('nameModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        function saveUserName(event) {
            event.preventDefault();
            const nameInput = document.getElementById('userName');
            const userName = nameInput.value.trim();

            if (userName) {
                sessionStorage.setItem('imaginecraft_user_name', userName);
                closeNameModal();
                nameInput.value = '';
            }
        }

        function closeModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeContactModal();
                closeNameModal();
            }
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                closeContactModal();
                closeNameModal();
                closeMultimediaModal();
            }
        });

        // ========================================
        // Earthquake Transition
        // ========================================
        function loadEarthquakeSetting() {
            const settings = getConfigSettings();
            return settings && settings.earthquakeEnabled !== undefined ? settings.earthquakeEnabled : true;
        }

        const earthquakeEnabled = loadEarthquakeSetting();

        // Apply --quake-time CSS variable
        // Urgent mood increases earthquake duration by 50% for more dramatic effect
        function applyQuakeTimeVariable() {
            let quakeTime = earthquakeDuration;

            // Urgent mood gets 50% longer and more intense earthquake
            if (systemMood === 'urgent') {
                quakeTime = quakeTime * 1.5;
            }

            document.documentElement.style.setProperty('--quake-time', `${quakeTime}s`);
            return quakeTime;
        }

        // Preload main.html content as background layer when earthquake is enabled
        // Superman Logic: Main site is ALWAYS rendered behind terminal
        function preloadMainSite() {
            const iframe = document.getElementById('mainSiteFrame');
            const background = document.getElementById('mainSiteBackground');

            if (earthquakeEnabled) {
                // Load main site immediately so it's ready behind the terminal
                if (iframe && !iframe.src) {
                    iframe.src = 'main.html';
                }
                // Mark as preloaded (main site is now rendering behind terminal)
                if (background) {
                    background.classList.add('preloaded');
                }
            }
        }

        // Execute earthquake transition - True Superman reveal style
        function triggerEarthquakeTransition(event) {
            if (!earthquakeEnabled) {
                // Normal navigation
                return true;
            }

            // Prevent default navigation
            event.preventDefault();

            const explorePage = document.querySelector('.explore-page');
            const terminalOverlay = document.getElementById('terminalOverlay');
            const background = document.getElementById('mainSiteBackground');
            const iframe = document.getElementById('mainSiteFrame');

            // Ensure iframe is loaded (should already be preloaded)
            if (!iframe.src) {
                iframe.src = 'main.html';
            }

            // The main site background is ALREADY visible (z-index: 1)
            // The terminal (explore-page) covers it (z-index: 2)
            // Mark background as active to ensure visibility
            if (background) {
                background.classList.add('active');
            }

            // Apply --quake-time variable before animation starts
            // Returns the actual quake time (may be modified for urgent mood)
            const actualQuakeTime = applyQuakeTimeVariable();
            const durationMs = actualQuakeTime * 1000;

            // Phase 1: Earthquake shake on the explore page (terminal layer only)
            // The main site stays static behind it
            explorePage.classList.add('earthquake-shake');

            // After shake completes, trigger the terminal split
            setTimeout(() => {
                // Phase 2: Activate terminal overlay (the shell that splits)
                // This overlay sits at z-index: 3, above the terminal content
                terminalOverlay.classList.add('active');

                // Hide the explore page content so only the overlay shows
                explorePage.style.visibility = 'hidden';

                // Small delay then crack/split the terminal shell
                setTimeout(() => {
                    terminalOverlay.classList.add('splitting');

                    // Phase 3: After split animation (0.8s), navigate to main.html
                    // The main site is already visible through the cracks
                    setTimeout(() => {
                        window.location.href = 'main.html';
                    }, 800);
                }, 50);
            }, durationMs);

            return false;
        }

        // Attach earthquake transition to all Main Site links
        function attachEarthquakeHandlers() {
            // Get all "Enter Main Site" links
            const mainSiteLinks = document.querySelectorAll('.explore-link');
            mainSiteLinks.forEach(link => {
                link.addEventListener('click', triggerEarthquakeTransition);
            });
        }

        // ========================================
        // Boot Sequence Animation
        // ========================================
        function runBootSequence(callback) {
            console.log('runBootSequence started');

            try {
                const overlay = document.getElementById('bootSequenceOverlay');
                const diagnostics = document.getElementById('bootDiagnostics');
                const explorePage = document.querySelector('.explore-page');

                if (!overlay) {
                    console.warn('Boot overlay not found, calling callback');
                    if (callback) callback();
                    return;
                }

                console.log('Boot overlay found, proceeding with sequence');

                // Hide main content during boot
                if (explorePage) {
                    explorePage.classList.add('boot-hidden');
                }

                // 8-second fallback timeout - ensure overlay fades even if script fails
                let hasCompleted = false;
                const fallbackTimeout = setTimeout(() => {
                    if (!hasCompleted) {
                        console.warn('Boot sequence fallback timeout triggered');
                        finishBootSequence();
                    }
                }, 8000);

                // Load boot script from Firebase
                const bootScript = loadBootScript();
                const bootScriptLines = bootScript.split('\n').filter(line => line.trim() !== '');
                console.log('Boot script lines:', bootScriptLines.length);

                // Get fast typing speed from admin settings
                const settings = getConfigSettings();
                const baseSpeed = settings && settings.typingSpeed ? settings.typingSpeed : 150;
                // Fast typing: use 20-50ms range (similar to "urgent" mode)
                const fastTypeMin = 20;
                const fastTypeMax = 50;

                // Clear existing content and create container for typed output
                diagnostics.innerHTML = '';

                let currentLineIndex = 0;
                let currentCharIndex = 0;
                let currentLineElement = null;

                // Type out boot script character by character
                function typeNextCharacter() {
                    // Check if we're done with all lines
                    if (currentLineIndex >= bootScriptLines.length) {
                        clearTimeout(fallbackTimeout);
                        // Small delay after final character before fading overlay
                        setTimeout(finishBootSequence, 200);
                        return;
                    }

                    // Get current line text
                    const currentLineText = bootScriptLines[currentLineIndex];

                    // Create new line element if needed
                    if (!currentLineElement) {
                        currentLineElement = document.createElement('div');
                        currentLineElement.className = 'boot-line';
                        currentLineElement.textContent = '';
                        diagnostics.appendChild(currentLineElement);
                    }

                    // Type next character
                    if (currentCharIndex < currentLineText.length) {
                        currentLineElement.textContent += currentLineText[currentCharIndex];
                        currentCharIndex++;

                        // Random delay for typing speed variation
                        const delay = Math.floor(Math.random() * (fastTypeMax - fastTypeMin + 1)) + fastTypeMin;
                        setTimeout(typeNextCharacter, delay);
                    } else {
                        // Current line complete, move to next line
                        currentLineIndex++;
                        currentCharIndex = 0;
                        currentLineElement = null;

                        // Small delay between lines (100-150ms)
                        const lineDelay = Math.floor(Math.random() * 50) + 100;
                        setTimeout(typeNextCharacter, lineDelay);
                    }
                }

                // Finish boot sequence and reveal main terminal
                function finishBootSequence() {
                    // Prevent double initialization
                    if (hasCompleted) {
                        console.log('finishBootSequence already called, skipping');
                        return;
                    }
                    hasCompleted = true;
                    console.log('Finishing boot sequence - fading out overlay');
                    // Fade out the overlay using style.opacity for reliable animation
                    overlay.style.opacity = '0';

                    // Reveal the background image behind the curtains
                    const openingBackground = document.getElementById('openingBackground');
                    if (openingBackground) {
                        openingBackground.classList.add('visible');
                    }

                    // Show main content
                    if (explorePage) {
                        explorePage.classList.remove('boot-hidden');
                    }

                    // After fade transition completes (300ms), remove overlay and start terminal
                    setTimeout(() => {
                        console.log('Removing boot overlay from DOM');
                        // Remove the overlay element completely
                        if (overlay && overlay.parentNode) {
                            overlay.parentNode.removeChild(overlay);
                        }

                        // Mark as played for this session
                        markBootSequencePlayed();

                        console.log('Boot sequence complete, calling terminal initialization');
                        // NOW trigger the callback (start hero text and terminal)
                        // This ensures hero text only appears AFTER overlay has cleared
                        try {
                            if (callback) callback();
                        } catch (error) {
                            // Handle any errors from callback execution (e.g., message channel issues)
                            console.warn('Error during terminal initialization (continuing locally):', error);
                        }
                    }, 300);
                }

                // Start typing the boot sequence
                typeNextCharacter();
            } catch (error) {
                // Handle any synchronous errors in boot sequence
                console.error('Boot sequence error:', error);
                // Ensure callback is still called to prevent hang
                if (callback) {
                    try {
                        callback();
                    } catch (callbackError) {
                        console.warn('Error during callback execution:', callbackError);
                    }
                }
            }
        }

        function skipBootSequence(callback) {
            const overlay = document.getElementById('bootSequenceOverlay');
            const explorePage = document.querySelector('.explore-page');

            if (overlay) {
                overlay.style.opacity = '0';

                // Reveal the background image behind the curtains
                const openingBackground = document.getElementById('openingBackground');
                if (openingBackground) {
                    openingBackground.classList.add('visible');
                }

                setTimeout(() => {
                    if (overlay && overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }

                    // Mark as skipped/played for this session
                    markBootSequencePlayed();

                    // Call the callback after overlay is fully removed
                    if (callback) {
                        try {
                            callback();
                        } catch (error) {
                            console.warn('Error during callback execution:', error);
                        }
                    }
                }, 300);
            } else {
                // If no overlay, call callback immediately
                if (callback) {
                    try {
                        callback();
                    } catch (error) {
                        console.warn('Error during callback execution:', error);
                    }
                }
            }
            if (explorePage) {
                explorePage.classList.remove('boot-hidden');
            }
        }

        // ========================================
        // Initialize
        // ========================================
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOMContentLoaded - Starting initialization');

            // Wait for remote config to load before initializing (with timeout)
            try {
                await configPromise;
                console.log('Config loaded successfully');
            } catch (error) {
                console.error('Config loading error:', error);
                // Continue anyway with defaults
            }

            // Initialize all config-dependent values now that config is loaded
            initializeConfigDependentValues();

            // Wrap content initialization in try-catch to prevent errors from blocking the UI
            try {
                initializeContentData();
            } catch (error) {
                console.error('Error initializing content data:', error);
                // Set emergency fallback data
                allThoughts = ['System Error'];
                allResponses = ['An error occurred during initialization. Please refresh the page.'];
                heroText = 'SYSTEM ERROR';
                actions = [{ type: 'none', url: '', logo: '', linkText: 'Click here' }];
                activeStates = [true];
                allYesRedirectIndices = [''];
                allNoRedirectIndices = [''];
                randomizeEnabled = false;
                thoughts = allThoughts;
                responses = allResponses;
            }

            initializeSettings();

            // Load and prepare background image
            loadOpeningBackgroundImage();

            // Initialize cinematic overlay images
            initializeCinematicOverlays();

            // Apply system mood CSS class to explore page
            const explorePage = document.querySelector('.explore-page');
            if (explorePage && systemMood !== 'stable') {
                explorePage.classList.add(`mood-${systemMood}`);
            }

            // Clear hero text initially (will be typed out)
            if (heroElement && heroText) {
                heroElement.textContent = '';
                heroElement.dataset.fullText = heroText;
            }

            // Apply reduced motion adjustments
            if (prefersReducedMotion) {
                timing.fadeIn = 0;
                timing.fadeOut = 0;
                timing.linger = 5000;
            }

            // Apply --quake-time CSS variable from localStorage on page load
            applyQuakeTimeVariable();

            // Initialize earthquake transition
            attachEarthquakeHandlers();
            preloadMainSite();

            // Attach choice button event listeners
            if (choiceBtnYes) {
                choiceBtnYes.addEventListener('click', handleChoiceYes);
            }
            if (choiceBtnNo) {
                choiceBtnNo.addEventListener('click', handleChoiceNo);
            }

            // Attach New Question button event listeners
            const newQuestionBtnChoice = document.getElementById('newQuestionBtnChoice');
            if (newQuestionBtnChoice) {
                newQuestionBtnChoice.addEventListener('click', resetExplore);
            }

            // Attach event listeners to all panel New Question buttons
            for (let i = 0; i < 5; i++) {
                const btn = document.getElementById('newQuestionBtn' + i);
                if (btn) {
                    btn.addEventListener('click', resetExplore);
                }
            }

            // Type out hero text character by character
            function typeHeroText(callback) {
                const originalText = heroElement.dataset.fullText || heroText;
                const fullText = replaceName(originalText);
                let index = 0;

                function typeNextChar() {
                    if (index <= fullText.length) {
                        heroElement.textContent = fullText.substring(0, index);
                        index++;

                        // Calculate delay for each character
                        let delay = prefersReducedMotion ? 0 : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                        const lastChar = fullText.charAt(index - 1);
                        if (isPunctuation(lastChar)) {
                            delay = timing.punctuationPause;
                        }

                        state.animationTimeout = setTimeout(typeNextChar, delay);
                    } else {
                        // Hero text finished typing
                        state.heroTyped = true;
                        if (callback) callback();
                    }
                }

                typeNextChar();
            }

            // Function to start the main terminal experience
            function initializeTerminal() {
                // Type hero text first, then pause, then start cycling thoughts
                typeHeroText(() => {
                    // 1.5 second pause with blinking cursor after hero finishes
                    cursorElement.classList.add('visible');

                    setTimeout(() => {
                        // Now start cycling thoughts
                        startCycling();
                        // Start inactivity tracking for intermission overlay
                        trackUserActivity();
                    }, 1500);
                });
            }

            // Function to handle curtain rise animation
            function raiseCurtain() {
                const curtainElement = document.getElementById('theaterCurtain');
                if (!curtainElement) {
                    return;
                }

                // Apply curtain duration as CSS variable
                document.documentElement.style.setProperty('--curtain-duration', curtainDuration + 's');

                // Start curtain rise animation
                curtainElement.classList.add('curtain-rising');

                // After curtain has fully risen, hide it
                setTimeout(() => {
                    curtainElement.classList.add('curtain-hidden');
                }, curtainDuration * 1000);
            }

            // Function to set up splash screen interaction (already visible behind curtain)
            function setupSplashScreen(callback) {
                const splashScreen = document.getElementById('splashScreen');
                const splashClickPrompt = document.getElementById('splashClickPrompt');

                if (!splashScreen) {
                    // If splash screen doesn't exist, proceed immediately
                    if (callback) callback();
                    return;
                }

                // Timer to show "Click to Enter" prompt after 5 seconds
                const promptTimer = setTimeout(() => {
                    if (splashClickPrompt) {
                        splashClickPrompt.classList.add('visible');
                    }
                }, 5000);

                // Click handler to fade out splash and proceed
                function handleSplashClick() {
                    // Clear the prompt timer
                    clearTimeout(promptTimer);

                    // Start fade out animation
                    splashScreen.classList.add('fading-out');

                    // Remove click listener to prevent multiple triggers
                    splashScreen.removeEventListener('click', handleSplashClick);

                    // After fade out completes, proceed to callback
                    setTimeout(() => {
                        // Hide splash screen completely
                        splashScreen.style.display = 'none';
                        if (callback) callback();
                    }, 800); // Match CSS transition duration
                }

                // Add click event listener
                splashScreen.addEventListener('click', handleSplashClick);
            }

            // Function to proceed with boot sequence or terminal
            function proceedAfterSplash() {
                console.log('proceedAfterSplash called');
                // Check if boot sequence should run
                const shouldRunBootSequence = bootSequenceEnabled &&
                                              !hasBootSequencePlayedThisSession() &&
                                              !prefersReducedMotion;

                console.log('Boot sequence check:', {
                    bootSequenceEnabled,
                    hasPlayed: hasBootSequencePlayedThisSession(),
                    prefersReducedMotion,
                    shouldRunBootSequence
                });

                if (shouldRunBootSequence) {
                    console.log('Starting boot sequence...');
                    // Run boot sequence with error handling for message channel issues
                    try {
                        runBootSequence(initializeTerminal);
                    } catch (error) {
                        // If message channel closes or any error occurs, continue locally
                        console.warn('Boot sequence error (continuing locally):', error);
                        skipBootSequence(initializeTerminal);
                    }
                } else {
                    // Skip boot sequence, initialize terminal after overlay fades
                    skipBootSequence(initializeTerminal);
                }
            }

            // Set up splash screen interaction (already visible behind curtain)
            setupSplashScreen(proceedAfterSplash);

            // Emergency fail-safe: Force curtain to rise after 5 seconds if initialization hangs
            let curtainRaised = false;
            const emergencyCurtainTimer = setTimeout(() => {
                if (!curtainRaised) {
                    console.warn('Emergency curtain trigger activated after 5 seconds');
                    raiseCurtain();
                    curtainRaised = true;
                }
            }, 5000);

            // Raise curtain to reveal the splash screen
            try {
                raiseCurtain();
                curtainRaised = true;
                clearTimeout(emergencyCurtainTimer);
            } catch (error) {
                console.error('Error raising curtain:', error);
                // Emergency timer will handle it
            }

        });
    </script>

    <!-- Film Grain Overlay -->
    <div id="filmGrain" class="film-grain-overlay"></div>

    <!-- Opening Sequence Background Image (behind curtains, revealed after boot) -->
    <div id="openingBackground" class="opening-background">
        <img id="openingBackgroundImage" class="opening-background-image" alt="Background">
    </div>

    <!-- Splash Screen (revealed after curtain rises) -->
    <div id="splashScreen" class="splash-screen">
        <div class="splash-image-container">
            <img src="assets/mysteryimage.png" alt="Welcome" class="splash-image">
        </div>
        <div class="splash-click-prompt" id="splashClickPrompt">Click to Enter</div>
    </div>

    <!-- Theater Curtain Overlay -->
    <div id="theaterCurtain" class="theater-curtain">
        <div class="curtain-left"></div>
        <div class="curtain-right"></div>
    </div>

    <!-- Cinematic State Overlays -->
    <div id="intermissionOverlay" class="cinematic-overlay" style="display: none;">
        <img id="intermissionImage" src="" alt="Intermission" class="cinematic-image">
    </div>
    <div id="techDifficultyOverlay" class="cinematic-overlay" style="display: none;">
        <img id="techDifficultyImage" src="" alt="Technical Difficulties" class="cinematic-image">
    </div>
    <div id="finOverlay" class="cinematic-overlay" style="display: none;">
        <img id="finImage" src="" alt="Fin" class="cinematic-image">
    </div>

</body>
</html>
