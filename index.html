<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ImagineCraft Studios</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=VT323&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css?v=1.0.1">
</head>
<body>
    <!-- Boot Sequence Overlay -->
    <div id="bootSequenceOverlay" class="boot-sequence-overlay">
        <div class="boot-diagnostics" id="bootDiagnostics">
            <div class="boot-line" data-line="0">CORE_INIT: <span class="status">OK</span></div>
            <div class="boot-line" data-line="1">MEM_LOAD: <span class="status">1024KB</span></div>
            <div class="boot-line" data-line="2">DRV_MOUNT: <span class="status">/assets</span></div>
            <div class="boot-line" data-line="3">NET_STACK: <span class="status">READY</span></div>
            <div class="boot-line" data-line="4">SYS_CHECK: <span class="status">COMPLETE</span></div>
        </div>
        <div class="boot-progress-container" id="bootProgressContainer">
            <div class="boot-progress-bar" id="bootProgressBar">[--------------------] 0%</div>
        </div>
    </div>

    <main class="explore-page" role="main">
        <div class="explore-container">
            <!-- Question and cursor area -->
            <div class="explore-question-area">
                <h1 class="explore-question" id="exploreQuestion">Why are you here?</h1>
                <!-- Cursor and thoughts inline together -->
                <div class="explore-cursor-line">
                    <div class="explore-thought-container" aria-live="polite" aria-atomic="true">
                        <button
                            class="explore-thought"
                            id="currentThought"
                            tabindex="0"
                            aria-label="Click to select this thought"
                        ></button>
                    </div><span class="explore-cursor" id="exploreCursor" aria-hidden="true">â–ˆ</span>
                    <!-- Optional: text input appears here when user starts typing -->
                    <input
                        type="text"
                        class="explore-input"
                        id="exploreInput"
                        placeholder=""
                        aria-label="Type your own response"
                        autocomplete="off"
                    >
                </div>
                <!-- Choice buttons for Yes/No interaction -->
                <div class="choice-buttons-container" id="choiceButtonsContainer" hidden>
                    <button class="choice-btn choice-btn-yes" id="choiceBtnYes">Yes</button>
                    <button class="choice-btn choice-btn-no" id="choiceBtnNo">No</button>
                </div>
                <!-- New Question button (appears after No selection) -->
                <button class="new-question-btn" id="newQuestionBtnChoice">New Question</button>
            </div>

            <!-- Response panels (hidden by default) -->
            <div class="explore-panels" id="explorePanels" aria-live="polite">
                <!-- Panel 1: I have ideas -->
                <article class="explore-panel" data-thought="0" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn0"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn0">New Question</button>
                    </div>
                </article>

                <!-- Panel 2: I don't know where to start -->
                <article class="explore-panel" data-thought="1" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn1"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn1">New Question</button>
                    </div>
                </article>

                <!-- Panel 3: Our tools don't fit us -->
                <article class="explore-panel" data-thought="2" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn2"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn2">New Question</button>
                    </div>
                </article>

                <!-- Panel 4: I want software that matches how we work -->
                <article class="explore-panel" data-thought="3" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn3"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn3">New Question</button>
                    </div>
                </article>

                <!-- Panel 5: Help us think this through -->
                <article class="explore-panel" data-thought="4" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn4"><span class="action-text"></span></button>
                        <button class="new-question-btn" id="newQuestionBtn4">New Question</button>
                    </div>
                </article>

                <!-- Panel 6: Who are you? -->
                <article class="explore-panel" data-thought="5" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn5"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 7: I need something custom -->
                <article class="explore-panel" data-thought="6" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn6"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 8: Our budget is limited -->
                <article class="explore-panel" data-thought="7" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn7"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 9: We've tried this before -->
                <article class="explore-panel" data-thought="8" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn8"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 10: How long will it take? -->
                <article class="explore-panel" data-thought="9" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn9"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 11: Can you work with our team? -->
                <article class="explore-panel" data-thought="10" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn10"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Panel 12: What makes you different? -->
                <article class="explore-panel" data-thought="11" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtn11"><span class="action-text"></span></button>
                    </div>
                </article>

                <!-- Generic panel for typed input -->
                <article class="explore-panel" data-thought="custom" hidden>
                    <p class="panel-response"><span class="response-text"></span></p>
                    <div class="explore-panel-actions">
                        <button class="explore-action-btn hidden" id="actionBtnCustom"><span class="action-text"></span></button>
                    </div>
                </article>
            </div>

        </div>
    </main>

    <!-- Multimedia Modal (for video/image actions) -->
    <div class="modal-overlay" id="multimediaModal" onclick="closeMultimediaModalOnOverlay(event)">
        <div class="modal-content multimedia-modal-content" role="dialog" aria-modal="true" aria-labelledby="multimediaTitle">
            <button class="modal-close" onclick="closeMultimediaModal()" aria-label="Close modal">&times;</button>
            <div id="multimediaContent" class="multimedia-container">
                <!-- Video iframe or image will be inserted here -->
            </div>
        </div>
    </div>

    <!-- The Matrix Canvas (for falling 0s and 1s animation) -->
    <canvas id="matrixCanvas" class="matrix-canvas"></canvas>

    <!-- ASCII Logo Container (for permanent terminal logos) -->
    <div id="asciiLogoContainer" class="ascii-logo-container"></div>

    <!-- Main Site Background Layer (z-index: 1) - Always loaded behind terminal -->
    <div id="mainSiteBackground" class="main-site-background">
        <iframe id="mainSiteFrame" src="" title="Main Site"></iframe>
    </div>

    <!-- Terminal Overlay Shell (z-index: 2) - Splits during earthquake transition -->
    <div id="terminalOverlay" class="terminal-overlay">
        <div class="terminal-half terminal-half-left"></div>
        <div class="terminal-half terminal-half-right"></div>
    </div>

    <!-- Contact Modal (reused from main site) -->
    <div class="modal-overlay" id="contactModal" onclick="closeModalOnOverlay(event)">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
            <button class="modal-close" onclick="closeContactModal()" aria-label="Close modal">&times;</button>
            <h2 id="modalTitle">Get in Touch</h2>
            <form class="modal-form" action="mailto:hello@imaginecraft.studio" method="GET" enctype="text/plain">
                <div class="form-group">
                    <label for="modalName">Name</label>
                    <input type="text" id="modalName" name="name" placeholder="Your name" required>
                </div>
                <div class="form-group">
                    <label for="modalEmail">Email</label>
                    <input type="email" id="modalEmail" name="email" placeholder="you@example.com" required>
                </div>
                <div class="form-group">
                    <label for="modalMessage">Message</label>
                    <textarea id="modalMessage" name="body" placeholder="Tell us about your project..." required></textarea>
                </div>
                <button type="submit" class="cta-button">Send Message</button>
            </form>
        </div>
    </div>

    <style>
        /* Boot Sequence Styles */
        .boot-sequence-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            padding: 40px;
            font-family: 'VT323', monospace;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .boot-sequence-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .boot-sequence-overlay.removed {
            display: none;
        }

        .boot-diagnostics {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .boot-line {
            font-size: 1.2rem;
            color: #34ff35;
            text-shadow: 0 0 8px rgba(52, 255, 53, 0.6);
            opacity: 0;
            transform: translateX(-10px);
            transition: opacity 0.1s ease, transform 0.1s ease;
        }

        .boot-line.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .boot-line.flicker {
            animation: crtFlicker 0.15s ease-in-out;
        }

        .boot-line .status {
            color: #34ff35;
        }

        @keyframes crtFlicker {
            0% { opacity: 0.3; transform: translateX(-2px); }
            25% { opacity: 1; transform: translateX(1px); }
            50% { opacity: 0.7; transform: translateX(-1px); }
            75% { opacity: 1; transform: translateX(0); }
            100% { opacity: 1; transform: translateX(0); }
        }

        .boot-progress-container {
            margin-top: 30px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .boot-progress-container.visible {
            opacity: 1;
        }

        .boot-progress-bar {
            font-size: 1.2rem;
            color: #34ff35;
            text-shadow: 0 0 8px rgba(52, 255, 53, 0.6);
            letter-spacing: 2px;
        }

        /* CRT scanline effect for boot sequence */
        .boot-sequence-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1;
        }

        .boot-diagnostics,
        .boot-progress-container {
            position: relative;
            z-index: 2;
        }

        /* Hide main content during boot */
        .explore-page.boot-hidden {
            visibility: hidden;
        }

        /* Transparent Effect Styles */
        .builders-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: #2a2a2a;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .builders-container.active {
            opacity: 1;
        }

        .builders-media {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Placeholder construction scene when no media is set */
        .builders-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #87CEEB 0%, #87CEEB 60%, #8B4513 60%, #8B4513 100%);
            position: relative;
            overflow: hidden;
        }

        .scaffold {
            position: absolute;
            bottom: 40%;
            left: 20%;
            width: 200px;
            height: 300px;
            border: 8px solid #654321;
            border-bottom: none;
            background: transparent;
        }

        .scaffold::before,
        .scaffold::after {
            content: '';
            position: absolute;
            background: #654321;
        }

        .scaffold::before {
            width: 100%;
            height: 8px;
            top: 50%;
        }

        .scaffold::after {
            width: 8px;
            height: 100%;
            left: 50%;
        }

        .scaffold-2 {
            left: auto;
            right: 25%;
            height: 250px;
        }

        .builder {
            position: absolute;
            bottom: 40%;
            z-index: 2;
        }

        .builder-1 {
            left: 25%;
        }

        .builder-2 {
            right: 30%;
        }

        .builder-body {
            width: 40px;
            height: 80px;
            background: linear-gradient(180deg, #FFD700 0%, #FFD700 30%, #1E90FF 30%, #1E90FF 100%);
            border-radius: 20px 20px 5px 5px;
            position: relative;
        }

        .builder-body::before {
            content: '';
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 30px;
            background: #FFE4C4;
            border-radius: 50%;
        }

        .builder-body::after {
            content: '';
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            width: 35px;
            height: 15px;
            background: #FFD700;
            border-radius: 50% 50% 0 0;
        }

        .hammer {
            position: absolute;
            top: 10px;
            right: -30px;
            width: 8px;
            height: 40px;
            background: #8B4513;
            transform-origin: bottom center;
            animation: hammerSwing 0.8s ease-in-out infinite;
        }

        .hammer::before {
            content: '';
            position: absolute;
            top: -12px;
            left: -8px;
            width: 24px;
            height: 15px;
            background: #696969;
            border-radius: 3px;
        }

        .builder-2 .hammer {
            animation-delay: 0.4s;
        }

        @keyframes hammerSwing {
            0%, 100% { transform: rotate(-30deg); }
            50% { transform: rotate(30deg); }
        }

        .builders-text {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'VT323', monospace;
            font-size: 3rem;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            letter-spacing: 0.2em;
        }

        /* Terminal fade effect */
        .explore-page.transparent-fade {
            animation: terminalFade 3s ease-in-out forwards;
        }

        @keyframes terminalFade {
            0% {
                background-color: rgba(0, 0, 0, 1);
            }
            100% {
                background-color: rgba(0, 0, 0, 0.15);
            }
        }

        .explore-page.transparent-fade .explore-container {
            animation: textFade 3s ease-in-out forwards;
        }

        @keyframes textFade {
            0% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
            100% {
                opacity: 0.3;
            }
        }

        /* Close button for transparent effect */
        .transparent-close-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10001;
            width: 50px;
            height: 50px;
            border: 2px solid #34ff35;
            background: rgba(0, 0, 0, 0.7);
            color: #34ff35;
            font-size: 2rem;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.5s ease, transform 0.2s ease, background-color 0.2s ease;
            font-family: 'VT323', monospace;
            text-shadow: 0 0 8px rgba(52, 255, 53, 0.6);
        }

        .transparent-close-btn.visible {
            opacity: 1;
        }

        .transparent-close-btn:hover {
            background: rgba(52, 255, 53, 0.2);
            transform: scale(1.1);
        }
    </style>

    <script>
        // ========================================
        // State Management
        // ========================================

        // Default thoughts and responses (12 total)
        const defaultThoughts = [
            "I have ideas.",
            "I don't know where to start.",
            "Our tools don't fit us.",
            "I want software that matches how we work.",
            "Help us think this through.",
            "Who are you?",
            "I need something custom.",
            "Our budget is limited.",
            "We've tried this before.",
            "How long will it take?",
            "Can you work with our team?",
            "What makes you different?"
        ];

        const defaultResponses = [
            "Starting is the hardest part. We will figure out the first step together.",
            "Who we are is less important than what we can build together.",
            "The right tools don't exist yet; we have to invent them.",
            "Complexity is the enemy. We specialize in radical simplicity.",
            "Your vision is the blueprint. Our code is the foundation.",
            "We're builders who believe software should feel inevitable.",
            "Custom is our specialty. Every solution we build is tailored.",
            "Great work doesn't require a fortune. Let's find what's possible.",
            "Past failures are lessons. We learn what didn't work and build better.",
            "Quality takes time, but we move with purpose. Let's set expectations.",
            "Collaboration is core to how we work. Your team becomes ours.",
            "We listen first. Then we build what actually matters to you."
        ];

        // Default settings
        const defaultHeroText = 'Why are you here?';

        // Load from localStorage or use defaults
        function loadThoughtsFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_thoughts');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load thoughts from localStorage:', e);
            }
            return defaultThoughts;
        }

        function loadResponsesFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_responses');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load responses from localStorage:', e);
            }
            return defaultResponses;
        }

        function loadHeroTextFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_hero_text');
                if (stored) {
                    return stored;
                }
            } catch (e) {
                console.warn('Failed to load hero text from localStorage:', e);
            }
            return defaultHeroText;
        }

        function loadActionsFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_actions');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load actions from localStorage:', e);
            }
            return [];
        }

        function loadActiveStatesFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_active_states');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load active states from localStorage:', e);
            }
            // Default: all questions are active
            return Array(12).fill(true);
        }

        function loadRandomizeEnabledFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_randomize_enabled');
                if (stored !== null) {
                    return stored === 'true';
                }
            } catch (e) {
                console.warn('Failed to load randomize setting from localStorage:', e);
            }
            return false; // Default: randomize disabled
        }

        // Load boot sequence enabled state from localStorage (admin configurable)
        function loadBootSequenceEnabledFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_boot_sequence_enabled');
                if (stored !== null) {
                    return stored === 'true';
                }
            } catch (e) {
                console.warn('Failed to load boot sequence setting from localStorage:', e);
            }
            return true; // Default: boot sequence enabled
        }

        // Check if boot sequence has already played this session
        function hasBootSequencePlayedThisSession() {
            try {
                return sessionStorage.getItem('imaginecraft_boot_sequence_played') === 'true';
            } catch (e) {
                return false;
            }
        }

        // Mark boot sequence as played for this session
        function markBootSequencePlayed() {
            try {
                sessionStorage.setItem('imaginecraft_boot_sequence_played', 'true');
            } catch (e) {
                console.warn('Failed to mark boot sequence as played:', e);
            }
        }

        const bootSequenceEnabled = loadBootSequenceEnabledFromStorage();

        // Load system mood from localStorage (admin configurable)
        function loadSystemMoodFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_system_mood');
                if (stored && ['stable', 'glitchy', 'urgent'].includes(stored)) {
                    return stored;
                }
            } catch (e) {
                console.warn('Failed to load system mood from localStorage:', e);
            }
            return 'stable'; // Default: stable mood
        }

        const systemMood = loadSystemMoodFromStorage();

        // ========================================
        // Secret Commands System
        // ========================================

        // Default secret commands
        const defaultSecretCommands = [
            { keyword: 'FOREST', action: 'earthquake', enabled: true, description: 'Triggers Earthquake & Split to reveal background' },
            { keyword: 'MATRIX', action: 'matrix', enabled: true, description: 'Toggles digital rain animation on/off' },
            { keyword: 'ADMIN', action: 'redirect', url: 'admin.html', enabled: true, description: 'Navigates to Admin Dashboard' },
            { keyword: 'WARP', action: 'warp', enabled: true, description: 'Star Wars style hyperspace jump to a distant galaxy' },
            { keyword: 'TRANSPARENT', action: 'transparent', enabled: true, description: 'Fades terminal to reveal the builders behind the screen' }
        ];

        // Load secret commands from localStorage
        function loadSecretCommandsFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_secret_commands');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load secret commands from localStorage:', e);
            }
            return [...defaultSecretCommands];
        }

        const secretCommands = loadSecretCommandsFromStorage();

        // Keystroke buffer for command detection
        let keystrokeBuffer = '';
        const maxBufferSize = 20; // Maximum characters to track
        let matrixToggleState = false; // Track matrix toggle state

        // Secret command visual feedback
        function showCommandFeedback() {
            const explorePage = document.querySelector('.explore-page');
            if (explorePage) {
                explorePage.classList.add('secret-command-activated');
                // Remove the class after animation completes
                setTimeout(() => {
                    explorePage.classList.remove('secret-command-activated');
                }, 600);
            }
        }

        // Execute secret command action
        function executeSecretCommand(command) {
            showCommandFeedback();

            switch (command.action) {
                case 'earthquake':
                    triggerSecretEarthquake();
                    break;
                case 'matrix':
                    toggleMatrixAnimation();
                    break;
                case 'warp':
                    triggerWarpAnimation();
                    break;
                case 'transparent':
                    triggerTransparentAnimation();
                    break;
                case 'redirect':
                    if (command.url) {
                        setTimeout(() => {
                            window.location.href = command.url;
                        }, 400);
                    }
                    break;
                case 'custom':
                    // For future custom actions
                    if (command.customFunction) {
                        try {
                            eval(command.customFunction);
                        } catch (e) {
                            console.warn('Failed to execute custom command:', e);
                        }
                    }
                    break;
            }
        }

        // Trigger earthquake without navigation (for secret command)
        function triggerSecretEarthquake() {
            const explorePage = document.querySelector('.explore-page');
            const terminalOverlay = document.getElementById('terminalOverlay');
            const background = document.getElementById('mainSiteBackground');
            const iframe = document.getElementById('mainSiteFrame');

            // Load main site if not already loaded
            if (iframe && !iframe.src) {
                iframe.src = 'main.html';
            }

            // Show background
            if (background) {
                background.classList.add('active');
            }

            // Apply quake time
            const actualQuakeTime = applyQuakeTimeVariable();
            const durationMs = actualQuakeTime * 1000;

            // Phase 1: Earthquake shake
            explorePage.classList.add('earthquake-shake');

            // After shake, split the terminal
            setTimeout(() => {
                terminalOverlay.classList.add('active');
                explorePage.style.visibility = 'hidden';

                setTimeout(() => {
                    terminalOverlay.classList.add('splitting');

                    // Navigate after split
                    setTimeout(() => {
                        window.location.href = 'main.html';
                    }, 800);
                }, 50);
            }, durationMs);
        }

        // Toggle matrix animation on/off
        function toggleMatrixAnimation() {
            if (state.matrixActive) {
                // Matrix is running - stop it
                const canvas = document.getElementById('matrixCanvas');
                if (canvas) {
                    canvas.classList.add('fade-out');
                    setTimeout(() => {
                        canvas.classList.remove('active', 'fade-out');
                        state.matrixActive = false;
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }, 500);
                }
            } else {
                // Start infinite matrix (not timed)
                triggerInfiniteMatrix();
            }
        }

        // Trigger matrix animation that runs until toggled off
        function triggerInfiniteMatrix() {
            if (state.matrixActive) return;

            state.matrixActive = true;
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.classList.remove('fade-out');
            canvas.classList.add('active');

            const fontSize = 14;
            const columns = Math.floor(canvas.width / fontSize);
            const drops = Array(columns).fill(1);

            function draw() {
                if (!state.matrixActive) return;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#34ff35';
                ctx.font = fontSize + 'px VT323, monospace';
                ctx.shadowColor = 'rgba(52, 255, 53, 0.5)';
                ctx.shadowBlur = 4;

                for (let i = 0; i < drops.length; i++) {
                    const char = Math.random() > 0.5 ? '1' : '0';
                    ctx.fillText(char, i * fontSize, drops[i] * fontSize);

                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }

                state.matrixAnimationId = requestAnimationFrame(draw);
            }

            draw();
        }

        // Trigger Star Wars style warp/hyperspace animation
        function triggerWarpAnimation() {
            // Create warp container
            const warpContainer = document.createElement('div');
            warpContainer.id = 'warpContainer';
            warpContainer.className = 'warp-container';
            document.body.appendChild(warpContainer);

            // Create canvas for starfield
            const canvas = document.createElement('canvas');
            canvas.id = 'warpCanvas';
            canvas.className = 'warp-canvas';
            warpContainer.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Star properties
            const stars = [];
            const numStars = 400;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Initialize stars at random positions
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width - centerX,
                    y: Math.random() * canvas.height - centerY,
                    z: Math.random() * 1500 + 500,
                    speed: Math.random() * 2 + 1
                });
            }

            let animationId;
            let startTime = Date.now();
            const warpDuration = 3000; // 3 seconds of warping

            function drawStars() {
                const elapsed = Date.now() - startTime;

                // Clear with fade trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Calculate warp intensity (accelerates over time)
                const progress = Math.min(elapsed / warpDuration, 1);
                const warpSpeed = 20 + (progress * 80); // Accelerate from 20 to 100

                for (let i = 0; i < stars.length; i++) {
                    const star = stars[i];

                    // Move star toward viewer
                    star.z -= warpSpeed * star.speed;

                    // Reset star if it passes the viewer
                    if (star.z <= 0) {
                        star.x = Math.random() * canvas.width - centerX;
                        star.y = Math.random() * canvas.height - centerY;
                        star.z = 1500;
                        star.speed = Math.random() * 2 + 1;
                    }

                    // Project 3D position to 2D
                    const scale = 500 / star.z;
                    const x2d = star.x * scale + centerX;
                    const y2d = star.y * scale + centerY;

                    // Calculate previous position for streak
                    const prevZ = star.z + warpSpeed * star.speed;
                    const prevScale = 500 / prevZ;
                    const prevX = star.x * prevScale + centerX;
                    const prevY = star.y * prevScale + centerY;

                    // Draw star streak (line from previous to current position)
                    const streakLength = Math.min(1, progress * 2); // Streaks grow with warp
                    const brightness = Math.min(255, 100 + (1500 - star.z) / 5);

                    ctx.beginPath();
                    ctx.moveTo(prevX, prevY);
                    ctx.lineTo(x2d, y2d);
                    ctx.strokeStyle = `rgba(${brightness}, ${brightness}, ${Math.min(255, brightness + 50)}, ${0.5 + streakLength * 0.5})`;
                    ctx.lineWidth = 1 + scale * 2 * streakLength;
                    ctx.stroke();

                    // Draw bright point at end of streak
                    ctx.beginPath();
                    ctx.arc(x2d, y2d, Math.max(0.5, scale * 1.5), 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 + streakLength * 0.2})`;
                    ctx.fill();
                }

                // Continue animation or transition to galaxy
                if (elapsed < warpDuration) {
                    animationId = requestAnimationFrame(drawStars);
                } else {
                    // Warp complete - show galaxy reveal
                    cancelAnimationFrame(animationId);
                    showGalaxyReveal(warpContainer);
                }
            }

            // Start warp animation
            warpContainer.classList.add('active');
            drawStars();
        }

        // Show galaxy image after warp
        function showGalaxyReveal(warpContainer) {
            // Create galaxy container
            const galaxyDiv = document.createElement('div');
            galaxyDiv.className = 'galaxy-reveal';

            // Placeholder galaxy image (colorful nebula/galaxy)
            galaxyDiv.innerHTML = `
                <div class="galaxy-content">
                    <div class="galaxy-placeholder">
                        <div class="galaxy-stars"></div>
                        <div class="galaxy-nebula"></div>
                        <div class="galaxy-center"></div>
                    </div>
                    <p class="galaxy-text">Destination: Unknown Galaxy</p>
                </div>
            `;

            warpContainer.appendChild(galaxyDiv);

            // Fade out canvas, fade in galaxy
            const canvas = warpContainer.querySelector('.warp-canvas');
            canvas.classList.add('fade-out');

            setTimeout(() => {
                galaxyDiv.classList.add('visible');
            }, 100);

            // Auto-close after viewing
            setTimeout(() => {
                warpContainer.classList.add('closing');
                setTimeout(() => {
                    warpContainer.remove();
                }, 1000);
            }, 4000);
        }

        // Load builders image/video URL from localStorage
        function loadBuildersMediaFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_builders_media');
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load builders media from localStorage:', e);
            }
            // Default placeholder image
            return {
                type: 'image',
                url: ''
            };
        }

        // Trigger Transparent animation - reveals builders behind the terminal
        function triggerTransparentAnimation() {
            const buildersMedia = loadBuildersMediaFromStorage();

            // Create builders background container
            const buildersContainer = document.createElement('div');
            buildersContainer.id = 'buildersContainer';
            buildersContainer.className = 'builders-container';

            // Add media content (image or video)
            if (buildersMedia.url) {
                if (buildersMedia.type === 'video') {
                    buildersContainer.innerHTML = `
                        <video class="builders-media" autoplay loop muted playsinline>
                            <source src="${buildersMedia.url}" type="video/mp4">
                        </video>
                    `;
                } else {
                    buildersContainer.innerHTML = `
                        <img class="builders-media" src="${buildersMedia.url}" alt="Construction Crew">
                    `;
                }
            } else {
                // Placeholder if no URL set - CSS animated construction scene
                buildersContainer.innerHTML = `
                    <div class="builders-placeholder">
                        <div class="builder builder-1">
                            <div class="builder-body"></div>
                            <div class="hammer"></div>
                        </div>
                        <div class="builder builder-2">
                            <div class="builder-body"></div>
                            <div class="hammer"></div>
                        </div>
                        <div class="scaffold"></div>
                        <div class="scaffold scaffold-2"></div>
                        <p class="builders-text">UNDER CONSTRUCTION</p>
                    </div>
                `;
            }

            // Insert builders behind the terminal
            document.body.insertBefore(buildersContainer, document.body.firstChild);

            // Get terminal elements
            const explorePage = document.querySelector('.explore-page');
            const bootOverlay = document.getElementById('bootSequenceOverlay');

            // Add close button overlay
            const closeBtn = document.createElement('button');
            closeBtn.className = 'transparent-close-btn';
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = () => closeTransparentEffect(buildersContainer, explorePage, closeBtn);
            document.body.appendChild(closeBtn);

            // Trigger fade animation
            requestAnimationFrame(() => {
                buildersContainer.classList.add('active');
                explorePage.classList.add('transparent-fade');
                if (bootOverlay) {
                    bootOverlay.style.display = 'none';
                }
                closeBtn.classList.add('visible');
            });
        }

        // Close transparent effect
        function closeTransparentEffect(buildersContainer, explorePage, closeBtn) {
            explorePage.classList.remove('transparent-fade');
            closeBtn.classList.remove('visible');

            setTimeout(() => {
                buildersContainer.remove();
                closeBtn.remove();
            }, 1000);
        }

        // Check keystroke buffer for matching commands
        function checkSecretCommands() {
            const buffer = keystrokeBuffer.toUpperCase();

            for (const command of secretCommands) {
                if (!command.enabled) continue;

                const keyword = command.keyword.toUpperCase();
                if (buffer.endsWith(keyword)) {
                    // Command matched! Clear buffer and execute
                    keystrokeBuffer = '';
                    executeSecretCommand(command);
                    return true;
                }
            }
            return false;
        }

        // Global keydown listener for secret commands
        document.addEventListener('keydown', (event) => {
            // Only track printable characters
            if (event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {
                keystrokeBuffer += event.key;

                // Trim buffer if too long
                if (keystrokeBuffer.length > maxBufferSize) {
                    keystrokeBuffer = keystrokeBuffer.slice(-maxBufferSize);
                }

                // Check for command matches
                checkSecretCommands();
            }
        });

        // Fisher-Yates shuffle algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        const allThoughts = loadThoughtsFromStorage();
        const allResponses = loadResponsesFromStorage();
        const heroText = loadHeroTextFromStorage();
        const actions = loadActionsFromStorage();
        const activeStates = loadActiveStatesFromStorage();
        const randomizeEnabled = loadRandomizeEnabledFromStorage();

        // Filter to only include active thoughts and track their original indices
        let activeIndices = [];
        let thoughts = [];
        let responses = [];
        for (let i = 0; i < allThoughts.length; i++) {
            // Default to active if no state is set
            if (activeStates[i] !== false) {
                activeIndices.push(i);
                thoughts.push(allThoughts[i]);
                responses.push(allResponses[i]);
            }
        }

        // Apply randomization if enabled
        if (randomizeEnabled && activeIndices.length > 0) {
            // Create array of indices into the active arrays
            const indices = activeIndices.map((_, idx) => idx);

            // Shuffle the indices
            const shuffledIndices = shuffleArray(indices);

            // Take up to 3 (or fewer if not enough active questions)
            const selectedCount = Math.min(3, shuffledIndices.length);
            const selectedIndices = shuffledIndices.slice(0, selectedCount);

            // Rebuild arrays with only the selected items
            const newActiveIndices = [];
            const newThoughts = [];
            const newResponses = [];

            for (const idx of selectedIndices) {
                newActiveIndices.push(activeIndices[idx]);
                newThoughts.push(thoughts[idx]);
                newResponses.push(responses[idx]);
            }

            activeIndices = newActiveIndices;
            thoughts = newThoughts;
            responses = newResponses;
        }

        // Load Matrix fade duration from localStorage (admin configurable)
        function loadMatrixFadeDurationFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_matrix_fade_duration');
                if (stored) {
                    return parseFloat(stored);
                }
            } catch (e) {
                console.warn('Failed to load matrix fade duration from localStorage:', e);
            }
            return 1.5; // Default fade duration in seconds
        }

        const matrixFadeDuration = loadMatrixFadeDurationFromStorage();

        // Load Earthquake duration from localStorage (admin configurable)
        function loadEarthquakeDurationFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_earthquake_duration');
                if (stored) {
                    return parseFloat(stored);
                }
            } catch (e) {
                console.warn('Failed to load earthquake duration from localStorage:', e);
            }
            return 1.5; // Default earthquake duration in seconds
        }

        const earthquakeDuration = loadEarthquakeDurationFromStorage();

        // Load Choice Buttons setting from localStorage (admin configurable)
        function loadChoiceButtonsEnabledFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_choice_buttons_enabled');
                if (stored !== null) {
                    return stored === 'true';
                }
            } catch (e) {
                console.warn('Failed to load choice buttons setting from localStorage:', e);
            }
            return false; // Default disabled
        }

        const choiceButtonsEnabled = loadChoiceButtonsEnabledFromStorage();

        let state = {
            currentIndex: 0,
            isUserTyping: false,
            isSelected: false,
            selectedIndex: null,
            cycleTimeout: null,
            animationTimeout: null,
            idleTimeout: null,        // Timeout for auto-cycling when no choice is made
            isAnimating: false,
            currentText: '',
            targetText: '',
            matrixActive: false,
            matrixAnimationId: null,
            waitingForChoice: false,  // Whether we're waiting for Yes/No button click
            heroTyped: false          // Whether the hero text has been typed
        };

        // Load typing speed from localStorage (admin configurable)
        function loadTypingSpeedFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_typing_speed');
                if (stored) {
                    return parseInt(stored, 10);
                }
            } catch (e) {
                console.warn('Failed to load typing speed from localStorage:', e);
            }
            return 150; // Default base speed
        }

        const baseTypingSpeed = loadTypingSpeedFromStorage();

        // Timing configuration (in ms) - uses admin-configurable base speed
        // Adjusted based on system mood
        function getTimingConfig() {
            const base = {
                initialDelay: 3000,
                typeSpeedMin: Math.max(50, baseTypingSpeed - 50),
                typeSpeedMax: baseTypingSpeed + 100,
                punctuationPause: 500,
                backspaceSpeedMin: 50,
                backspaceSpeedMax: 100,
                linger: 4000
            };

            switch (systemMood) {
                case 'glitchy':
                    // Glitchy: More irregular, stuttered rhythm with wider variance
                    return {
                        ...base,
                        typeSpeedMin: Math.max(30, baseTypingSpeed - 100),
                        typeSpeedMax: baseTypingSpeed + 200, // Wider range for irregular feel
                        punctuationPause: Math.random() > 0.5 ? 800 : 200, // Random pauses
                        backspaceSpeedMin: 30,
                        backspaceSpeedMax: 150,
                        linger: 3000
                    };
                case 'urgent':
                    // Urgent: Much faster typing
                    return {
                        ...base,
                        initialDelay: 1500, // Faster start
                        typeSpeedMin: Math.max(20, Math.floor(baseTypingSpeed * 0.3)),
                        typeSpeedMax: Math.floor(baseTypingSpeed * 0.5),
                        punctuationPause: 150, // Minimal pause
                        backspaceSpeedMin: 20,
                        backspaceSpeedMax: 50,
                        linger: 2000 // Shorter linger
                    };
                default: // 'stable'
                    return base;
            }
        }

        const timing = getTimingConfig();

        // Helper function for random delay between min and max
        function randomDelay(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Check if character is punctuation
        function isPunctuation(char) {
            return ['.', ',', '!', '?', ';', ':'].includes(char);
        }

        // Check for reduced motion preference
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        // ========================================
        // DOM Elements
        // ========================================
        const thoughtElement = document.getElementById('currentThought');
        const inputElement = document.getElementById('exploreInput');
        const panelsContainer = document.getElementById('explorePanels');
        const cursorElement = document.getElementById('exploreCursor');
        const choiceButtonsContainer = document.getElementById('choiceButtonsContainer');
        const choiceBtnYes = document.getElementById('choiceBtnYes');
        const choiceBtnNo = document.getElementById('choiceBtnNo');
        const heroElement = document.getElementById('exploreQuestion');

        // ========================================
        // Typing Animation
        // ========================================

        // Glitchy mode typing helper - occasionally repeats or stutters
        function getGlitchyDelay(baseMin, baseMax) {
            // 15% chance of a glitch effect
            if (Math.random() < 0.15) {
                const glitchType = Math.random();
                if (glitchType < 0.3) {
                    // Very fast burst
                    return randomDelay(10, 30);
                } else if (glitchType < 0.6) {
                    // Long stutter pause
                    return randomDelay(300, 600);
                } else {
                    // Normal with jitter
                    return randomDelay(baseMin, baseMax) + (Math.random() > 0.5 ? 100 : -30);
                }
            }
            return randomDelay(baseMin, baseMax);
        }

        function typeCharacter(text, index, callback) {
            if (state.isUserTyping || state.isSelected) return;

            if (index <= text.length) {
                state.currentText = text.substring(0, index);
                thoughtElement.textContent = state.currentText;

                // Calculate delay - longer after punctuation, variable otherwise
                let delay = 0;
                if (!prefersReducedMotion) {
                    const lastChar = text.charAt(index - 1);
                    if (isPunctuation(lastChar)) {
                        // Glitchy mood has random punctuation pauses
                        delay = systemMood === 'glitchy'
                            ? (Math.random() > 0.5 ? timing.punctuationPause * 1.5 : timing.punctuationPause * 0.3)
                            : timing.punctuationPause;
                    } else {
                        // Use glitchy delay for glitchy mood
                        delay = systemMood === 'glitchy'
                            ? getGlitchyDelay(timing.typeSpeedMin, timing.typeSpeedMax)
                            : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                    }
                }

                state.animationTimeout = setTimeout(() => {
                    typeCharacter(text, index + 1, callback);
                }, delay);
            } else {
                if (callback) callback();
            }
        }

        function backspaceCharacter(callback) {
            if (state.isUserTyping || state.isSelected) return;

            if (state.currentText.length > 0) {
                state.currentText = state.currentText.substring(0, state.currentText.length - 1);
                thoughtElement.textContent = state.currentText;

                // Random jitter for backspace speed
                const delay = prefersReducedMotion ? 0 : randomDelay(timing.backspaceSpeedMin, timing.backspaceSpeedMax);

                state.animationTimeout = setTimeout(() => {
                    backspaceCharacter(callback);
                }, delay);
            } else {
                if (callback) callback();
            }
        }

        function showThought(index) {
            if (state.isUserTyping || state.isSelected || state.isAnimating) return;

            state.isAnimating = true;
            const thought = thoughts[index];
            state.targetText = thought;
            thoughtElement.dataset.index = index;

            // Make thought visible and start typing
            thoughtElement.classList.remove('fade-out');
            thoughtElement.classList.add('visible', 'fade-in');

            // Type out the thought character by character
            typeCharacter(thought, 0, () => {
                if (choiceButtonsEnabled) {
                    // Show choice buttons and wait for user interaction
                    state.waitingForChoice = true;
                    showChoiceButtons();

                    // Start idle timeout - if user doesn't interact, trigger backspace like "No"
                    state.idleTimeout = setTimeout(() => {
                        if (state.waitingForChoice && !state.isUserTyping && !state.isSelected) {
                            triggerBackspaceAndNext(true);
                        }
                    }, timing.linger);
                } else {
                    // Original behavior: Linger for 3 seconds after fully typed
                    state.cycleTimeout = setTimeout(() => {
                        if (!state.isUserTyping && !state.isSelected) {
                            // Backspace the thought
                            backspaceCharacter(() => {
                                state.isAnimating = false;
                                // Move to next thought
                                state.currentIndex = (state.currentIndex + 1) % thoughts.length;
                                showThought(state.currentIndex);
                            });
                        }
                    }, timing.linger);
                }
            });
        }

        // Show choice buttons with animation
        function showChoiceButtons() {
            if (choiceButtonsContainer) {
                // Reset any previous selection state
                choiceButtonsContainer.classList.remove('selection-made');
                const yesBtn = document.getElementById('choiceBtnYes');
                const noBtn = document.getElementById('choiceBtnNo');
                if (yesBtn) yesBtn.classList.remove('selected');
                if (noBtn) noBtn.classList.remove('selected');

                // Hide the New Question button in choice area
                hideNewQuestionButton('choice');

                choiceButtonsContainer.hidden = false;
                // Trigger animation after a brief delay
                setTimeout(() => {
                    choiceButtonsContainer.classList.add('visible');
                }, 50);
            }
        }

        // Hide choice buttons
        function hideChoiceButtons() {
            if (choiceButtonsContainer) {
                choiceButtonsContainer.classList.remove('visible');
                setTimeout(() => {
                    choiceButtonsContainer.hidden = true;
                }, 300); // Wait for fade out transition
            }
        }

        // Mark a choice button as selected (persistent visual state)
        function markChoiceSelection(choice) {
            if (!choiceButtonsContainer) return;

            // Add selection-made class to disable further interaction
            choiceButtonsContainer.classList.add('selection-made');

            // Add selected class to the chosen button
            const yesBtn = document.getElementById('choiceBtnYes');
            const noBtn = document.getElementById('choiceBtnNo');

            if (choice === 'yes' && yesBtn) {
                yesBtn.classList.add('selected');
            } else if (choice === 'no' && noBtn) {
                noBtn.classList.add('selected');
            }
        }

        // Reset choice buttons to initial state
        function resetChoiceButtons() {
            if (!choiceButtonsContainer) return;

            // Remove all state classes from container
            choiceButtonsContainer.classList.remove('selection-made', 'visible', 'fading-out');
            choiceButtonsContainer.hidden = true;

            // Remove all state classes from buttons
            const yesBtn = document.getElementById('choiceBtnYes');
            const noBtn = document.getElementById('choiceBtnNo');
            if (yesBtn) {
                yesBtn.classList.remove('selected', 'disabled', 'btn-active');
            }
            if (noBtn) {
                noBtn.classList.remove('selected', 'disabled', 'btn-active');
            }

            // Hide the New Question button in choice area
            hideNewQuestionButton('choice');
        }

        // Type out New Question button text character by character
        function typeNewQuestionText(btn, text, index, callback) {
            if (!btn) {
                if (callback) callback();
                return;
            }

            if (index <= text.length) {
                // Show cursor after text
                btn.innerHTML = text.substring(0, index) + '<span class="typing-cursor">â–ˆ</span>';

                const delay = prefersReducedMotion ? 0 : randomDelay(50, 100);
                setTimeout(() => {
                    typeNewQuestionText(btn, text, index + 1, callback);
                }, delay);
            } else {
                // Typing complete - show final text without cursor
                btn.textContent = text;
                if (callback) callback();
            }
        }

        // Show New Question button with typing animation
        function showNewQuestionButton(location) {
            let btn;
            if (location === 'choice') {
                btn = document.getElementById('newQuestionBtnChoice');
            } else if (typeof location === 'number') {
                btn = document.getElementById('newQuestionBtn' + location);
            }

            if (btn) {
                const buttonText = 'New Question';
                // Clear initial text for typing
                btn.textContent = '';
                // Make visible but not interactive during typing
                btn.classList.add('visible');
                btn.style.pointerEvents = 'none';

                // Type out the button text
                setTimeout(() => {
                    typeNewQuestionText(btn, buttonText, 0, () => {
                        // Enable interaction after typing completes
                        btn.style.pointerEvents = 'auto';
                    });
                }, 200);
            }
        }

        // Hide New Question button
        function hideNewQuestionButton(location) {
            let btn;
            if (location === 'choice') {
                btn = document.getElementById('newQuestionBtnChoice');
            } else if (typeof location === 'number') {
                btn = document.getElementById('newQuestionBtn' + location);
            }

            if (btn) {
                btn.classList.remove('visible');
                btn.style.pointerEvents = '';
                btn.textContent = 'New Question';
            }
        }

        // Hide all New Question buttons
        function hideAllNewQuestionButtons() {
            const choiceBtn = document.getElementById('newQuestionBtnChoice');
            if (choiceBtn) {
                choiceBtn.classList.remove('visible');
                choiceBtn.style.pointerEvents = '';
                choiceBtn.textContent = 'New Question';
            }

            // Loop through all possible panel buttons (up to 50 for dynamic thoughts)
            for (let i = 0; i < 50; i++) {
                const panelBtn = document.getElementById('newQuestionBtn' + i);
                if (panelBtn) {
                    panelBtn.classList.remove('visible');
                    panelBtn.style.pointerEvents = '';
                    panelBtn.textContent = 'New Question';
                }
            }
        }

        // Handle Yes button click - trigger the response
        function handleChoiceYes() {
            if (!state.waitingForChoice) return;

            // Immediately prevent multiple clicks
            state.waitingForChoice = false;

            // Clear idle timeout since user made a choice
            clearTimeout(state.idleTimeout);
            state.idleTimeout = null;

            // Add flash feedback effect
            const yesBtn = document.getElementById('choiceBtnYes');
            if (yesBtn) {
                yesBtn.classList.add('btn-active');
                setTimeout(() => {
                    yesBtn.classList.remove('btn-active');
                }, 150);
            }

            // Mark selection made and highlight Yes button (don't hide buttons)
            markChoiceSelection('yes');

            // Trigger the thought selection (shows response panel)
            selectThought(state.currentIndex);
        }

        // Unified function to trigger backspace animation and move to next thought
        // Used by both "No" button click and idle timeout
        function triggerBackspaceAndNext(isTimeout = false) {
            if (!state.waitingForChoice) return;

            // Immediately prevent multiple clicks
            state.waitingForChoice = false;

            // Clear any pending idle timeout
            clearTimeout(state.idleTimeout);
            state.idleTimeout = null;

            const container = document.getElementById('choiceButtonsContainer');

            if (isTimeout) {
                // Timeout: fade out buttons smoothly, then backspace
                if (container) {
                    container.classList.add('fading-out');
                }

                // Wait for fade animation to complete before backspacing
                setTimeout(() => {
                    hideChoiceButtons();
                    if (container) {
                        container.classList.remove('fading-out');
                    }

                    // Backspace the current thought and move to next
                    backspaceCharacter(() => {
                        state.isAnimating = false;
                        // Reset buttons for next thought
                        resetChoiceButtons();
                        // Move to next thought
                        state.currentIndex = (state.currentIndex + 1) % thoughts.length;
                        showThought(state.currentIndex);
                    });
                }, 500); // Match the CSS fade-out transition duration
            } else {
                // User clicked "No": show flash feedback, keep visible but disabled
                const noBtn = document.getElementById('choiceBtnNo');
                const yesBtn = document.getElementById('choiceBtnYes');

                if (noBtn) {
                    // Flash effect
                    noBtn.classList.add('btn-active');
                    setTimeout(() => {
                        noBtn.classList.remove('btn-active');
                    }, 180);
                }

                // Mark selection and disable buttons (they stay visible)
                markChoiceSelection('no');

                // Disable both buttons visually
                if (noBtn) noBtn.classList.add('disabled');
                if (yesBtn) yesBtn.classList.add('disabled');

                // Immediately start backspace animation after flash
                setTimeout(() => {
                    backspaceCharacter(() => {
                        state.isAnimating = false;
                        // Move to next thought
                        state.currentIndex = (state.currentIndex + 1) % thoughts.length;
                        showThought(state.currentIndex);
                    });
                }, 200);
            }
        }

        // Handle No button click - backspace and move to next thought
        function handleChoiceNo() {
            triggerBackspaceAndNext(false);
        }

        function startCycling() {
            // Check if there are any active thoughts to cycle
            if (thoughts.length === 0) {
                // No active thoughts - show cursor but display fallback message
                cursorElement.classList.add('visible');
                thoughtElement.textContent = 'No questions available';
                thoughtElement.classList.add('visible', 'fade-in');
                return;
            }

            // If hero was typed, cursor is already visible and we skip the initial delay
            // (the 1.5s pause after hero typing serves as the delay)
            if (state.heroTyped) {
                showThought(state.currentIndex);
            } else {
                // Original behavior: Show cursor after initial delay, then start cycling thoughts
                state.cycleTimeout = setTimeout(() => {
                    cursorElement.classList.add('visible');
                    showThought(state.currentIndex);
                }, timing.initialDelay);
            }
        }

        function stopCycling() {
            clearTimeout(state.cycleTimeout);
            clearTimeout(state.animationTimeout);
            clearTimeout(state.idleTimeout);
            state.isAnimating = false;
        }

        // ========================================
        // Thought Selection
        // ========================================
        // Helper to get original index from filtered index
        function getOriginalIndex(filteredIndex) {
            if (typeof filteredIndex === 'number' && activeIndices[filteredIndex] !== undefined) {
                return activeIndices[filteredIndex];
            }
            return filteredIndex; // Return as-is for 'custom' or invalid
        }

        function selectThought(index) {
            state.isSelected = true;
            state.selectedIndex = index;
            // Sync currentIndex for sequential cycling continuity
            if (typeof index === 'number') {
                state.currentIndex = index;
            }
            stopCycling();

            // If we're selecting a cycling thought, show the full text
            if (typeof index === 'number' && thoughts[index]) {
                thoughtElement.textContent = thoughts[index];
                state.currentText = thoughts[index];
            }

            // Lock the thought in place
            thoughtElement.classList.add('selected');
            thoughtElement.classList.remove('fade-out', 'fade-in');
            thoughtElement.setAttribute('aria-pressed', 'true');

            // Hide cursor from thought line (it will appear in response)
            cursorElement.classList.remove('visible');

            // Get the original index for panel lookup
            const originalIndex = getOriginalIndex(index);

            // Show the corresponding panel using original index
            showPanel(index, originalIndex);
        }

        function showPanel(filteredIndex, originalIndex) {
            const panels = panelsContainer.querySelectorAll('.explore-panel');
            // Use original index for panel data-thought lookup, filtered index for responses array
            const panelId = typeof originalIndex === 'number' ? originalIndex : filteredIndex;

            panels.forEach(panel => {
                if (panel.dataset.thought === String(panelId)) {
                    panel.hidden = false;
                    panel.classList.add('visible');

                    // Get panel elements
                    const responseEl = panel.querySelector('.panel-response');
                    const textEl = panel.querySelector('.response-text');
                    const actionsEl = panel.querySelector('.explore-panel-actions');
                    const actionBtn = panel.querySelector('.explore-action-btn');

                    if (responseEl && textEl) {
                        // Get response from filtered responses array
                        const fullResponse = (typeof filteredIndex === 'number' && responses[filteredIndex])
                            ? responses[filteredIndex]
                            : "Every project starts with a conversation. Let's start ours.";
                        textEl.textContent = '';

                        // Clear action button text
                        if (actionBtn) {
                            const actionText = actionBtn.querySelector('.action-text');
                            if (actionText) actionText.textContent = '';
                            actionBtn.classList.add('hidden');
                        }

                        // Hide actions initially
                        if (actionsEl) actionsEl.classList.remove('visible');

                        // Start sequential typing: response -> action button
                        // Pass original index for action lookup
                        typePanelResponse(textEl, actionsEl, actionBtn, fullResponse, 0, originalIndex);
                    }

                    // Focus the panel for accessibility
                    setTimeout(() => {
                        const focusTarget = panel.querySelector('.panel-response') || panel.querySelector('h2');
                        if (focusTarget) focusTarget.focus();
                    }, 100);
                } else {
                    panel.hidden = true;
                    panel.classList.remove('visible');
                    // Clear any response text when hiding
                    const textEl = panel.querySelector('.response-text');
                    const actionsEl = panel.querySelector('.explore-panel-actions');
                    if (textEl) textEl.textContent = '';
                    if (actionsEl) actionsEl.classList.remove('visible');
                }
            });

            panelsContainer.classList.add('visible');
        }

        function typePanelResponse(textEl, actionsEl, actionBtn, text, charIndex, panelIndex) {
            if (charIndex <= text.length) {
                // Show cursor after text
                textEl.innerHTML = text.substring(0, charIndex) + '<span class="typing-cursor">â–ˆ</span>';

                let delay = 0;
                if (!prefersReducedMotion) {
                    const lastChar = text.charAt(charIndex - 1);
                    if (isPunctuation(lastChar)) {
                        // Glitchy mood has random punctuation pauses
                        delay = systemMood === 'glitchy'
                            ? (Math.random() > 0.5 ? timing.punctuationPause * 1.5 : timing.punctuationPause * 0.3)
                            : timing.punctuationPause;
                    } else {
                        // Use glitchy delay for glitchy mood
                        delay = systemMood === 'glitchy'
                            ? getGlitchyDelay(timing.typeSpeedMin, timing.typeSpeedMax)
                            : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                    }
                }

                setTimeout(() => {
                    typePanelResponse(textEl, actionsEl, actionBtn, text, charIndex + 1, panelIndex);
                }, delay);
            } else {
                // Response typing complete - remove cursor from response
                textEl.textContent = text;

                // Show action button if this thought has an action configured
                showActionButton(actionsEl, actionBtn, panelIndex);
            }
        }

        function showActionButton(actionsEl, actionBtn, panelIndex) {
            // Check if this panel has an action
            const action = (typeof panelIndex === 'number' && actions[panelIndex]) ? actions[panelIndex] : null;
            const hasAction = action && action.type && action.type !== 'none';

            if (hasAction && actionBtn) {
                // Show actions container
                if (actionsEl) {
                    actionsEl.classList.add('visible');
                }

                const actionLinkText = action.linkText || 'Click here';
                actionBtn.classList.remove('hidden');

                // Type out the action button text
                typeActionText(actionBtn, actionLinkText, 0, () => {
                    // Set up action button handler
                    actionBtn.classList.add('ready');
                    actionBtn.onclick = () => executeAction(action);

                    // Stop cursor blinking - typing is complete
                    cursorElement.classList.add('cursor-stopped');

                    // Show New Question button after action is ready
                    showNewQuestionButton(panelIndex);
                });
            } else {
                // No action configured - just stop cursor blinking
                cursorElement.classList.add('cursor-stopped');

                // Show New Question button even if no action
                if (typeof panelIndex === 'number') {
                    if (actionsEl) {
                        actionsEl.classList.add('visible');
                    }
                    showNewQuestionButton(panelIndex);
                }
            }
        }

        function typeActionText(btn, text, index, callback) {
            if (!btn) {
                if (callback) callback();
                return;
            }

            const textSpan = btn.querySelector('.action-text');
            if (!textSpan) {
                if (callback) callback();
                return;
            }

            if (index <= text.length) {
                // Show cursor after text
                textSpan.innerHTML = text.substring(0, index) + '<span class="typing-cursor">â–ˆ</span>';

                const delay = prefersReducedMotion ? 0 : randomDelay(60, 120);
                setTimeout(() => {
                    typeActionText(btn, text, index + 1, callback);
                }, delay);
            } else {
                // Typing complete - show final text without cursor
                textSpan.textContent = text;
                if (callback) callback();
            }
        }

        // ========================================
        // Action Execution
        // ========================================
        function executeAction(action) {
            if (!action || !action.type) return;

            switch (action.type) {
                case 'video':
                    openVideoModal(action.url);
                    break;
                case 'image':
                    openImageModal(action.url);
                    break;
                case 'logo':
                    printAsciiLogo(action.logo);
                    break;
                case 'matrix':
                    triggerMatrixAnimation();
                    break;
                case 'contact':
                    openContactModal();
                    break;
            }
        }

        // ========================================
        // Multimedia Modal (Video/Image)
        // ========================================
        function openVideoModal(url) {
            if (!url) return;

            const modal = document.getElementById('multimediaModal');
            const content = document.getElementById('multimediaContent');

            // Extract video ID from YouTube URL
            let videoId = '';
            const urlPatterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\s?]+)/,
                /youtube\.com\/shorts\/([^&\s?]+)/
            ];

            for (const pattern of urlPatterns) {
                const match = url.match(pattern);
                if (match) {
                    videoId = match[1];
                    break;
                }
            }

            if (videoId) {
                content.innerHTML = `
                    <iframe
                        src="https://www.youtube.com/embed/${videoId}?autoplay=1"
                        frameborder="0"
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen>
                    </iframe>
                `;
            } else {
                // Fallback: try embedding as-is
                content.innerHTML = `
                    <iframe
                        src="${url}"
                        frameborder="0"
                        allowfullscreen>
                    </iframe>
                `;
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function openImageModal(url) {
            if (!url) return;

            const modal = document.getElementById('multimediaModal');
            const content = document.getElementById('multimediaContent');

            content.innerHTML = `<img src="${url}" alt="Image content" class="modal-image">`;

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeMultimediaModal() {
            const modal = document.getElementById('multimediaModal');
            const content = document.getElementById('multimediaContent');

            modal.classList.remove('active');
            document.body.style.overflow = '';

            // Clear content to stop video playback
            setTimeout(() => {
                content.innerHTML = '';
            }, 300);
        }

        function closeMultimediaModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeMultimediaModal();
            }
        }

        // ========================================
        // ASCII Logo Printing
        // ========================================
        function printAsciiLogo(logoText) {
            if (!logoText) return;

            const container = document.getElementById('asciiLogoContainer');

            // Clear any existing content
            container.innerHTML = '';

            // Create wrapper for positioning the close button
            const wrapper = document.createElement('div');
            wrapper.className = 'ascii-logo-wrapper';

            // Create home link that wraps the logo
            const homeLink = document.createElement('a');
            homeLink.className = 'ascii-logo-home-link';
            homeLink.href = 'index.html';
            homeLink.setAttribute('aria-label', 'Return to home and reset terminal');
            homeLink.onclick = function(e) {
                e.preventDefault();
                closeAsciiLogo();
                resetExplore();
            };

            // Create close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'ascii-logo-close';
            closeBtn.textContent = 'X';
            closeBtn.setAttribute('aria-label', 'Close logo');
            closeBtn.onclick = function(e) {
                e.stopPropagation();
                closeAsciiLogo();
            };

            // Create logo element
            const logoElement = document.createElement('pre');
            logoElement.className = 'ascii-logo';
            logoElement.textContent = '';

            // Structure: wrapper > homeLink > logoElement, wrapper > closeBtn
            homeLink.appendChild(logoElement);
            wrapper.appendChild(homeLink);
            wrapper.appendChild(closeBtn);
            container.appendChild(wrapper);

            // Show the container
            container.classList.add('visible');

            // Type out the logo character by character
            typeAsciiLogo(logoElement, logoText, 0);
        }

        function typeAsciiLogo(element, text, index) {
            if (index <= text.length) {
                element.textContent = text.substring(0, index);

                // Faster typing for ASCII art
                const delay = prefersReducedMotion ? 0 : randomDelay(5, 15);
                setTimeout(() => {
                    typeAsciiLogo(element, text, index + 1);
                }, delay);
            }
        }

        function closeAsciiLogo() {
            const container = document.getElementById('asciiLogoContainer');
            container.classList.remove('visible');
            // Clear content after hiding
            setTimeout(() => {
                container.innerHTML = '';
            }, 300);
        }

        // ========================================
        // The Matrix Animation
        // ========================================
        function triggerMatrixAnimation() {
            if (state.matrixActive) return;

            state.matrixActive = true;
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas to full screen
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.classList.remove('fade-out');
            canvas.classList.add('active');

            const fontSize = 14;
            const columns = Math.floor(canvas.width / fontSize);
            const drops = Array(columns).fill(1);

            function draw() {
                // Semi-transparent black background for trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Green text - updated to #34ff35
                ctx.fillStyle = '#34ff35';
                ctx.font = fontSize + 'px VT323, monospace';
                ctx.shadowColor = 'rgba(52, 255, 53, 0.5)';
                ctx.shadowBlur = 4;

                for (let i = 0; i < drops.length; i++) {
                    // Random 0 or 1
                    const char = Math.random() > 0.5 ? '1' : '0';
                    ctx.fillText(char, i * fontSize, drops[i] * fontSize);

                    // Reset drop when it reaches bottom or randomly
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
            }

            // Run animation for 5 seconds
            const interval = setInterval(draw, 50);

            setTimeout(() => {
                clearInterval(interval);

                // Apply dynamic fade duration from admin settings
                const fadeDurationMs = matrixFadeDuration * 1000;
                canvas.style.transition = `opacity ${matrixFadeDuration}s ease`;

                // Start fade-out transition
                canvas.classList.add('fade-out');

                // After fade-out completes, clean up
                setTimeout(() => {
                    canvas.classList.remove('active', 'fade-out');
                    canvas.style.transition = ''; // Reset to CSS default
                    state.matrixActive = false;
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }, fadeDurationMs);
            }, 5000);
        }

        // Handle window resize for Matrix canvas
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('matrixCanvas');
            if (canvas.classList.contains('active')) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        });

        function resetExplore() {
            state.isSelected = false;
            state.isUserTyping = false;
            state.isAnimating = false;
            state.waitingForChoice = false;
            // Clear any pending timeouts
            clearTimeout(state.idleTimeout);
            state.idleTimeout = null;
            // Advance to the next thought in sequence (don't reset to 0)
            state.currentIndex = (state.currentIndex + 1) % thoughts.length;
            state.selectedIndex = null;
            state.currentText = '';
            state.targetText = '';

            // Reset thought element
            thoughtElement.classList.remove('selected', 'visible', 'fade-in', 'fade-out');
            thoughtElement.textContent = '';
            thoughtElement.removeAttribute('aria-pressed');

            // Hide cursor initially (will be shown after delay when cycling restarts)
            cursorElement.classList.remove('visible', 'cursor-stopped');

            // Reset choice buttons to initial state
            resetChoiceButtons();

            // Hide all New Question buttons
            hideAllNewQuestionButtons();

            // Hide all panels and reset their elements
            const panels = panelsContainer.querySelectorAll('.explore-panel');
            panels.forEach(panel => {
                panel.hidden = true;
                panel.classList.remove('visible');
                // Reset panel elements
                const textEl = panel.querySelector('.response-text');
                const actionsEl = panel.querySelector('.explore-panel-actions');
                const actionBtn = panel.querySelector('.explore-action-btn');

                if (textEl) textEl.textContent = '';
                if (actionsEl) actionsEl.classList.remove('visible');
                if (actionBtn) {
                    actionBtn.classList.remove('ready');
                    actionBtn.classList.add('hidden');
                    actionBtn.onclick = null;
                    const actionTextSpan = actionBtn.querySelector('.action-text');
                    if (actionTextSpan) actionTextSpan.textContent = '';
                }
            });
            panelsContainer.classList.remove('visible');

            // Clear input
            inputElement.value = '';
            inputElement.classList.remove('active');

            // Restart cycling
            startCycling();
        }

        // ========================================
        // Input Handling
        // ========================================
        function handleInputChange() {
            const hasValue = inputElement.value.trim().length > 0;

            if (hasValue && !state.isUserTyping) {
                state.isUserTyping = true;
                stopCycling();
                thoughtElement.classList.remove('visible', 'fade-in', 'fade-out');
                thoughtElement.textContent = '';
                state.currentText = '';
                inputElement.classList.add('active');
            } else if (!hasValue && state.isUserTyping) {
                state.isUserTyping = false;
                inputElement.classList.remove('active');
                if (!state.isSelected) {
                    startCycling();
                }
            }
        }

        function handleInputKeydown(event) {
            if (event.key === 'Enter' && inputElement.value.trim()) {
                event.preventDefault();
                selectThought('custom');
            }
        }

        // ========================================
        // Event Listeners
        // ========================================
        // Event delegation on parent container for thought clicks
        // This ensures clicks work even while text is being typed/re-rendered
        document.querySelector('.explore-thought-container').addEventListener('click', (event) => {
            const thought = event.target.closest('.explore-thought');
            if (thought && thought.classList.contains('visible') && !state.isSelected) {
                const index = parseInt(thought.dataset.index, 10);
                selectThought(index);
            }
        });

        // Event delegation for keyboard accessibility
        document.querySelector('.explore-thought-container').addEventListener('keydown', (event) => {
            const thought = event.target.closest('.explore-thought');
            if ((event.key === 'Enter' || event.key === ' ') &&
                thought && thought.classList.contains('visible') &&
                !state.isSelected) {
                event.preventDefault();
                const index = parseInt(thought.dataset.index, 10);
                selectThought(index);
            }
        });

        inputElement.addEventListener('input', handleInputChange);
        inputElement.addEventListener('keydown', handleInputKeydown);

        // Focus input when clicking anywhere in question area
        document.querySelector('.explore-question-area').addEventListener('click', (event) => {
            if (!event.target.closest('.explore-thought') && !state.isSelected) {
                inputElement.focus();
            }
        });

        // ========================================
        // Contact Modal (reused)
        // ========================================
        function openContactModal() {
            document.getElementById('contactModal').classList.add('active');
            document.body.style.overflow = 'hidden';
            document.getElementById('modalName').focus();
        }

        function closeContactModal() {
            document.getElementById('contactModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        function closeModalOnOverlay(event) {
            if (event.target === event.currentTarget) {
                closeContactModal();
            }
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                closeContactModal();
                closeMultimediaModal();
            }
        });

        // ========================================
        // Earthquake Transition
        // ========================================
        function loadEarthquakeSettingFromStorage() {
            try {
                const stored = localStorage.getItem('imaginecraft_earthquake_enabled');
                if (stored !== null) {
                    return stored === 'true';
                }
            } catch (e) {
                console.warn('Failed to load earthquake setting from localStorage:', e);
            }
            return true; // Default to enabled
        }

        const earthquakeEnabled = loadEarthquakeSettingFromStorage();

        // Apply --quake-time CSS variable from localStorage immediately
        // Urgent mood increases earthquake duration by 50% for more dramatic effect
        function applyQuakeTimeVariable() {
            let quakeTime = earthquakeDuration; // Already loaded from localStorage

            // Urgent mood gets 50% longer and more intense earthquake
            if (systemMood === 'urgent') {
                quakeTime = quakeTime * 1.5;
            }

            document.documentElement.style.setProperty('--quake-time', `${quakeTime}s`);
            return quakeTime;
        }

        // Preload main.html content as background layer when earthquake is enabled
        // Superman Logic: Main site is ALWAYS rendered behind terminal
        function preloadMainSite() {
            const iframe = document.getElementById('mainSiteFrame');
            const background = document.getElementById('mainSiteBackground');

            if (earthquakeEnabled) {
                // Load main site immediately so it's ready behind the terminal
                if (iframe && !iframe.src) {
                    iframe.src = 'main.html';
                }
                // Mark as preloaded (main site is now rendering behind terminal)
                if (background) {
                    background.classList.add('preloaded');
                }
            }
        }

        // Execute earthquake transition - True Superman reveal style
        function triggerEarthquakeTransition(event) {
            if (!earthquakeEnabled) {
                // Normal navigation
                return true;
            }

            // Prevent default navigation
            event.preventDefault();

            const explorePage = document.querySelector('.explore-page');
            const terminalOverlay = document.getElementById('terminalOverlay');
            const background = document.getElementById('mainSiteBackground');
            const iframe = document.getElementById('mainSiteFrame');

            // Ensure iframe is loaded (should already be preloaded)
            if (!iframe.src) {
                iframe.src = 'main.html';
            }

            // The main site background is ALREADY visible (z-index: 1)
            // The terminal (explore-page) covers it (z-index: 2)
            // Mark background as active to ensure visibility
            if (background) {
                background.classList.add('active');
            }

            // Apply --quake-time variable before animation starts
            // Returns the actual quake time (may be modified for urgent mood)
            const actualQuakeTime = applyQuakeTimeVariable();
            const durationMs = actualQuakeTime * 1000;

            // Phase 1: Earthquake shake on the explore page (terminal layer only)
            // The main site stays static behind it
            explorePage.classList.add('earthquake-shake');

            // After shake completes, trigger the terminal split
            setTimeout(() => {
                // Phase 2: Activate terminal overlay (the shell that splits)
                // This overlay sits at z-index: 3, above the terminal content
                terminalOverlay.classList.add('active');

                // Hide the explore page content so only the overlay shows
                explorePage.style.visibility = 'hidden';

                // Small delay then crack/split the terminal shell
                setTimeout(() => {
                    terminalOverlay.classList.add('splitting');

                    // Phase 3: After split animation (0.8s), navigate to main.html
                    // The main site is already visible through the cracks
                    setTimeout(() => {
                        window.location.href = 'main.html';
                    }, 800);
                }, 50);
            }, durationMs);

            return false;
        }

        // Attach earthquake transition to all Main Site links
        function attachEarthquakeHandlers() {
            // Get all "Enter Main Site" links
            const mainSiteLinks = document.querySelectorAll('.explore-link');
            mainSiteLinks.forEach(link => {
                link.addEventListener('click', triggerEarthquakeTransition);
            });
        }

        // ========================================
        // Boot Sequence Animation
        // ========================================
        function runBootSequence(callback) {
            const overlay = document.getElementById('bootSequenceOverlay');
            const diagnostics = document.getElementById('bootDiagnostics');
            const progressContainer = document.getElementById('bootProgressContainer');
            const progressBar = document.getElementById('bootProgressBar');
            const explorePage = document.querySelector('.explore-page');

            if (!overlay) {
                if (callback) callback();
                return;
            }

            // Hide main content during boot
            if (explorePage) {
                explorePage.classList.add('boot-hidden');
            }

            const bootLines = diagnostics.querySelectorAll('.boot-line');
            let currentLine = 0;

            // Phase 1: Show diagnostic lines with flicker effect
            function showNextDiagnosticLine() {
                if (currentLine < bootLines.length) {
                    const line = bootLines[currentLine];
                    line.classList.add('flicker');

                    // After flicker animation, make it visible
                    setTimeout(() => {
                        line.classList.add('visible');
                        line.classList.remove('flicker');
                        currentLine++;

                        // Random delay between lines (80-200ms) for that mechanical feel
                        const delay = Math.floor(Math.random() * 120) + 80;
                        setTimeout(showNextDiagnosticLine, delay);
                    }, 150);
                } else {
                    // All diagnostic lines shown, start progress bar
                    setTimeout(startProgressBar, 300);
                }
            }

            // Phase 2: Animate the progress bar
            function startProgressBar() {
                progressContainer.classList.add('visible');

                let progress = 0;
                const totalDuration = 1800; // 1.8 seconds total
                const updateInterval = 50; // Update every 50ms
                const steps = totalDuration / updateInterval;
                const progressPerStep = 100 / steps;

                const progressInterval = setInterval(() => {
                    progress += progressPerStep;
                    if (progress >= 100) {
                        progress = 100;
                        clearInterval(progressInterval);

                        // Update final progress bar
                        updateProgressBar(100);

                        // Phase 3: Fade out and transition to main terminal
                        setTimeout(finishBootSequence, 200);
                    } else {
                        updateProgressBar(Math.floor(progress));
                    }
                }, updateInterval);
            }

            function updateProgressBar(percent) {
                const filled = Math.floor(percent / 5); // 20 characters total
                const empty = 20 - filled;
                const bar = '[' + '#'.repeat(filled) + '-'.repeat(empty) + '] ' + percent + '%';
                progressBar.textContent = bar;
            }

            // Phase 3: Finish boot sequence and reveal main terminal
            function finishBootSequence() {
                // Fade out the overlay
                overlay.classList.add('hidden');

                // Show main content
                if (explorePage) {
                    explorePage.classList.remove('boot-hidden');
                }

                // After fade transition, remove overlay completely
                setTimeout(() => {
                    overlay.classList.add('removed');

                    // Mark as played for this session
                    markBootSequencePlayed();

                    // Trigger the callback (start main terminal)
                    if (callback) callback();
                }, 300);
            }

            // Start the boot sequence
            showNextDiagnosticLine();
        }

        function skipBootSequence() {
            const overlay = document.getElementById('bootSequenceOverlay');
            const explorePage = document.querySelector('.explore-page');

            if (overlay) {
                overlay.classList.add('removed');
            }
            if (explorePage) {
                explorePage.classList.remove('boot-hidden');
            }
        }

        // ========================================
        // Initialize
        // ========================================
        document.addEventListener('DOMContentLoaded', () => {
            // Apply system mood CSS class to explore page
            const explorePage = document.querySelector('.explore-page');
            if (explorePage && systemMood !== 'stable') {
                explorePage.classList.add(`mood-${systemMood}`);
            }

            // Clear hero text initially (will be typed out)
            if (heroElement && heroText) {
                heroElement.textContent = '';
                heroElement.dataset.fullText = heroText;
            }

            // Apply reduced motion adjustments
            if (prefersReducedMotion) {
                timing.fadeIn = 0;
                timing.fadeOut = 0;
                timing.linger = 5000;
            }

            // Apply --quake-time CSS variable from localStorage on page load
            applyQuakeTimeVariable();

            // Initialize earthquake transition
            attachEarthquakeHandlers();
            preloadMainSite();

            // Attach choice button event listeners
            if (choiceBtnYes) {
                choiceBtnYes.addEventListener('click', handleChoiceYes);
            }
            if (choiceBtnNo) {
                choiceBtnNo.addEventListener('click', handleChoiceNo);
            }

            // Attach New Question button event listeners
            const newQuestionBtnChoice = document.getElementById('newQuestionBtnChoice');
            if (newQuestionBtnChoice) {
                newQuestionBtnChoice.addEventListener('click', resetExplore);
            }

            // Attach event listeners to all panel New Question buttons
            for (let i = 0; i < 5; i++) {
                const btn = document.getElementById('newQuestionBtn' + i);
                if (btn) {
                    btn.addEventListener('click', resetExplore);
                }
            }

            // Type out hero text character by character
            function typeHeroText(callback) {
                const fullText = heroElement.dataset.fullText || heroText;
                let index = 0;

                function typeNextChar() {
                    if (index <= fullText.length) {
                        heroElement.textContent = fullText.substring(0, index);
                        index++;

                        // Calculate delay for each character
                        let delay = prefersReducedMotion ? 0 : randomDelay(timing.typeSpeedMin, timing.typeSpeedMax);
                        const lastChar = fullText.charAt(index - 1);
                        if (isPunctuation(lastChar)) {
                            delay = timing.punctuationPause;
                        }

                        state.animationTimeout = setTimeout(typeNextChar, delay);
                    } else {
                        // Hero text finished typing
                        state.heroTyped = true;
                        if (callback) callback();
                    }
                }

                typeNextChar();
            }

            // Function to start the main terminal experience
            function initializeTerminal() {
                // Type hero text first, then pause, then start cycling thoughts
                typeHeroText(() => {
                    // 1.5 second pause with blinking cursor after hero finishes
                    cursorElement.classList.add('visible');

                    setTimeout(() => {
                        // Now start cycling thoughts
                        startCycling();
                    }, 1500);
                });
            }

            // Check if boot sequence should run
            const shouldRunBootSequence = bootSequenceEnabled &&
                                          !hasBootSequencePlayedThisSession() &&
                                          !prefersReducedMotion;

            if (shouldRunBootSequence) {
                // Run boot sequence, then initialize terminal
                runBootSequence(initializeTerminal);
            } else {
                // Skip boot sequence, initialize terminal immediately
                skipBootSequence();
                initializeTerminal();
            }
        });
    </script>
</body>
</html>
